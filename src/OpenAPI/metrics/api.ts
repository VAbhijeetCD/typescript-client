const BASE_PATH = "https://api.chatdaddy.tech/metrics".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Metrics Service
 * Query aggregate metrics
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @enum {string}
 */

export const Aggregate = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;

export type Aggregate = typeof Aggregate[keyof typeof Aggregate];


/**
 * Describe an array
 * @export
 * @interface ArrayPropertyDescriptor
 */
interface ArrayPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof ArrayPropertyDescriptor
     */
    'type': ArrayPropertyDescriptorTypeEnum;
    /**
     * 
     * @type {DataPropertyDescriptor}
     * @memberof ArrayPropertyDescriptor
     */
    'items': DataPropertyDescriptor;
}

const ArrayPropertyDescriptorTypeEnum = {
    Array: 'array'
} as const;

type ArrayPropertyDescriptorTypeEnum = typeof ArrayPropertyDescriptorTypeEnum[keyof typeof ArrayPropertyDescriptorTypeEnum];

/**
 * 
 * @export
 * @interface ConditionalPropertyOption
 */
interface ConditionalPropertyOption {
    /**
     * Stringified value of the option.
     * @type {string}
     * @memberof ConditionalPropertyOption
     */
    'valueStr': string;
    /**
     * 
     * @type {string}
     * @memberof ConditionalPropertyOption
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface DashboardCreate
 */
export interface DashboardCreate {
    /**
     * 
     * @type {string}
     * @memberof DashboardCreate
     */
    'name': string;
    /**
     * 
     * @type {DashboardSchema}
     * @memberof DashboardCreate
     */
    'schema': DashboardSchema;
}
/**
 * 
 * @export
 * @interface DashboardData
 */
export interface DashboardData {
    /**
     * 
     * @type {Array<MetricsResult>}
     * @memberof DashboardData
     */
    'data': Array<MetricsResult>;
    /**
     * 
     * @type {Array<MetricsResultV2>}
     * @memberof DashboardData
     */
    'dataV2'?: Array<MetricsResultV2>;
}
/**
 * 
 * @export
 * @interface DashboardMetadata
 */
export interface DashboardMetadata {
    /**
     * 
     * @type {string}
     * @memberof DashboardMetadata
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMetadata
     */
    'name': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DashboardMetadata
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DashboardMetadata
     */
    'updatedAt': string;
    /**
     * 
     * @type {DashboardSchema}
     * @memberof DashboardMetadata
     */
    'schema': DashboardSchema;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DashboardPeriod = {
    MonthToDate: 'month-to-date',
    QuarterToDate: 'quarter-to-date',
    YearToDate: 'year-to-date',
    Last4Weeks: 'last-4-weeks',
    Last12Weeks: 'last-12-weeks',
    Custom: 'custom'
} as const;

export type DashboardPeriod = typeof DashboardPeriod[keyof typeof DashboardPeriod];


/**
 * @type DashboardSchema
 * @export
 */
export type DashboardSchema = DashboardSchemaV1 | DashboardSchemaV2;

/**
 * 
 * @export
 * @interface DashboardSchemaItem
 */
export interface DashboardSchemaItem {
    /**
     * 
     * @type {MetricType}
     * @memberof DashboardSchemaItem
     */
    'metric': MetricType;
    /**
     * 
     * @type {DataAggregateType}
     * @memberof DashboardSchemaItem
     */
    'aggregate': DataAggregateType;
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaItem
     */
    'key'?: string;
}


/**
 * 
 * @export
 * @interface DashboardSchemaItemV2
 */
export interface DashboardSchemaItemV2 {
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaItemV2
     */
    'id': string;
    /**
     * 
     * @type {DashboardVisualizationType}
     * @memberof DashboardSchemaItemV2
     */
    'visualizationType': DashboardVisualizationType;
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaItemV2
     */
    'metricId': string;
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaItemV2
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DashboardSchemaItemV2
     */
    'filter'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaItemV2
     */
    'breakdown'?: string;
    /**
     * Hide the default value in the breakdown.
     * @type {boolean}
     * @memberof DashboardSchemaItemV2
     */
    'hideDefaultInBreakdown'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardSchemaItemV2
     */
    'includePreviousPeriod'?: boolean;
}


/**
 * 
 * @export
 * @interface DashboardSchemaV1
 */
export interface DashboardSchemaV1 {
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaV1
     */
    'version'?: DashboardSchemaV1VersionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardSchemaV1
     */
    'includePreviousPeriod'?: boolean;
    /**
     * 
     * @type {Array<DashboardSchemaItem>}
     * @memberof DashboardSchemaV1
     */
    'items': Array<DashboardSchemaItem>;
}

export const DashboardSchemaV1VersionEnum = {
    1: '1'
} as const;

export type DashboardSchemaV1VersionEnum = typeof DashboardSchemaV1VersionEnum[keyof typeof DashboardSchemaV1VersionEnum];

/**
 * 
 * @export
 * @interface DashboardSchemaV2
 */
export interface DashboardSchemaV2 {
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaV2
     */
    'version': DashboardSchemaV2VersionEnum;
    /**
     * 
     * @type {Array<DashboardSchemaItemV2>}
     * @memberof DashboardSchemaV2
     */
    'items': Array<DashboardSchemaItemV2>;
}

export const DashboardSchemaV2VersionEnum = {
    2: '2'
} as const;

export type DashboardSchemaV2VersionEnum = typeof DashboardSchemaV2VersionEnum[keyof typeof DashboardSchemaV2VersionEnum];

/**
 * 
 * @export
 * @interface DashboardUpdate
 */
export interface DashboardUpdate {
    /**
     * 
     * @type {string}
     * @memberof DashboardUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {DashboardSchema}
     * @memberof DashboardUpdate
     */
    'schema'?: DashboardSchema;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DashboardVisualizationType = {
    Histogram: 'histogram',
    Total: 'total'
} as const;

export type DashboardVisualizationType = typeof DashboardVisualizationType[keyof typeof DashboardVisualizationType];


/**
 * 
 * @export
 * @interface DashboardWithData
 */
export interface DashboardWithData {
    /**
     * 
     * @type {string}
     * @memberof DashboardWithData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DashboardWithData
     */
    'name': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DashboardWithData
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DashboardWithData
     */
    'updatedAt': string;
    /**
     * 
     * @type {DashboardSchema}
     * @memberof DashboardWithData
     */
    'schema': DashboardSchema;
    /**
     * 
     * @type {Array<MetricsResult>}
     * @memberof DashboardWithData
     */
    'data': Array<MetricsResult>;
    /**
     * 
     * @type {Array<MetricsResultV2>}
     * @memberof DashboardWithData
     */
    'dataV2'?: Array<MetricsResultV2>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DataAggregateType = {
    Avg: 'avg',
    Sum: 'sum'
} as const;

export type DataAggregateType = typeof DataAggregateType[keyof typeof DataAggregateType];


/**
 * Description of a property
 * @export
 * @interface DataProperty
 */
type DataProperty = DataPropertyDescriptor & PropertyMetadata
/**
 * @type DataPropertyDescriptor
 * @export
 */
type DataPropertyDescriptor = SimplePropertyDescriptor | ArrayPropertyDescriptor | MapPropertyDescriptor | OAuthPropertyDescriptor;

/**
 * 
 * @export
 * @interface DateRange
 */
export interface DateRange {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'start': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface DisplayIcon
 */
interface DisplayIcon {
    /**
     * Material symbol name
     * @type {string}
     * @memberof DisplayIcon
     */
    'name': string;
    /**
     * Color name, hex code or theme color
     * @type {string}
     * @memberof DisplayIcon
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface GetDashboardBySchemaRequest
 */
export interface GetDashboardBySchemaRequest {
    /**
     * 
     * @type {DashboardSchema}
     * @memberof GetDashboardBySchemaRequest
     */
    'schema': DashboardSchema;
}
/**
 * 
 * @export
 * @interface GetDashboardMetadatas200Response
 */
export interface GetDashboardMetadatas200Response {
    /**
     * 
     * @type {Array<DashboardMetadata>}
     * @memberof GetDashboardMetadatas200Response
     */
    'items': Array<DashboardMetadata>;
}
/**
 * 
 * @export
 * @interface GetMetricsConfig200Response
 */
export interface GetMetricsConfig200Response {
    /**
     * 
     * @type {Array<MetricConfig>}
     * @memberof GetMetricsConfig200Response
     */
    'items': Array<MetricConfig>;
}
/**
 * Describe a map
 * @export
 * @interface MapPropertyDescriptor
 */
interface MapPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof MapPropertyDescriptor
     */
    'type': MapPropertyDescriptorTypeEnum;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof MapPropertyDescriptor
     */
    'properties': Array<DataProperty>;
    /**
     * 
     * @type {DataPropertyDescriptor}
     * @memberof MapPropertyDescriptor
     */
    'additionalProperties'?: DataPropertyDescriptor;
}

const MapPropertyDescriptorTypeEnum = {
    Map: 'map'
} as const;

type MapPropertyDescriptorTypeEnum = typeof MapPropertyDescriptorTypeEnum[keyof typeof MapPropertyDescriptorTypeEnum];

/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Metric
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface MetricConfig
 */
export interface MetricConfig {
    /**
     * 
     * @type {string}
     * @memberof MetricConfig
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricConfig
     */
    'defaultName': string;
    /**
     * 
     * @type {string}
     * @memberof MetricConfig
     */
    'description'?: string;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof MetricConfig
     */
    'properties': Array<DataProperty>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricType = {
    MessagesSentByUser: 'messages-sent-by-user',
    MessagesSentByAccount: 'messages-sent-by-account',
    MessagesRecvByChat: 'messages-recv-by-chat',
    AvgResponseTimeByUser: 'avg-response-time-by-user',
    MessageReplyRateByUser: 'message-reply-rate-by-user',
    TasksAddedByUser: 'tasks-added-by-user',
    TasksSolvedByUser: 'tasks-solved-by-user',
    TasksAddedByChat: 'tasks-added-by-chat',
    ContactsTaggedByTag: 'contacts-tagged-by-tag',
    MessageFlowsSentByFlowId: 'message-flows-sent-by-flow-id',
    MessageFlowsCompletedByFlowId: 'message-flows-completed-by-flow-id',
    MessageFlowClickRateByFlowId: 'message-flow-click-rate-by-flow-id',
    PaymentRecvByPhone: 'payment-recv-by-phone',
    OrdersRecvByPhone: 'orders-recv-by-phone',
    NewChats: 'new-chats'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * 
 * @export
 * @interface MetricsResult
 */
export interface MetricsResult {
    /**
     * 
     * @type {Array<Metric>}
     * @memberof MetricsResult
     */
    'metrics': Array<Metric>;
    /**
     * 
     * @type {Array<Metric>}
     * @memberof MetricsResult
     */
    'previousMetrics'?: Array<Metric>;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricsResult
     */
    'type': MetricType;
    /**
     * 
     * @type {DataAggregateType}
     * @memberof MetricsResult
     */
    'dataAggregate': DataAggregateType;
    /**
     * 
     * @type {string}
     * @memberof MetricsResult
     */
    'key'?: string;
}


/**
 * @type MetricsResultV2
 * @export
 */
export type MetricsResultV2 = MetricsResultV2Histogram | MetricsResultV2Total;

/**
 * 
 * @export
 * @interface MetricsResultV2Histogram
 */
export interface MetricsResultV2Histogram {
    /**
     * 
     * @type {string}
     * @memberof MetricsResultV2Histogram
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsResultV2Histogram
     */
    'visualizationType': MetricsResultV2HistogramVisualizationTypeEnum;
    /**
     * 
     * @type {{ [key: string]: Array<Metric>; }}
     * @memberof MetricsResultV2Histogram
     */
    'lines': { [key: string]: Array<Metric>; };
    /**
     * 
     * @type {{ [key: string]: Array<Metric>; }}
     * @memberof MetricsResultV2Histogram
     */
    'previousPeriodLines'?: { [key: string]: Array<Metric>; };
}

export const MetricsResultV2HistogramVisualizationTypeEnum = {
    Histogram: 'histogram'
} as const;

export type MetricsResultV2HistogramVisualizationTypeEnum = typeof MetricsResultV2HistogramVisualizationTypeEnum[keyof typeof MetricsResultV2HistogramVisualizationTypeEnum];

/**
 * 
 * @export
 * @interface MetricsResultV2Total
 */
export interface MetricsResultV2Total {
    /**
     * 
     * @type {string}
     * @memberof MetricsResultV2Total
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsResultV2Total
     */
    'visualizationType': MetricsResultV2TotalVisualizationTypeEnum;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof MetricsResultV2Total
     */
    'values': { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof MetricsResultV2Total
     */
    'previousPeriodValues'?: { [key: string]: { [key: string]: number; }; };
}

export const MetricsResultV2TotalVisualizationTypeEnum = {
    Total: 'total'
} as const;

export type MetricsResultV2TotalVisualizationTypeEnum = typeof MetricsResultV2TotalVisualizationTypeEnum[keyof typeof MetricsResultV2TotalVisualizationTypeEnum];

/**
 * describe OAuth input for access tokens
 * @export
 * @interface OAuthPropertyDescriptor
 */
interface OAuthPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof OAuthPropertyDescriptor
     */
    'type': OAuthPropertyDescriptorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OAuthPropertyDescriptor
     */
    'url'?: string;
}

const OAuthPropertyDescriptorTypeEnum = {
    Oauth: 'oauth'
} as const;

type OAuthPropertyDescriptorTypeEnum = typeof OAuthPropertyDescriptorTypeEnum[keyof typeof OAuthPropertyDescriptorTypeEnum];

/**
 * 
 * @export
 * @interface PropertyMetadata
 */
interface PropertyMetadata {
    /**
     * 
     * @type {string}
     * @memberof PropertyMetadata
     */
    'propertyPath': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMetadata
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {DisplayIcon}
     * @memberof PropertyMetadata
     */
    'icon'?: DisplayIcon;
    /**
     * Is the property always expected to be present.
     * @type {boolean}
     * @memberof PropertyMetadata
     */
    'required'?: boolean;
}
/**
 * Simple string/number/boolean type
 * @export
 * @interface SimplePropertyDescriptor
 */
interface SimplePropertyDescriptor {
    /**
     * 
     * @type {SimplePropertyType}
     * @memberof SimplePropertyDescriptor
     */
    'type': SimplePropertyType;
    /**
     * 
     * @type {Array<ConditionalPropertyOption>}
     * @memberof SimplePropertyDescriptor
     */
    'options'?: Array<ConditionalPropertyOption>;
    /**
     * Format of the property.  Only valid for string type. For example, \'date-time\' for timestamp properties
     * @type {string}
     * @memberof SimplePropertyDescriptor
     */
    'format'?: string;
    /**
     * Minimum number of stages required in the board for the condition to be valid. Only valid for \"board\" type
     * @type {number}
     * @memberof SimplePropertyDescriptor
     */
    'minimumStages'?: number;
}


/**
 * Type of property. - string, number, boolean: Simple property type - timestamp: timestamp string in ISO format - timezone: timezone in offset format - time: time in 24 hour format - channel, tag, team_member, chat, board_stage, board, ticket:     Reference to another object by ID - custom_field: Object of type { name: string, value: string } - duration: integer representing seconds 
 * @export
 * @enum {string}
 */

const SimplePropertyType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Channel: 'channel',
    Tag: 'tag',
    CustomField: 'custom_field',
    Timestamp: 'timestamp',
    CountryCode: 'country_code',
    TeamMember: 'team_member',
    Chat: 'chat',
    BoardStage: 'board_stage',
    Duration: 'duration',
    Ticket: 'ticket',
    Board: 'board',
    Oauth: 'oauth',
    Timezone: 'timezone',
    Time: 'time'
} as const;

type SimplePropertyType = typeof SimplePropertyType[keyof typeof SimplePropertyType];



/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new dashboard metadata
         * @param {DashboardCreate} [dashboardCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardMetadata: async (dashboardCreate?: DashboardCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/metadatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dashboardCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dashboard metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardMetadata: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDashboardMetadata', 'id', id)
            const localVarPath = `/dashboard/metadatas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard data
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {string} [id] Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard: async (period: DashboardPeriod, aggregate: Aggregate, id?: string, customDateRange?: DateRange, timezoneOffset?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getDashboard', 'period', period)
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getDashboard', 'aggregate', aggregate)
            const localVarPath = `/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (customDateRange !== undefined) {
                localVarQueryParameter['customDateRange'] = customDateRange;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard data by schema
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {GetDashboardBySchemaRequest} [getDashboardBySchemaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardBySchema: async (period: DashboardPeriod, aggregate: Aggregate, customDateRange?: DateRange, timezoneOffset?: string, getDashboardBySchemaRequest?: GetDashboardBySchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getDashboardBySchema', 'period', period)
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getDashboardBySchema', 'aggregate', aggregate)
            const localVarPath = `/dashboard/get-by-schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (customDateRange !== undefined) {
                localVarQueryParameter['customDateRange'] = customDateRange;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getDashboardBySchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard metadatas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardMetadatas: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/metadatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a dashboard metadata
         * @param {string} id 
         * @param {DashboardUpdate} [dashboardUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboardMetadata: async (id: string, dashboardUpdate?: DashboardUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDashboardMetadata', 'id', id)
            const localVarPath = `/dashboard/metadatas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dashboardUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new dashboard metadata
         * @param {DashboardCreate} [dashboardCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboardMetadata(dashboardCreate?: DashboardCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboardMetadata(dashboardCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a dashboard metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDashboardMetadata(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDashboardMetadata(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get dashboard data
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {string} [id] Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboard(period: DashboardPeriod, aggregate: Aggregate, id?: string, customDateRange?: DateRange, timezoneOffset?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardWithData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboard(period, aggregate, id, customDateRange, timezoneOffset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get dashboard data by schema
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {GetDashboardBySchemaRequest} [getDashboardBySchemaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardBySchema(period: DashboardPeriod, aggregate: Aggregate, customDateRange?: DateRange, timezoneOffset?: string, getDashboardBySchemaRequest?: GetDashboardBySchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardBySchema(period, aggregate, customDateRange, timezoneOffset, getDashboardBySchemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get dashboard metadatas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardMetadatas(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDashboardMetadatas200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardMetadatas(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a dashboard metadata
         * @param {string} id 
         * @param {DashboardUpdate} [dashboardUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDashboardMetadata(id: string, dashboardUpdate?: DashboardUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDashboardMetadata(id, dashboardUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new dashboard metadata
         * @param {DashboardApiCreateDashboardMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardMetadata(requestParameters: DashboardApiCreateDashboardMetadataRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DashboardMetadata> {
            return localVarFp.createDashboardMetadata(requestParameters.dashboardCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a dashboard metadata
         * @param {DashboardApiDeleteDashboardMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardMetadata(requestParameters: DashboardApiDeleteDashboardMetadataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDashboardMetadata(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard data
         * @param {DashboardApiGetDashboardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(requestParameters: DashboardApiGetDashboardRequest, options?: AxiosRequestConfig): AxiosPromise<DashboardWithData> {
            return localVarFp.getDashboard(requestParameters.period, requestParameters.aggregate, requestParameters.id, requestParameters.customDateRange, requestParameters.timezoneOffset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard data by schema
         * @param {DashboardApiGetDashboardBySchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardBySchema(requestParameters: DashboardApiGetDashboardBySchemaRequest, options?: AxiosRequestConfig): AxiosPromise<DashboardData> {
            return localVarFp.getDashboardBySchema(requestParameters.period, requestParameters.aggregate, requestParameters.customDateRange, requestParameters.timezoneOffset, requestParameters.getDashboardBySchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard metadatas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardMetadatas(options?: AxiosRequestConfig): AxiosPromise<GetDashboardMetadatas200Response> {
            return localVarFp.getDashboardMetadatas(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a dashboard metadata
         * @param {DashboardApiUpdateDashboardMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboardMetadata(requestParameters: DashboardApiUpdateDashboardMetadataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDashboardMetadata(requestParameters.id, requestParameters.dashboardUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDashboardMetadata operation in DashboardApi.
 * @export
 * @interface DashboardApiCreateDashboardMetadataRequest
 */
export interface DashboardApiCreateDashboardMetadataRequest {
    /**
     * 
     * @type {DashboardCreate}
     * @memberof DashboardApiCreateDashboardMetadata
     */
    readonly dashboardCreate?: DashboardCreate
}

/**
 * Request parameters for deleteDashboardMetadata operation in DashboardApi.
 * @export
 * @interface DashboardApiDeleteDashboardMetadataRequest
 */
export interface DashboardApiDeleteDashboardMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof DashboardApiDeleteDashboardMetadata
     */
    readonly id: string
}

/**
 * Request parameters for getDashboard operation in DashboardApi.
 * @export
 * @interface DashboardApiGetDashboardRequest
 */
export interface DashboardApiGetDashboardRequest {
    /**
     * 
     * @type {DashboardPeriod}
     * @memberof DashboardApiGetDashboard
     */
    readonly period: DashboardPeriod

    /**
     * Timeframe to aggregate the data in.
     * @type {Aggregate}
     * @memberof DashboardApiGetDashboard
     */
    readonly aggregate: Aggregate

    /**
     * Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
     * @type {string}
     * @memberof DashboardApiGetDashboard
     */
    readonly id?: string

    /**
     * Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
     * @type {DateRange}
     * @memberof DashboardApiGetDashboard
     */
    readonly customDateRange?: DateRange

    /**
     * Timezone offset to query the data in.
     * @type {string}
     * @memberof DashboardApiGetDashboard
     */
    readonly timezoneOffset?: string
}

/**
 * Request parameters for getDashboardBySchema operation in DashboardApi.
 * @export
 * @interface DashboardApiGetDashboardBySchemaRequest
 */
export interface DashboardApiGetDashboardBySchemaRequest {
    /**
     * 
     * @type {DashboardPeriod}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly period: DashboardPeriod

    /**
     * Timeframe to aggregate the data in.
     * @type {Aggregate}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly aggregate: Aggregate

    /**
     * Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
     * @type {DateRange}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly customDateRange?: DateRange

    /**
     * Timezone offset to query the data in.
     * @type {string}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly timezoneOffset?: string

    /**
     * 
     * @type {GetDashboardBySchemaRequest}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly getDashboardBySchemaRequest?: GetDashboardBySchemaRequest
}

/**
 * Request parameters for updateDashboardMetadata operation in DashboardApi.
 * @export
 * @interface DashboardApiUpdateDashboardMetadataRequest
 */
export interface DashboardApiUpdateDashboardMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof DashboardApiUpdateDashboardMetadata
     */
    readonly id: string

    /**
     * 
     * @type {DashboardUpdate}
     * @memberof DashboardApiUpdateDashboardMetadata
     */
    readonly dashboardUpdate?: DashboardUpdate
}

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * 
     * @summary Create a new dashboard metadata
     * @param {DashboardApiCreateDashboardMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public createDashboardMetadata(requestParameters: DashboardApiCreateDashboardMetadataRequest = {}, options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).createDashboardMetadata(requestParameters.dashboardCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a dashboard metadata
     * @param {DashboardApiDeleteDashboardMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public deleteDashboardMetadata(requestParameters: DashboardApiDeleteDashboardMetadataRequest, options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).deleteDashboardMetadata(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard data
     * @param {DashboardApiGetDashboardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboard(requestParameters: DashboardApiGetDashboardRequest, options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboard(requestParameters.period, requestParameters.aggregate, requestParameters.id, requestParameters.customDateRange, requestParameters.timezoneOffset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard data by schema
     * @param {DashboardApiGetDashboardBySchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardBySchema(requestParameters: DashboardApiGetDashboardBySchemaRequest, options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardBySchema(requestParameters.period, requestParameters.aggregate, requestParameters.customDateRange, requestParameters.timezoneOffset, requestParameters.getDashboardBySchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard metadatas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardMetadatas(options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardMetadatas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a dashboard metadata
     * @param {DashboardApiUpdateDashboardMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public updateDashboardMetadata(requestParameters: DashboardApiUpdateDashboardMetadataRequest, options?: AxiosRequestConfig) {
        return DashboardApiFp(this.configuration).updateDashboardMetadata(requestParameters.id, requestParameters.dashboardUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get metrics configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get metrics configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricsConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetricsConfig200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get metrics configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricsConfig(options?: AxiosRequestConfig): AxiosPromise<GetMetricsConfig200Response> {
            return localVarFp.getMetricsConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * 
     * @summary Get metrics configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetricsConfig(options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetricsConfig(options).then((request) => request(this.axios, this.basePath));
    }
}


