const BASE_PATH = "https://api-metrics.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Metrics Service
 * Query aggregate metrics
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @enum {string}
 */

export const Aggregate = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;

export type Aggregate = typeof Aggregate[keyof typeof Aggregate];


/**
 * 
 * @export
 * @interface Assigned
 */
export interface Assigned {
    /**
     * 
     * @type {string}
     * @memberof Assigned
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface BroadCastNotification
 */
export interface BroadCastNotification {
    /**
     * 
     * @type {string}
     * @memberof BroadCastNotification
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BroadCastNotification
     */
    'customerName'?: string;
    /**
     * 
     * @type {number}
     * @memberof BroadCastNotification
     */
    'progress'?: number;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof BroadCastNotification
     */
    'broadCastStatus'?: PaymentStatus;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BroadCastStatus = {
    Inactive: 'inactive',
    Scheduled: 'scheduled',
    Progress: 'progress',
    Completed: 'completed'
} as const;

export type BroadCastStatus = typeof BroadCastStatus[keyof typeof BroadCastStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const DataAggregateType = {
    Avg: 'avg',
    Sum: 'sum'
} as const;

export type DataAggregateType = typeof DataAggregateType[keyof typeof DataAggregateType];


/**
 * 
 * @export
 * @interface GetHomeMetrics200Response
 */
export interface GetHomeMetrics200Response {
    /**
     * 
     * @type {Array<MetricsResult>}
     * @memberof GetHomeMetrics200Response
     */
    'metrics': Array<MetricsResult>;
}
/**
 * All the metrics you\'d like to see on the home page
 * @export
 * @interface GetMetrics200Response
 */
export interface GetMetrics200Response {
    /**
     * 
     * @type {GetMetrics200ResponseMetrics}
     * @memberof GetMetrics200Response
     */
    'metrics': GetMetrics200ResponseMetrics;
    /**
     * 
     * @type {number}
     * @memberof GetMetrics200Response
     */
    'nextPage'?: number;
}
/**
 * 
 * @export
 * @interface GetMetrics200ResponseMetrics
 */
export interface GetMetrics200ResponseMetrics {
    [key: string]: Array<Metric> | any;

    /**
     * 
     * @type {Array<Metric>}
     * @memberof GetMetrics200ResponseMetrics
     */
    'total'?: Array<Metric>;
}
/**
 * 
 * @export
 * @interface GetNotifications200Response
 */
export interface GetNotifications200Response {
    /**
     * 
     * @type {Array<Notification>}
     * @memberof GetNotifications200Response
     */
    'notifications': Array<Notification>;
    /**
     * 
     * @type {string}
     * @memberof GetNotifications200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface GetTopMetricKeys200Response
 */
export interface GetTopMetricKeys200Response {
    /**
     * 
     * @type {Array<TopMetricKey>}
     * @memberof GetTopMetricKeys200Response
     */
    'keys': Array<TopMetricKey>;
}
/**
 * 
 * @export
 * @interface HomeMetricUpdateRequest
 */
export interface HomeMetricUpdateRequest {
    /**
     * 
     * @type {MetricType}
     * @memberof HomeMetricUpdateRequest
     */
    'metric': MetricType;
    /**
     * 
     * @type {DataAggregateType}
     * @memberof HomeMetricUpdateRequest
     */
    'aggregate': DataAggregateType;
}
/**
 * 
 * @export
 * @interface InboxNotification
 */
export interface InboxNotification {
    /**
     * 
     * @type {number}
     * @memberof InboxNotification
     */
    'phoneNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof InboxNotification
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboxNotification
     */
    'customerName'?: string;
    /**
     * 
     * @type {Assigned}
     * @memberof InboxNotification
     */
    'assignedBy'?: Assigned;
    /**
     * 
     * @type {Array<string>}
     * @memberof InboxNotification
     */
    'tag'?: Array<string>;
    /**
     * 
     * @type {OrderStatus}
     * @memberof InboxNotification
     */
    'orderStatus'?: OrderStatus;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof InboxNotification
     */
    'paymentStatus'?: PaymentStatus;
}
/**
 * 
 * @export
 * @interface KeywordReplyNotification
 */
export interface KeywordReplyNotification {
    /**
     * 
     * @type {string}
     * @memberof KeywordReplyNotification
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordReplyNotification
     */
    'triggerTimes'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordReplyNotification
     */
    'timeSync'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordReplyNotification
     */
    'messageReply'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordReplyNotification
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordReplyNotification
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface MessageFlowNotification
 */
export interface MessageFlowNotification {
    /**
     * 
     * @type {string}
     * @memberof MessageFlowNotification
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageFlowNotification
     */
    'folder'?: string;
}
/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Metric
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    'value': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricType = {
    MessagesSentByUser: 'messages-sent-by-user',
    MessagesRecvByChat: 'messages-recv-by-chat',
    AvgResponseTimeByUser: 'avg-response-time-by-user',
    MessageReplyRateByUser: 'message-reply-rate-by-user',
    TasksAddedByUser: 'tasks-added-by-user',
    TasksSolvedByUser: 'tasks-solved-by-user',
    TasksAddedByChat: 'tasks-added-by-chat',
    ContactsTaggedByTag: 'contacts-tagged-by-tag',
    MessageFlowsSentByFlowId: 'message-flows-sent-by-flow-id',
    MessageFlowsCompletedByFlowId: 'message-flows-completed-by-flow-id',
    MessageFlowClickRateByFlowId: 'message-flow-click-rate-by-flow-id',
    PaymentRecvByPhone: 'payment-recv-by-phone',
    OrdersRecvByPhone: 'orders-recv-by-phone',
    NewChats: 'new-chats'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * 
 * @export
 * @interface MetricsResult
 */
export interface MetricsResult {
    /**
     * 
     * @type {Array<Metric>}
     * @memberof MetricsResult
     */
    'metrics': Array<Metric>;
    /**
     * 
     * @type {Array<Metric>}
     * @memberof MetricsResult
     */
    'previousMetrics'?: Array<Metric>;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricsResult
     */
    'type': MetricType;
    /**
     * 
     * @type {DataAggregateType}
     * @memberof MetricsResult
     */
    'dataAggregate': DataAggregateType;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'id'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Notification
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'actionBy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'hasRead'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'category'?: NotificationCategoryEnum;
    /**
     * 
     * @type {MessageFlowNotification}
     * @memberof Notification
     */
    'data'?: MessageFlowNotification;
}

export const NotificationCategoryEnum = {
    MessageFlow: 'message_flow'
} as const;

export type NotificationCategoryEnum = typeof NotificationCategoryEnum[keyof typeof NotificationCategoryEnum];

/**
 * 
 * @export
 * @interface NotificationAllOf
 */
export interface NotificationAllOf {
    /**
     * 
     * @type {number}
     * @memberof NotificationAllOf
     */
    'id'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof NotificationAllOf
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationAllOf
     */
    'actionBy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationAllOf
     */
    'hasRead'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationCategory = {
    Inbox: 'inbox',
    Shop: 'shop',
    Broadcast: 'broadcast',
    OfflineBot: 'offline_bot',
    KeywordReply: 'keyword_reply',
    MessageFlow: 'message_flow'
} as const;

export type NotificationCategory = typeof NotificationCategory[keyof typeof NotificationCategory];


/**
 * @type NotificationData
 * @export
 */
export type NotificationData = NotificationDataOneOf | NotificationDataOneOf1 | NotificationDataOneOf2 | NotificationDataOneOf3 | NotificationDataOneOf4 | NotificationDataOneOf5;

/**
 * 
 * @export
 * @interface NotificationDataOneOf
 */
export interface NotificationDataOneOf {
    /**
     * 
     * @type {string}
     * @memberof NotificationDataOneOf
     */
    'category'?: NotificationDataOneOfCategoryEnum;
    /**
     * 
     * @type {InboxNotification}
     * @memberof NotificationDataOneOf
     */
    'data'?: InboxNotification;
}

export const NotificationDataOneOfCategoryEnum = {
    Inbox: 'inbox'
} as const;

export type NotificationDataOneOfCategoryEnum = typeof NotificationDataOneOfCategoryEnum[keyof typeof NotificationDataOneOfCategoryEnum];

/**
 * 
 * @export
 * @interface NotificationDataOneOf1
 */
export interface NotificationDataOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof NotificationDataOneOf1
     */
    'category'?: NotificationDataOneOf1CategoryEnum;
    /**
     * 
     * @type {ShopNotification}
     * @memberof NotificationDataOneOf1
     */
    'data'?: ShopNotification;
}

export const NotificationDataOneOf1CategoryEnum = {
    Shop: 'shop'
} as const;

export type NotificationDataOneOf1CategoryEnum = typeof NotificationDataOneOf1CategoryEnum[keyof typeof NotificationDataOneOf1CategoryEnum];

/**
 * 
 * @export
 * @interface NotificationDataOneOf2
 */
export interface NotificationDataOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof NotificationDataOneOf2
     */
    'category'?: NotificationDataOneOf2CategoryEnum;
    /**
     * 
     * @type {BroadCastNotification}
     * @memberof NotificationDataOneOf2
     */
    'data'?: BroadCastNotification;
}

export const NotificationDataOneOf2CategoryEnum = {
    Broadcast: 'broadcast'
} as const;

export type NotificationDataOneOf2CategoryEnum = typeof NotificationDataOneOf2CategoryEnum[keyof typeof NotificationDataOneOf2CategoryEnum];

/**
 * 
 * @export
 * @interface NotificationDataOneOf3
 */
export interface NotificationDataOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof NotificationDataOneOf3
     */
    'category'?: NotificationDataOneOf3CategoryEnum;
    /**
     * 
     * @type {OfflineBottNotification}
     * @memberof NotificationDataOneOf3
     */
    'data'?: OfflineBottNotification;
}

export const NotificationDataOneOf3CategoryEnum = {
    OfflineBot: 'offline_bot'
} as const;

export type NotificationDataOneOf3CategoryEnum = typeof NotificationDataOneOf3CategoryEnum[keyof typeof NotificationDataOneOf3CategoryEnum];

/**
 * 
 * @export
 * @interface NotificationDataOneOf4
 */
export interface NotificationDataOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof NotificationDataOneOf4
     */
    'category'?: NotificationDataOneOf4CategoryEnum;
    /**
     * 
     * @type {KeywordReplyNotification}
     * @memberof NotificationDataOneOf4
     */
    'data'?: KeywordReplyNotification;
}

export const NotificationDataOneOf4CategoryEnum = {
    KeywordReply: 'keyword_reply'
} as const;

export type NotificationDataOneOf4CategoryEnum = typeof NotificationDataOneOf4CategoryEnum[keyof typeof NotificationDataOneOf4CategoryEnum];

/**
 * 
 * @export
 * @interface NotificationDataOneOf5
 */
export interface NotificationDataOneOf5 {
    /**
     * 
     * @type {string}
     * @memberof NotificationDataOneOf5
     */
    'category'?: NotificationDataOneOf5CategoryEnum;
    /**
     * 
     * @type {MessageFlowNotification}
     * @memberof NotificationDataOneOf5
     */
    'data'?: MessageFlowNotification;
}

export const NotificationDataOneOf5CategoryEnum = {
    MessageFlow: 'message_flow'
} as const;

export type NotificationDataOneOf5CategoryEnum = typeof NotificationDataOneOf5CategoryEnum[keyof typeof NotificationDataOneOf5CategoryEnum];

/**
 * 
 * @export
 * @interface OfflineBottNotification
 */
export interface OfflineBottNotification {
    /**
     * 
     * @type {string}
     * @memberof OfflineBottNotification
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfflineBottNotification
     */
    'customerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfflineBottNotification
     */
    'specificTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfflineBottNotification
     */
    'triggerTimes'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OfflineBottNotification
     */
    'channels'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderStatus = {
    Confirmed: 'confirmed',
    Pending: 'pending',
    Cancelled: 'cancelled',
    Completed: 'completed'
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const PaymentStatus = {
    Unpaid: 'unpaid',
    Paid: 'paid',
    Refund: 'refund',
    Pending: 'pending',
    Authorized: 'authorized',
    Completed: 'completed',
    Expired: 'expired'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * 
 * @export
 * @interface ShopNotification
 */
export interface ShopNotification {
    /**
     * 
     * @type {string}
     * @memberof ShopNotification
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopNotification
     */
    'customerName'?: string;
    /**
     * 
     * @type {Assigned}
     * @memberof ShopNotification
     */
    'assignedBy'?: Assigned;
    /**
     * 
     * @type {OrderStatus}
     * @memberof ShopNotification
     */
    'orderStatus'?: OrderStatus;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof ShopNotification
     */
    'paymentStatus'?: PaymentStatus;
    /**
     * 
     * @type {number}
     * @memberof ShopNotification
     */
    'productCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopNotification
     */
    'total'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopNotification
     */
    'channel'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TopMetricKey
 */
export interface TopMetricKey {
    /**
     * 
     * @type {string}
     * @memberof TopMetricKey
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof TopMetricKey
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface UpdateHomeMetricsRequest
 */
export interface UpdateHomeMetricsRequest {
    /**
     * 
     * @type {Array<HomeMetricUpdateRequest>}
     * @memberof UpdateHomeMetricsRequest
     */
    'metrics': Array<HomeMetricUpdateRequest>;
}

/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Will return: - 30 results for the \"day\" aggregate - 12 results for the \"week\" aggregate - 6 results for the \"month\" aggregate 
         * @summary Get all metrics for the home page
         * @param {Aggregate} aggregate Aggregate function to use
         * @param {number} [page] 
         * @param {boolean} [includePreviousPeriod] 
         * @param {string} [timezoneOffset] Timezone offset to query the data in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeMetrics: async (aggregate: Aggregate, page?: number, includePreviousPeriod?: boolean, timezoneOffset?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getHomeMetrics', 'aggregate', aggregate)
            const localVarPath = `/metrics/home/{aggregate}`
                .replace(`{${"aggregate"}}`, encodeURIComponent(String(aggregate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includePreviousPeriod !== undefined) {
                localVarQueryParameter['includePreviousPeriod'] = includePreviousPeriod;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query a given metric
         * @param {MetricType} metric 
         * @param {Aggregate} aggregate 
         * @param {number} [count] Number of results to return
         * @param {number} [page] 
         * @param {Array<string>} [key] fetch data for only these specific keys
         * @param {string} [timezoneOffset] Timezone offset to query the data in
         * @param {DataAggregateType} [dataAggregation] How to aggregate the data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics: async (metric: MetricType, aggregate: Aggregate, count?: number, page?: number, key?: Array<string>, timezoneOffset?: string, dataAggregation?: DataAggregateType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metric' is not null or undefined
            assertParamExists('getMetrics', 'metric', metric)
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getMetrics', 'aggregate', aggregate)
            const localVarPath = `/metrics/{metric}/{aggregate}`
                .replace(`{${"metric"}}`, encodeURIComponent(String(metric)))
                .replace(`{${"aggregate"}}`, encodeURIComponent(String(aggregate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (key) {
                localVarQueryParameter['key'] = key;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }

            if (dataAggregation !== undefined) {
                localVarQueryParameter['dataAggregation'] = dataAggregation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query the top performing keys for a metric & aggregate
         * @param {MetricType} metric 
         * @param {Aggregate} aggregate 
         * @param {number} [count] Number of results to return
         * @param {string} [timezoneOffset] Timezone offset to query the data in
         * @param {'sum' | 'avg'} [dataAggregation] How to aggregate the data
         * @param {string} [timestamp] Timestamp to fetch the top keys for
         * @param {'asc' | 'desc'} [orderDirection] Order direction for the top keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopMetricKeys: async (metric: MetricType, aggregate: Aggregate, count?: number, timezoneOffset?: string, dataAggregation?: 'sum' | 'avg', timestamp?: string, orderDirection?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metric' is not null or undefined
            assertParamExists('getTopMetricKeys', 'metric', metric)
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getTopMetricKeys', 'aggregate', aggregate)
            const localVarPath = `/top-metric-keys/{metric}/{aggregate}`
                .replace(`{${"metric"}}`, encodeURIComponent(String(metric)))
                .replace(`{${"aggregate"}}`, encodeURIComponent(String(aggregate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }

            if (dataAggregation !== undefined) {
                localVarQueryParameter['dataAggregation'] = dataAggregation;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = (timestamp as any instanceof Date) ?
                    (timestamp as any).toISOString() :
                    timestamp;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['orderDirection'] = orderDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the default metrics seen on the home page
         * @param {UpdateHomeMetricsRequest} [updateHomeMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHomeMetrics: async (updateHomeMetricsRequest?: UpdateHomeMetricsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics/home`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateHomeMetricsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Will return: - 30 results for the \"day\" aggregate - 12 results for the \"week\" aggregate - 6 results for the \"month\" aggregate 
         * @summary Get all metrics for the home page
         * @param {Aggregate} aggregate Aggregate function to use
         * @param {number} [page] 
         * @param {boolean} [includePreviousPeriod] 
         * @param {string} [timezoneOffset] Timezone offset to query the data in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHomeMetrics(aggregate: Aggregate, page?: number, includePreviousPeriod?: boolean, timezoneOffset?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHomeMetrics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHomeMetrics(aggregate, page, includePreviousPeriod, timezoneOffset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query a given metric
         * @param {MetricType} metric 
         * @param {Aggregate} aggregate 
         * @param {number} [count] Number of results to return
         * @param {number} [page] 
         * @param {Array<string>} [key] fetch data for only these specific keys
         * @param {string} [timezoneOffset] Timezone offset to query the data in
         * @param {DataAggregateType} [dataAggregation] How to aggregate the data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetrics(metric: MetricType, aggregate: Aggregate, count?: number, page?: number, key?: Array<string>, timezoneOffset?: string, dataAggregation?: DataAggregateType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMetrics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetrics(metric, aggregate, count, page, key, timezoneOffset, dataAggregation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query the top performing keys for a metric & aggregate
         * @param {MetricType} metric 
         * @param {Aggregate} aggregate 
         * @param {number} [count] Number of results to return
         * @param {string} [timezoneOffset] Timezone offset to query the data in
         * @param {'sum' | 'avg'} [dataAggregation] How to aggregate the data
         * @param {string} [timestamp] Timestamp to fetch the top keys for
         * @param {'asc' | 'desc'} [orderDirection] Order direction for the top keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopMetricKeys(metric: MetricType, aggregate: Aggregate, count?: number, timezoneOffset?: string, dataAggregation?: 'sum' | 'avg', timestamp?: string, orderDirection?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTopMetricKeys200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopMetricKeys(metric, aggregate, count, timezoneOffset, dataAggregation, timestamp, orderDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the default metrics seen on the home page
         * @param {UpdateHomeMetricsRequest} [updateHomeMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHomeMetrics(updateHomeMetricsRequest?: UpdateHomeMetricsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHomeMetrics(updateHomeMetricsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Will return: - 30 results for the \"day\" aggregate - 12 results for the \"week\" aggregate - 6 results for the \"month\" aggregate 
         * @summary Get all metrics for the home page
         * @param {Aggregate} aggregate Aggregate function to use
         * @param {number} [page] 
         * @param {boolean} [includePreviousPeriod] 
         * @param {string} [timezoneOffset] Timezone offset to query the data in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeMetrics(aggregate: Aggregate, page?: number, includePreviousPeriod?: boolean, timezoneOffset?: string, options?: any): AxiosPromise<GetHomeMetrics200Response> {
            return localVarFp.getHomeMetrics(aggregate, page, includePreviousPeriod, timezoneOffset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query a given metric
         * @param {MetricType} metric 
         * @param {Aggregate} aggregate 
         * @param {number} [count] Number of results to return
         * @param {number} [page] 
         * @param {Array<string>} [key] fetch data for only these specific keys
         * @param {string} [timezoneOffset] Timezone offset to query the data in
         * @param {DataAggregateType} [dataAggregation] How to aggregate the data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(metric: MetricType, aggregate: Aggregate, count?: number, page?: number, key?: Array<string>, timezoneOffset?: string, dataAggregation?: DataAggregateType, options?: any): AxiosPromise<GetMetrics200Response> {
            return localVarFp.getMetrics(metric, aggregate, count, page, key, timezoneOffset, dataAggregation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query the top performing keys for a metric & aggregate
         * @param {MetricType} metric 
         * @param {Aggregate} aggregate 
         * @param {number} [count] Number of results to return
         * @param {string} [timezoneOffset] Timezone offset to query the data in
         * @param {'sum' | 'avg'} [dataAggregation] How to aggregate the data
         * @param {string} [timestamp] Timestamp to fetch the top keys for
         * @param {'asc' | 'desc'} [orderDirection] Order direction for the top keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopMetricKeys(metric: MetricType, aggregate: Aggregate, count?: number, timezoneOffset?: string, dataAggregation?: 'sum' | 'avg', timestamp?: string, orderDirection?: 'asc' | 'desc', options?: any): AxiosPromise<GetTopMetricKeys200Response> {
            return localVarFp.getTopMetricKeys(metric, aggregate, count, timezoneOffset, dataAggregation, timestamp, orderDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the default metrics seen on the home page
         * @param {UpdateHomeMetricsRequest} [updateHomeMetricsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHomeMetrics(updateHomeMetricsRequest?: UpdateHomeMetricsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateHomeMetrics(updateHomeMetricsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHomeMetrics operation in MetricsApi.
 * @export
 * @interface MetricsApiGetHomeMetricsRequest
 */
export interface MetricsApiGetHomeMetricsRequest {
    /**
     * Aggregate function to use
     * @type {Aggregate}
     * @memberof MetricsApiGetHomeMetrics
     */
    readonly aggregate: Aggregate

    /**
     * 
     * @type {number}
     * @memberof MetricsApiGetHomeMetrics
     */
    readonly page?: number

    /**
     * 
     * @type {boolean}
     * @memberof MetricsApiGetHomeMetrics
     */
    readonly includePreviousPeriod?: boolean

    /**
     * Timezone offset to query the data in
     * @type {string}
     * @memberof MetricsApiGetHomeMetrics
     */
    readonly timezoneOffset?: string
}

/**
 * Request parameters for getMetrics operation in MetricsApi.
 * @export
 * @interface MetricsApiGetMetricsRequest
 */
export interface MetricsApiGetMetricsRequest {
    /**
     * 
     * @type {MetricType}
     * @memberof MetricsApiGetMetrics
     */
    readonly metric: MetricType

    /**
     * 
     * @type {Aggregate}
     * @memberof MetricsApiGetMetrics
     */
    readonly aggregate: Aggregate

    /**
     * Number of results to return
     * @type {number}
     * @memberof MetricsApiGetMetrics
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof MetricsApiGetMetrics
     */
    readonly page?: number

    /**
     * fetch data for only these specific keys
     * @type {Array<string>}
     * @memberof MetricsApiGetMetrics
     */
    readonly key?: Array<string>

    /**
     * Timezone offset to query the data in
     * @type {string}
     * @memberof MetricsApiGetMetrics
     */
    readonly timezoneOffset?: string

    /**
     * How to aggregate the data
     * @type {DataAggregateType}
     * @memberof MetricsApiGetMetrics
     */
    readonly dataAggregation?: DataAggregateType
}

/**
 * Request parameters for getTopMetricKeys operation in MetricsApi.
 * @export
 * @interface MetricsApiGetTopMetricKeysRequest
 */
export interface MetricsApiGetTopMetricKeysRequest {
    /**
     * 
     * @type {MetricType}
     * @memberof MetricsApiGetTopMetricKeys
     */
    readonly metric: MetricType

    /**
     * 
     * @type {Aggregate}
     * @memberof MetricsApiGetTopMetricKeys
     */
    readonly aggregate: Aggregate

    /**
     * Number of results to return
     * @type {number}
     * @memberof MetricsApiGetTopMetricKeys
     */
    readonly count?: number

    /**
     * Timezone offset to query the data in
     * @type {string}
     * @memberof MetricsApiGetTopMetricKeys
     */
    readonly timezoneOffset?: string

    /**
     * How to aggregate the data
     * @type {'sum' | 'avg'}
     * @memberof MetricsApiGetTopMetricKeys
     */
    readonly dataAggregation?: 'sum' | 'avg'

    /**
     * Timestamp to fetch the top keys for
     * @type {string}
     * @memberof MetricsApiGetTopMetricKeys
     */
    readonly timestamp?: string

    /**
     * Order direction for the top keys
     * @type {'asc' | 'desc'}
     * @memberof MetricsApiGetTopMetricKeys
     */
    readonly orderDirection?: 'asc' | 'desc'
}

/**
 * Request parameters for updateHomeMetrics operation in MetricsApi.
 * @export
 * @interface MetricsApiUpdateHomeMetricsRequest
 */
export interface MetricsApiUpdateHomeMetricsRequest {
    /**
     * 
     * @type {UpdateHomeMetricsRequest}
     * @memberof MetricsApiUpdateHomeMetrics
     */
    readonly updateHomeMetricsRequest?: UpdateHomeMetricsRequest
}

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Will return: - 30 results for the \"day\" aggregate - 12 results for the \"week\" aggregate - 6 results for the \"month\" aggregate 
     * @summary Get all metrics for the home page
     * @param {MetricsApiGetHomeMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getHomeMetrics(requestParameters: MetricsApiGetHomeMetricsRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getHomeMetrics(requestParameters.aggregate, requestParameters.page, requestParameters.includePreviousPeriod, requestParameters.timezoneOffset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query a given metric
     * @param {MetricsApiGetMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(requestParameters: MetricsApiGetMetricsRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetrics(requestParameters.metric, requestParameters.aggregate, requestParameters.count, requestParameters.page, requestParameters.key, requestParameters.timezoneOffset, requestParameters.dataAggregation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query the top performing keys for a metric & aggregate
     * @param {MetricsApiGetTopMetricKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getTopMetricKeys(requestParameters: MetricsApiGetTopMetricKeysRequest, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getTopMetricKeys(requestParameters.metric, requestParameters.aggregate, requestParameters.count, requestParameters.timezoneOffset, requestParameters.dataAggregation, requestParameters.timestamp, requestParameters.orderDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the default metrics seen on the home page
     * @param {MetricsApiUpdateHomeMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public updateHomeMetrics(requestParameters: MetricsApiUpdateHomeMetricsRequest = {}, options?: AxiosRequestConfig) {
        return MetricsApiFp(this.configuration).updateHomeMetrics(requestParameters.updateHomeMetricsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get notifications data
         * @param {string} [id] 
         * @param {NotificationCategory} [category] 
         * @param {number} [count] Number of results to return
         * @param {string} [q] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (id?: string, category?: NotificationCategory, count?: number, q?: string, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get notifications data
         * @param {string} [id] 
         * @param {NotificationCategory} [category] 
         * @param {number} [count] Number of results to return
         * @param {string} [q] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(id?: string, category?: NotificationCategory, count?: number, q?: string, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNotifications200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(id, category, count, q, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get notifications data
         * @param {string} [id] 
         * @param {NotificationCategory} [category] 
         * @param {number} [count] Number of results to return
         * @param {string} [q] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(id?: string, category?: NotificationCategory, count?: number, q?: string, cursor?: string, options?: any): AxiosPromise<GetNotifications200Response> {
            return localVarFp.getNotifications(id, category, count, q, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getNotifications operation in NotificationApi.
 * @export
 * @interface NotificationApiGetNotificationsRequest
 */
export interface NotificationApiGetNotificationsRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationApiGetNotifications
     */
    readonly id?: string

    /**
     * 
     * @type {NotificationCategory}
     * @memberof NotificationApiGetNotifications
     */
    readonly category?: NotificationCategory

    /**
     * Number of results to return
     * @type {number}
     * @memberof NotificationApiGetNotifications
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof NotificationApiGetNotifications
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof NotificationApiGetNotifications
     */
    readonly cursor?: string
}

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @summary Get notifications data
     * @param {NotificationApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public getNotifications(requestParameters: NotificationApiGetNotificationsRequest = {}, options?: AxiosRequestConfig) {
        return NotificationApiFp(this.configuration).getNotifications(requestParameters.id, requestParameters.category, requestParameters.count, requestParameters.q, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }
}


