const BASE_PATH = "https://api-im.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Instant Messaging Service
 * Complete instant messaging API for WhatsApp Web & Multi-Device. 
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it. 
     * @type {string}
     * @memberof Account
     */
    'accountId': string;
    /**
     * Owner of thr account
     * @type {string}
     * @memberof Account
     */
    'ownerId': string;
    /**
     * User facing nickname of the account
     * @type {string}
     * @memberof Account
     */
    'nickname': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'credentials'?: { [key: string]: any; } | null;
    /**
     * Prefix for the webhook URL
     * @type {string}
     * @memberof Account
     */
    'webhookUrlPrefix'?: string;
    /**
     * 
     * @type {AccountType}
     * @memberof Account
     */
    'type': AccountType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'updatedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'lastLoginAt'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'lastLogoutAt'?: string | null;
    /**
     * 
     * @type {AccountState}
     * @memberof Account
     */
    'state': AccountState;
    /**
     * 
     * @type {AccountError}
     * @memberof Account
     */
    'error'?: AccountError | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'stateInfo': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'canLogin': boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'userId'?: string | null;
    /**
     * 
     * @type {Contact}
     * @memberof Account
     */
    'user'?: Contact;
    /**
     * 
     * @type {AccountSettings}
     * @memberof Account
     */
    'settings': AccountSettings;
}
/**
 * 
 * @export
 * @interface AccountError
 */
export interface AccountError {
    /**
     * 
     * @type {string}
     * @memberof AccountError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AccountSettings
 */
export interface AccountSettings {
    /**
     * Supply a list of user IDs to notify when a new message arrives
     * @type {Array<string>}
     * @memberof AccountSettings
     */
    'notifyUsers'?: Array<string>;
    /**
     * Should chat history be synced with the database
     * @type {boolean}
     * @memberof AccountSettings
     */
    'enableHistorySync'?: boolean;
    /**
     * Maximum number of messages that would be synced to the database
     * @type {number}
     * @memberof AccountSettings
     */
    'maxMessageSync'?: number;
    /**
     * Will doing a chat action (like archive, mark unread) actually sync it back with the primary device
     * @type {boolean}
     * @memberof AccountSettings
     */
    'nativeChatActionSync'?: boolean;
    /**
     * Based on this flag smart assignee will work. 1. fromMe => only trigger for chats that were created by me. 2. fromOther => only trigger for chats that were created by the other person initiating the conversation. 3. all => trigger for all new chats. 4. disabled => this should be enabled by the flag being null or undefined.
     * @type {string}
     * @memberof AccountSettings
     */
    'autoAssignNewChats'?: AccountSettingsAutoAssignNewChatsEnum;
}

export const AccountSettingsAutoAssignNewChatsEnum = {
    FromMe: 'fromMe',
    FromOther: 'fromOther',
    All: 'all'
} as const;

export type AccountSettingsAutoAssignNewChatsEnum = typeof AccountSettingsAutoAssignNewChatsEnum[keyof typeof AccountSettingsAutoAssignNewChatsEnum];

/**
 * Describes the current state of an account. 1. open => logged in & connected to WhatsApp. Can send & receive messages now 2. connecting => establishing connection to WhatsApp. QR code is available during this state 3. close => connection to WhatsApp is closed, account is inactive at the moment
 * @export
 * @enum {string}
 */

export const AccountState = {
    Open: 'open',
    Connecting: 'connecting',
    Close: 'close'
} as const;

export type AccountState = typeof AccountState[keyof typeof AccountState];


/**
 * Describes the tier of the account, and which features it\'ll have
 * @export
 * @enum {string}
 */

export const AccountTier = {
    LimitedMsgNoChatHistory: 'limited_msg_no_chat_history',
    UnlimitedMsgChatHistory: 'unlimited_msg_chat_history'
} as const;

export type AccountTier = typeof AccountTier[keyof typeof AccountTier];


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountType = {
    Wa: 'wa',
    WaBusinessApi: 'wa-business-api',
    Mock: 'mock'
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];


/**
 * 
 * @export
 * @interface AccountsGet200Response
 */
export interface AccountsGet200Response {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountsGet200Response
     */
    'accounts': Array<Account>;
    /**
     * 
     * @type {number}
     * @memberof AccountsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface AccountsLogout200Response
 */
export interface AccountsLogout200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AccountsLogout200Response
     */
    'success': boolean;
}
/**
 * Update an account. Specifying account updates the type
 * @export
 * @interface AccountsPatchRequest
 */
export interface AccountsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsPatchRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {AccountTier}
     * @memberof AccountsPatchRequest
     */
    'tier'?: AccountTier;
    /**
     * 
     * @type {AccountSettings}
     * @memberof AccountsPatchRequest
     */
    'settings'?: AccountSettings;
}
/**
 * 
 * @export
 * @interface AccountsPostRequest
 */
export interface AccountsPostRequest {
    /**
     * 
     * @type {AccountType}
     * @memberof AccountsPostRequest
     */
    'type': AccountType;
    /**
     * 
     * @type {AccountTier}
     * @memberof AccountsPostRequest
     */
    'tier'?: AccountTier;
    /**
     * 
     * @type {string}
     * @memberof AccountsPostRequest
     */
    'nickname'?: string;
}
/**
 * 
 * @export
 * @interface AlibabaCAMSWebhookItem
 */
export interface AlibabaCAMSWebhookItem {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookItem
     */
    'Type': AlibabaCAMSWebhookItemTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookItem
     */
    'Status'?: AlibabaCAMSWebhookItemStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookItem
     */
    'ConversationId'?: string;
    /**
     * Raw text if type=TEXT, otherwise JSON stringified content
     * @type {string}
     * @memberof AlibabaCAMSWebhookItem
     */
    'Message'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookItem
     */
    'From': string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookItem
     */
    'To': string;
    /**
     * Unix timestamp in MS
     * @type {number}
     * @memberof AlibabaCAMSWebhookItem
     */
    'Timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookItem
     */
    'MessageId': string;
    /**
     * Name of the user that sent the message
     * @type {string}
     * @memberof AlibabaCAMSWebhookItem
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookItem
     */
    'ConversationType'?: AlibabaCAMSWebhookItemConversationTypeEnum;
}

export const AlibabaCAMSWebhookItemTypeEnum = {
    Text: 'TEXT',
    Template: 'TEMPLATE',
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Document: 'DOCUMENT',
    Unknown: 'UNKNOWN',
    Location: 'LOCATION',
    Interactive: 'INTERACTIVE'
} as const;

export type AlibabaCAMSWebhookItemTypeEnum = typeof AlibabaCAMSWebhookItemTypeEnum[keyof typeof AlibabaCAMSWebhookItemTypeEnum];
export const AlibabaCAMSWebhookItemStatusEnum = {
    Sent: 'Sent',
    Delivered: 'Delivered',
    Read: 'Read'
} as const;

export type AlibabaCAMSWebhookItemStatusEnum = typeof AlibabaCAMSWebhookItemStatusEnum[keyof typeof AlibabaCAMSWebhookItemStatusEnum];
export const AlibabaCAMSWebhookItemConversationTypeEnum = {
    BusinessInitiated: 'business_initiated',
    UserInitiated: 'user_initiated'
} as const;

export type AlibabaCAMSWebhookItemConversationTypeEnum = typeof AlibabaCAMSWebhookItemConversationTypeEnum[keyof typeof AlibabaCAMSWebhookItemConversationTypeEnum];

/**
 * 
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it. 
     * @type {string}
     * @memberof Chat
     */
    'accountId': string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof Chat
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chat
     */
    'lastMessage': string;
    /**
     * Number of unread messages
     * @type {number}
     * @memberof Chat
     */
    'unread': number;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'spam'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'archive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'readOnly': boolean;
    /**
     * Timestamp of when the chat was muted
     * @type {number}
     * @memberof Chat
     */
    'mute'?: number | null;
    /**
     * Timestamp of when the chat was pinned
     * @type {number}
     * @memberof Chat
     */
    'pin'?: number | null;
    /**
     * did the user create this contact
     * @type {boolean}
     * @memberof Chat
     */
    'isUserGenerated': boolean;
    /**
     * does this chat have any pending messages
     * @type {boolean}
     * @memberof Chat
     */
    'hasPendingMessage'?: boolean;
    /**
     * does this chat have any unsolved notes
     * @type {boolean}
     * @memberof Chat
     */
    'hasUnsolvedNote'?: boolean;
    /**
     * does this chat have any failed messages
     * @type {boolean}
     * @memberof Chat
     */
    'hasFailedMessage'?: boolean;
    /**
     * the user IDs mentioned in the chat
     * @type {Array<string>}
     * @memberof Chat
     */
    'mentions'?: Array<string>;
    /**
     * if disappearing messages is on, and for how long
     * @type {number}
     * @memberof Chat
     */
    'disappearingMessages'?: number | null;
    /**
     * If the chat has all the message history from the primary source
     * @type {boolean}
     * @memberof Chat
     */
    'hasEntireMessageHistory': boolean;
    /**
     * 
     * @type {Contact}
     * @memberof Chat
     */
    'contact': Contact;
    /**
     * 
     * @type {Array<Message>}
     * @memberof Chat
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {Array<ChatPresence>}
     * @memberof Chat
     */
    'presences'?: Array<ChatPresence>;
    /**
     * cursor to sort chats by
     * @type {string}
     * @memberof Chat
     */
    'cursor': string;
}
/**
 * 
 * @export
 * @interface ChatAction
 */
export interface ChatAction {
    /**
     * 
     * @type {string}
     * @memberof ChatAction
     */
    'action': ChatActionActionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ChatAction
     */
    'value': boolean;
}

export const ChatActionActionEnum = {
    Archive: 'archive',
    Pin: 'pin',
    Mute: 'mute',
    Read: 'read',
    Delete: 'delete'
} as const;

export type ChatActionActionEnum = typeof ChatActionActionEnum[keyof typeof ChatActionActionEnum];

/**
 * 
 * @export
 * @interface ChatPresence
 */
export interface ChatPresence {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it. 
     * @type {string}
     * @memberof ChatPresence
     */
    'accountId'?: string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof ChatPresence
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatPresence
     */
    'contactId': string;
    /**
     * if a known team member has this presence
     * @type {string}
     * @memberof ChatPresence
     */
    'userId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ChatPresence
     */
    'updatedAt': string;
    /**
     * 
     * @type {PresenceType}
     * @memberof ChatPresence
     */
    'type': PresenceType;
}
/**
 * 
 * @export
 * @interface ChatsGet200Response
 */
export interface ChatsGet200Response {
    /**
     * next page cursor, if it exists
     * @type {string}
     * @memberof ChatsGet200Response
     */
    'nextPage'?: string;
    /**
     * number of total unread chats given the filter
     * @type {number}
     * @memberof ChatsGet200Response
     */
    'unreadChatCount'?: number;
    /**
     * 
     * @type {Array<Chat>}
     * @memberof ChatsGet200Response
     */
    'chats': Array<Chat>;
}
/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof Contact
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it. 
     * @type {string}
     * @memberof Contact
     */
    'accountId': string;
    /**
     * 
     * @type {ContactType}
     * @memberof Contact
     */
    'type': ContactType;
    /**
     * name of the contact as set on ChatDaddy
     * @type {string}
     * @memberof Contact
     */
    'name': string | null;
    /**
     * name of the contact, as set on the platform
     * @type {Array<string>}
     * @memberof Contact
     */
    'platformNames': Array<string>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Contact
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Contact
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phoneNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'email'?: string | null;
    /**
     * 
     * @type {ContactImg}
     * @memberof Contact
     */
    'img'?: ContactImg | null;
    /**
     * Tags associated with this contact
     * @type {Array<ContactTag>}
     * @memberof Contact
     */
    'tags': Array<ContactTag>;
    /**
     * The assignee of the contact
     * @type {string}
     * @memberof Contact
     */
    'assignee'?: string | null;
    /**
     * The person who assigned this contact
     * @type {string}
     * @memberof Contact
     */
    'assigner'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'messagesSent': number;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'messagesReceived': number;
    /**
     * 
     * @type {ContactChat}
     * @memberof Contact
     */
    'chat'?: ContactChat;
}
/**
 * 
 * @export
 * @interface ContactChat
 */
export interface ContactChat {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ContactChat
     */
    'lastMessage': string;
}
/**
 * 
 * @export
 * @interface ContactImg
 */
export interface ContactImg {
    /**
     * 
     * @type {string}
     * @memberof ContactImg
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactImg
     */
    'fullUrl'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ContactImg
     */
    'fetchedAt'?: string;
}
/**
 * 
 * @export
 * @interface ContactTag
 */
export interface ContactTag {
    /**
     * 
     * @type {string}
     * @memberof ContactTag
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTag
     */
    'value'?: string | null;
    /**
     * used in events to denote that the tag has been removed
     * @type {boolean}
     * @memberof ContactTag
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ContactType = {
    Individual: 'individual',
    Group: 'group',
    Broadcast: 'broadcast'
} as const;

export type ContactType = typeof ContactType[keyof typeof ContactType];


/**
 * 
 * @export
 * @interface ContactsCheckExists200Response
 */
export interface ContactsCheckExists200Response {
    /**
     * Whether the user exists
     * @type {boolean}
     * @memberof ContactsCheckExists200Response
     */
    'exists': boolean;
    /**
     * True ID of the user on the platform
     * @type {string}
     * @memberof ContactsCheckExists200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ContactsGet200Response
 */
export interface ContactsGet200Response {
    /**
     * total contacts present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof ContactsGet200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<Contact>}
     * @memberof ContactsGet200Response
     */
    'contacts': Array<Contact>;
    /**
     * 
     * @type {string}
     * @memberof ContactsGet200Response
     */
    'nextPage': string | null;
}
/**
 * @type ContactsGetCountParameter
 * @export
 */
export type ContactsGetCountParameter = ContactsGetCountParameterOneOf | number;

/**
 * 
 * @export
 * @enum {string}
 */

export const ContactsGetCountParameterOneOf = {
    All: 'all'
} as const;

export type ContactsGetCountParameterOneOf = typeof ContactsGetCountParameterOneOf[keyof typeof ContactsGetCountParameterOneOf];


/**
 * 
 * @export
 * @interface ContactsImageGet200Response
 */
export interface ContactsImageGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ContactsImageGet200Response
     */
    'url': string | null;
}
/**
 * 
 * @export
 * @interface ContactsPatch
 */
export interface ContactsPatch {
    /**
     * 
     * @type {ContactsPatchPatch}
     * @memberof ContactsPatch
     */
    'patch': ContactsPatchPatch;
}
/**
 * 
 * @export
 * @interface ContactsPatch200Response
 */
export interface ContactsPatch200Response {
    /**
     * 
     * @type {number}
     * @memberof ContactsPatch200Response
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface ContactsPatchPatch
 */
export interface ContactsPatchPatch {
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'assignee'?: string | null;
    /**
     * 
     * @type {Array<ContactTag>}
     * @memberof ContactsPatchPatch
     */
    'tags'?: Array<ContactTag>;
}
/**
 * 
 * @export
 * @interface ContactsPost
 */
export interface ContactsPost {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it. 
     * @type {string}
     * @memberof ContactsPost
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<ContactsPostContactsInner>}
     * @memberof ContactsPost
     */
    'contacts': Array<ContactsPostContactsInner>;
}
/**
 * 
 * @export
 * @interface ContactsPostContactsInner
 */
export interface ContactsPostContactsInner {
    /**
     * 
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'name': string | null;
    /**
     * The phone number of the contact
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'phoneNumber': string;
    /**
     * The email of the contact
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'email'?: string;
    /**
     * 
     * @type {Array<ContactTag>}
     * @memberof ContactsPostContactsInner
     */
    'tags'?: Array<ContactTag> | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'assignee'?: string | null;
}
/**
 * 
 * @export
 * @interface DataModel
 */
export interface DataModel {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DataModel
     */
    'fromDate': string;
    /**
     * 
     * @type {DataModelInner}
     * @memberof DataModel
     */
    'messagesSent': DataModelInner;
    /**
     * 
     * @type {DataModelInner}
     * @memberof DataModel
     */
    'tasksCompleted': DataModelInner;
    /**
     * 
     * @type {DataModelInner}
     * @memberof DataModel
     */
    'tasksAdded': DataModelInner;
}
/**
 * 
 * @export
 * @interface DataModelInner
 */
export interface DataModelInner {
    /**
     * 
     * @type {Array<DataModelRowsInner>}
     * @memberof DataModelInner
     */
    'byUserId': Array<DataModelRowsInner>;
    /**
     * 
     * @type {Array<DataModelRowsInner>}
     * @memberof DataModelInner
     */
    'byChatId'?: Array<DataModelRowsInner>;
}
/**
 * 
 * @export
 * @interface DataModelRowsInner
 */
export interface DataModelRowsInner {
    /**
     * 
     * @type {string}
     * @memberof DataModelRowsInner
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof DataModelRowsInner
     */
    'count': number;
    /**
     * the identifier of the grouping -- could be user Id, or chat Id
     * @type {string}
     * @memberof DataModelRowsInner
     */
    'actor': string;
}
/**
 * 
 * @export
 * @interface GroupAction
 */
export interface GroupAction {
    /**
     * 
     * @type {GroupActionType}
     * @memberof GroupAction
     */
    'action': GroupActionType;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupAction
     */
    'participants': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GroupActionType = {
    Add: 'add',
    Remove: 'remove',
    Demote: 'demote',
    Promote: 'promote'
} as const;

export type GroupActionType = typeof GroupActionType[keyof typeof GroupActionType];


/**
 * 
 * @export
 * @interface GroupCreate
 */
export interface GroupCreate {
    /**
     * 
     * @type {string}
     * @memberof GroupCreate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupCreate
     */
    'participants': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupMetadata
 */
export interface GroupMetadata {
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it. 
     * @type {string}
     * @memberof GroupMetadata
     */
    'accountId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof GroupMetadata
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    'ownerId'?: string | null;
    /**
     * 
     * @type {Contact}
     * @memberof GroupMetadata
     */
    'owner'?: Contact;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    'description': string | null;
    /**
     * is set when the group only allows admins to change group settings
     * @type {boolean}
     * @memberof GroupMetadata
     */
    'restrict': boolean;
    /**
     * is set when the group only allows admins to write messages
     * @type {boolean}
     * @memberof GroupMetadata
     */
    'announce': boolean;
    /**
     * 
     * @type {Array<GroupParticipant>}
     * @memberof GroupMetadata
     */
    'participants': Array<GroupParticipant>;
}
/**
 * 
 * @export
 * @interface GroupParticipant
 */
export interface GroupParticipant {
    /**
     * 
     * @type {Contact}
     * @memberof GroupParticipant
     */
    'contact': Contact;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipant
     */
    'admin'?: GroupParticipantAdminEnum;
}

export const GroupParticipantAdminEnum = {
    Admin: 'admin',
    SuperAdmin: 'super-admin'
} as const;

export type GroupParticipantAdminEnum = typeof GroupParticipantAdminEnum[keyof typeof GroupParticipantAdminEnum];

/**
 * 
 * @export
 * @interface GroupsInviteCode200Response
 */
export interface GroupsInviteCode200Response {
    /**
     * 
     * @type {string}
     * @memberof GroupsInviteCode200Response
     */
    'inviteCode': string;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof Message
     */
    'chatId': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it. 
     * @type {string}
     * @memberof Message
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'fromMe': boolean;
    /**
     * The contact that sent the message (applicable for groups)
     * @type {string}
     * @memberof Message
     */
    'senderContactId'?: string | null;
    /**
     * 
     * @type {MessageAllOfSender}
     * @memberof Message
     */
    'sender'?: MessageAllOfSender | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    'timestamp': string;
    /**
     * 
     * @type {MessageStatus}
     * @memberof Message
     */
    'status'?: MessageStatus;
    /**
     * 
     * @type {MessageAllOfError}
     * @memberof Message
     */
    'error'?: MessageAllOfError | null;
    /**
     * Only for notes, user ID of the person who resolved the note
     * @type {string}
     * @memberof Message
     */
    'resolvedBy'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    'resolvedAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {MiscOptions}
     * @memberof Message
     */
    'miscOptions'?: MiscOptions;
    /**
     * 
     * @type {Array<string>}
     * @memberof Message
     */
    'mentions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'text': string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof Message
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof Message
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof Message
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof Message
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof Message
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof Message
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof Message
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof Message
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof Message
     */
    'reactions'?: Array<MessageReaction> | null;
}
/**
 * 
 * @export
 * @interface MessageAllOf
 */
export interface MessageAllOf {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MessageAllOf
     */
    'chatId': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it. 
     * @type {string}
     * @memberof MessageAllOf
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageAllOf
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof MessageAllOf
     */
    'fromMe': boolean;
    /**
     * The contact that sent the message (applicable for groups)
     * @type {string}
     * @memberof MessageAllOf
     */
    'senderContactId'?: string | null;
    /**
     * 
     * @type {MessageAllOfSender}
     * @memberof MessageAllOf
     */
    'sender'?: MessageAllOfSender | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageAllOf
     */
    'timestamp': string;
    /**
     * 
     * @type {MessageStatus}
     * @memberof MessageAllOf
     */
    'status'?: MessageStatus;
    /**
     * 
     * @type {MessageAllOfError}
     * @memberof MessageAllOf
     */
    'error'?: MessageAllOfError | null;
    /**
     * Only for notes, user ID of the person who resolved the note
     * @type {string}
     * @memberof MessageAllOf
     */
    'resolvedBy'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageAllOf
     */
    'resolvedAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MessageAllOf
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageAllOf
     */
    'miscOptions'?: MiscOptions;
}
/**
 * 
 * @export
 * @interface MessageAllOfError
 */
export interface MessageAllOfError {
    /**
     * 
     * @type {string}
     * @memberof MessageAllOfError
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof MessageAllOfError
     */
    'statusCode': number;
    /**
     * 
     * @type {number}
     * @memberof MessageAllOfError
     */
    'retries'?: number;
}
/**
 * The user ID of the person that sent it
 * @export
 * @interface MessageAllOfSender
 */
export interface MessageAllOfSender {
    /**
     * 
     * @type {string}
     * @memberof MessageAllOfSender
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface MessageAttachment
 */
export interface MessageAttachment {
    /**
     * 
     * @type {MessageAttachmentType}
     * @memberof MessageAttachment
     */
    'type': MessageAttachmentType;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachment
     */
    'mimetype': string;
    /**
     * 1. can be publicly hosted url,  2. or can be base64 encoded buffer. But make sure it starts with `data:;base64,` -- can be at most 1KB in size Note: the `contact` type only supports base64 encoded data. Must be a serialised vcard 
     * @type {string}
     * @memberof MessageAttachment
     */
    'url': string;
    /**
     * 
     * @type {MessageLocation}
     * @memberof MessageAttachment
     */
    'location'?: MessageLocation;
    /**
     * thumbnail of sticker/video/image
     * @type {any}
     * @memberof MessageAttachment
     */
    'jpegThumbnail'?: any | null;
    /**
     * duration of audio/video message
     * @type {number}
     * @memberof MessageAttachment
     */
    'seconds'?: number;
    /**
     * Show as PTT (voice note) -- only for audio messages
     * @type {boolean}
     * @memberof MessageAttachment
     */
    'pttAudio'?: boolean;
    /**
     * name of the doc message
     * @type {string}
     * @memberof MessageAttachment
     */
    'filename'?: string;
    /**
     * is this a gif -- only for video messages
     * @type {boolean}
     * @memberof MessageAttachment
     */
    'isGif'?: boolean;
    /**
     * 
     * @type {MessageAttachmentDecryption}
     * @memberof MessageAttachment
     */
    'decryption'?: MessageAttachmentDecryption;
}
/**
 * 
 * @export
 * @interface MessageAttachmentDecryption
 */
export interface MessageAttachmentDecryption {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MessageAttachmentDecryption
     */
    'keys'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentDecryption
     */
    'algorithm': MessageAttachmentDecryptionAlgorithmEnum;
}

export const MessageAttachmentDecryptionAlgorithmEnum = {
    Aes256Cbc: 'aes-256-cbc'
} as const;

export type MessageAttachmentDecryptionAlgorithmEnum = typeof MessageAttachmentDecryptionAlgorithmEnum[keyof typeof MessageAttachmentDecryptionAlgorithmEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const MessageAttachmentType = {
    Image: 'image',
    Video: 'video',
    Contact: 'contact',
    Sticker: 'sticker',
    Audio: 'audio',
    Document: 'document',
    Location: 'location'
} as const;

export type MessageAttachmentType = typeof MessageAttachmentType[keyof typeof MessageAttachmentType];


/**
 * 
 * @export
 * @interface MessageButton
 */
export interface MessageButton {
    /**
     * 
     * @type {string}
     * @memberof MessageButton
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageButton
     */
    'text': string;
    /**
     * Make a button with a link
     * @type {string}
     * @memberof MessageButton
     */
    'url'?: string;
    /**
     * Make a button with a phone number
     * @type {string}
     * @memberof MessageButton
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface MessageCompose
 */
export interface MessageCompose {
    /**
     * Specify the message Id -- can be used to atomically send messages. Two messages with the same ID will never be sent twice 
     * @type {string}
     * @memberof MessageCompose
     */
    'id'?: string;
    /**
     * Set the status of the message, use to create notes
     * @type {string}
     * @memberof MessageCompose
     */
    'status'?: MessageComposeStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageCompose
     */
    'timestamp'?: string;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageCompose
     */
    'miscOptions'?: MiscOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof MessageCompose
     */
    'parameters'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageCompose
     */
    'mentions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MessageCompose
     */
    'text': string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageCompose
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof MessageCompose
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageCompose
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageCompose
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof MessageCompose
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof MessageCompose
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof MessageCompose
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof MessageCompose
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof MessageCompose
     */
    'reactions'?: Array<MessageReaction> | null;
}

export const MessageComposeStatusEnum = {
    Note: 'note',
    Pending: 'pending'
} as const;

export type MessageComposeStatusEnum = typeof MessageComposeStatusEnum[keyof typeof MessageComposeStatusEnum];

/**
 * 
 * @export
 * @interface MessageComposeAllOf
 */
export interface MessageComposeAllOf {
    /**
     * Specify the message Id -- can be used to atomically send messages. Two messages with the same ID will never be sent twice 
     * @type {string}
     * @memberof MessageComposeAllOf
     */
    'id'?: string;
    /**
     * Set the status of the message, use to create notes
     * @type {string}
     * @memberof MessageComposeAllOf
     */
    'status'?: MessageComposeAllOfStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageComposeAllOf
     */
    'timestamp'?: string;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageComposeAllOf
     */
    'miscOptions'?: MiscOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof MessageComposeAllOf
     */
    'parameters'?: { [key: string]: any; };
}

export const MessageComposeAllOfStatusEnum = {
    Note: 'note',
    Pending: 'pending'
} as const;

export type MessageComposeAllOfStatusEnum = typeof MessageComposeAllOfStatusEnum[keyof typeof MessageComposeAllOfStatusEnum];

/**
 * 
 * @export
 * @interface MessageContent
 */
export interface MessageContent {
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageContent
     */
    'mentions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MessageContent
     */
    'text': string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageContent
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof MessageContent
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageContent
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageContent
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof MessageContent
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof MessageContent
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof MessageContent
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof MessageContent
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof MessageContent
     */
    'reactions'?: Array<MessageReaction> | null;
}
/**
 * 
 * @export
 * @interface MessageContentAction
 */
export interface MessageContentAction {
    /**
     * 
     * @type {string}
     * @memberof MessageContentAction
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageContentAction
     */
    'parameters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MessageContentOrder
 */
export interface MessageContentOrder {
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'jpegThumbnail'?: string;
    /**
     * 
     * @type {number}
     * @memberof MessageContentOrder
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'sellerId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'token': string;
    /**
     * 
     * @type {Price}
     * @memberof MessageContentOrder
     */
    'total': Price;
}
/**
 * 
 * @export
 * @interface MessageLinkPreview
 */
export interface MessageLinkPreview {
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'jpegThumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'matchedText'?: string;
}
/**
 * 
 * @export
 * @interface MessageLocation
 */
export interface MessageLocation {
    /**
     * 
     * @type {number}
     * @memberof MessageLocation
     */
    'latitude': number;
    /**
     * 
     * @type {number}
     * @memberof MessageLocation
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface MessageProduct
 */
export interface MessageProduct {
    /**
     * 
     * @type {string}
     * @memberof MessageProduct
     */
    'id': string;
    /**
     * 3-letter ISO currency code
     * @type {string}
     * @memberof MessageProduct
     */
    'currencyCode': string;
    /**
     * the actual price * 1000
     * @type {number}
     * @memberof MessageProduct
     */
    'price1000': number;
    /**
     * 
     * @type {string}
     * @memberof MessageProduct
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageProduct
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface MessageReaction
 */
export interface MessageReaction {
    /**
     * Describes a reaction on a message
     * @type {string}
     * @memberof MessageReaction
     */
    'reaction': string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MessageReaction
     */
    'fromId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageReaction
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageReaction
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MessageStatus = {
    Error: 'error',
    Pending: 'pending',
    Note: 'note',
    Sent: 'sent',
    Delivered: 'delivered',
    Read: 'read'
} as const;

export type MessageStatus = typeof MessageStatus[keyof typeof MessageStatus];


/**
 * 
 * @export
 * @interface MessagesGet200Response
 */
export interface MessagesGet200Response {
    /**
     * 
     * @type {string}
     * @memberof MessagesGet200Response
     */
    'nextPage'?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof MessagesGet200Response
     */
    'messages': Array<Message>;
}
/**
 * 
 * @export
 * @interface MessagesPatchPendingRequest
 */
export interface MessagesPatchPendingRequest {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesPatchPendingRequest
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface MessagesPatchRequest
 */
export interface MessagesPatchRequest {
    /**
     * 
     * @type {boolean}
     * @memberof MessagesPatchRequest
     */
    'resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MessagesPatchRequest
     */
    'text'?: string;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessagesPatchRequest
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessagesPatchRequest
     */
    'mentions'?: Array<string>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesPatchRequest
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface MessagesSearch200Response
 */
export interface MessagesSearch200Response {
    /**
     * 
     * @type {number}
     * @memberof MessagesSearch200Response
     */
    'nextPage'?: number;
    /**
     * 
     * @type {Array<Message>}
     * @memberof MessagesSearch200Response
     */
    'messages': Array<Message>;
    /**
     * 
     * @type {Array<Chat>}
     * @memberof MessagesSearch200Response
     */
    'chats'?: Array<Chat>;
}
/**
 * 
 * @export
 * @interface MiscOptions
 */
export interface MiscOptions {
    /**
     * Original ID from the provider
     * @type {string}
     * @memberof MiscOptions
     */
    'originalId'?: string;
    /**
     * WA Business template
     * @type {string}
     * @memberof MiscOptions
     */
    'templateId'?: string;
    /**
     * WA Business template params -- do not need to populate
     * @type {{ [key: string]: string; }}
     * @memberof MiscOptions
     */
    'templateParams'?: { [key: string]: string; };
    /**
     * Emulate typing behaviour before send
     * @type {boolean}
     * @memberof MiscOptions
     */
    'withTyping'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MiscOptions
     */
    'forwardCount'?: number;
    /**
     * 
     * @type {MiscOptionsForwarded}
     * @memberof MiscOptions
     */
    'forwarded'?: MiscOptionsForwarded;
    /**
     * Adds random whitespace to produce a distinct message
     * @type {boolean}
     * @memberof MiscOptions
     */
    'randomizeMessage'?: boolean;
    /**
     * the ID of the button clicked
     * @type {string}
     * @memberof MiscOptions
     */
    'buttonReplyId'?: string;
}
/**
 * the message being forwarded
 * @export
 * @interface MiscOptionsForwarded
 */
export interface MiscOptionsForwarded {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MiscOptionsForwarded
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof MiscOptionsForwarded
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'statusCode': number;
    /**
     * Specific description of the error
     * @type {string}
     * @memberof ModelError
     */
    'error': string;
    /**
     * What the error was
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * Some extra information about the error
     * @type {object}
     * @memberof ModelError
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface OrderDetails
 */
export interface OrderDetails {
    /**
     * 
     * @type {OrderPrice}
     * @memberof OrderDetails
     */
    'price'?: OrderPrice;
    /**
     * 
     * @type {Array<OrderProduct>}
     * @memberof OrderDetails
     */
    'products'?: Array<OrderProduct>;
}
/**
 * 
 * @export
 * @interface OrderPrice
 */
export interface OrderPrice {
    /**
     * actual price * 1000
     * @type {number}
     * @memberof OrderPrice
     */
    'total1000'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderPrice
     */
    'subtotal1000'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderPrice
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface OrderProduct
 */
export interface OrderProduct {
    /**
     * 
     * @type {MessageProduct}
     * @memberof OrderProduct
     */
    'product': MessageProduct;
    /**
     * 
     * @type {number}
     * @memberof OrderProduct
     */
    'quantity': number;
}
/**
 * Model for a product on an external platform (eg. WhatsApp)
 * @export
 * @interface PlatformProduct
 */
export interface PlatformProduct {
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProduct
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'currency': string;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformProduct
     */
    'isHidden': boolean;
    /**
     * 
     * @type {Array<ProductCategory>}
     * @memberof PlatformProduct
     */
    'categories'?: Array<ProductCategory> | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlatformProduct
     */
    'imageUrls': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlatformProduct
     */
    'reviewStatus': { [key: string]: string; };
    /**
     * 
     * @type {ProductAvailability}
     * @memberof PlatformProduct
     */
    'availability': ProductAvailability;
    /**
     * 
     * @type {ProductSyncStatus}
     * @memberof PlatformProduct
     */
    'syncStatus': ProductSyncStatus;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PlatformProduct
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PlatformProduct
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PlatformProductCategoriesGet200Response
 */
export interface PlatformProductCategoriesGet200Response {
    /**
     * 
     * @type {Array<ProductCategory>}
     * @memberof PlatformProductCategoriesGet200Response
     */
    'categories': Array<ProductCategory>;
}
/**
 * 
 * @export
 * @interface PlatformProductCreate
 */
export interface PlatformProductCreate {
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductCreate
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'currency': string;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformProductCreate
     */
    'isHidden': boolean;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'category'?: string | null;
}
/**
 * 
 * @export
 * @interface PlatformProductUpdate
 */
export interface PlatformProductUpdate {
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductUpdate
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformProductUpdate
     */
    'isHidden'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'category'?: string | null;
}
/**
 * 
 * @export
 * @interface PlatformProductsGet200Response
 */
export interface PlatformProductsGet200Response {
    /**
     * total products present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof PlatformProductsGet200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<PlatformProduct>}
     * @memberof PlatformProductsGet200Response
     */
    'products': Array<PlatformProduct>;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductsGet200Response
     */
    'nextPage'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PresenceType = {
    Available: 'available',
    Unavailable: 'unavailable',
    Typing: 'typing',
    StoppedTyping: 'stoppedTyping'
} as const;

export type PresenceType = typeof PresenceType[keyof typeof PresenceType];


/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'currency': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProductAvailability = {
    InStock: 'in-stock'
} as const;

export type ProductAvailability = typeof ProductAvailability[keyof typeof ProductAvailability];


/**
 * 
 * @export
 * @interface ProductCategory
 */
export interface ProductCategory {
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProductCategory
     */
    'productCount': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProductSyncStatus = {
    Synced: 'synced',
    PendingCreate: 'pendingCreate',
    PendingUpdate: 'pendingUpdate',
    PendingDelete: 'pendingDelete',
    SyncFailed: 'syncFailed'
} as const;

export type ProductSyncStatus = typeof ProductSyncStatus[keyof typeof ProductSyncStatus];


/**
 * 
 * @export
 * @interface QuotedMessage
 */
export interface QuotedMessage {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof QuotedMessage
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'senderContactId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'jpegThumbnail'?: string | null;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * Unique name of Tag
     * @type {string}
     * @memberof Tag
     */
    'name': string;
    /**
     * The filters for a dynamic tag
     * @type {object}
     * @memberof Tag
     */
    'filters'?: object | null;
    /**
     * 
     * @type {TagFieldValidation}
     * @memberof Tag
     */
    'validation'?: TagFieldValidation;
}
/**
 * @type TagFieldValidation
 * @export
 */
export type TagFieldValidation = TagFieldValidationOneOf | TagFieldValidationOneOf1;

/**
 * 
 * @export
 * @interface TagFieldValidationOneOf
 */
export interface TagFieldValidationOneOf {
    /**
     * 
     * @type {string}
     * @memberof TagFieldValidationOneOf
     */
    'type'?: TagFieldValidationOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TagFieldValidationOneOf
     */
    'format'?: TagFieldValidationOneOfFormatEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagFieldValidationOneOf
     */
    'enum'?: Array<string>;
}

export const TagFieldValidationOneOfTypeEnum = {
    String: 'string'
} as const;

export type TagFieldValidationOneOfTypeEnum = typeof TagFieldValidationOneOfTypeEnum[keyof typeof TagFieldValidationOneOfTypeEnum];
export const TagFieldValidationOneOfFormatEnum = {
    Email: 'email',
    Phone: 'phone',
    Uri: 'uri'
} as const;

export type TagFieldValidationOneOfFormatEnum = typeof TagFieldValidationOneOfFormatEnum[keyof typeof TagFieldValidationOneOfFormatEnum];

/**
 * 
 * @export
 * @interface TagFieldValidationOneOf1
 */
export interface TagFieldValidationOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof TagFieldValidationOneOf1
     */
    'type'?: TagFieldValidationOneOf1TypeEnum;
}

export const TagFieldValidationOneOf1TypeEnum = {
    Number: 'number',
    Integer: 'integer',
    Boolean: 'boolean'
} as const;

export type TagFieldValidationOneOf1TypeEnum = typeof TagFieldValidationOneOf1TypeEnum[keyof typeof TagFieldValidationOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface TagsGet200Response
 */
export interface TagsGet200Response {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagsGet200Response
     */
    'tags': Array<Tag>;
}
/**
 * 
 * @export
 * @interface TagsPatchRequest
 */
export interface TagsPatchRequest {
    /**
     * 
     * @type {TagFieldValidation}
     * @memberof TagsPatchRequest
     */
    'validation'?: TagFieldValidation;
}
/**
 * Description of the category of the template
 * @export
 * @enum {string}
 */

export const TemplateCategory = {
    AccountUpdate: 'account-update',
    PaymentUpdate: 'payment-update',
    PersonalFinanceUpdate: 'personal-finance-update',
    TransportationUpdate: 'transportation-update',
    ReservationUpdate: 'reservation-update',
    IssueResolution: 'issue-resolution',
    AppointmentUpdate: 'appointment-update',
    ShippingUpdate: 'shipping-update',
    TicketUpdate: 'ticket-update',
    AlertUpdate: 'alert-update',
    AutoReply: 'auto-reply',
    Otp: 'otp'
} as const;

export type TemplateCategory = typeof TemplateCategory[keyof typeof TemplateCategory];


/**
 * 
 * @export
 * @interface TemplateCreate
 */
export interface TemplateCreate {
    /**
     * 
     * @type {string}
     * @memberof TemplateCreate
     */
    'text': string;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof TemplateCreate
     */
    'buttons'?: Array<MessageButton>;
    /**
     * 
     * @type {Array<TemplateCreateAttachmentsInner>}
     * @memberof TemplateCreate
     */
    'attachments'?: Array<TemplateCreateAttachmentsInner>;
}
/**
 * 
 * @export
 * @interface TemplateCreateAttachmentsInner
 */
export interface TemplateCreateAttachmentsInner {
    /**
     * 
     * @type {MessageAttachmentType}
     * @memberof TemplateCreateAttachmentsInner
     */
    'type': MessageAttachmentType;
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateAttachmentsInner
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateAttachmentsInner
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface TemplateParams
 */
export interface TemplateParams {
    /**
     * 
     * @type {string}
     * @memberof TemplateParams
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateParams
     */
    'language': string;
    /**
     * 
     * @type {TemplateCategory}
     * @memberof TemplateParams
     */
    'category': TemplateCategory;
}
/**
 * 
 * @export
 * @interface TemplatesSubmitForReview200Response
 */
export interface TemplatesSubmitForReview200Response {
    /**
     * ID of the template submitted for review
     * @type {string}
     * @memberof TemplatesSubmitForReview200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TemplatesSubmitForReviewRequest
 */
export interface TemplatesSubmitForReviewRequest {
    /**
     * 
     * @type {TemplateParams}
     * @memberof TemplatesSubmitForReviewRequest
     */
    'params': TemplateParams;
    /**
     * 
     * @type {TemplateCreate}
     * @memberof TemplatesSubmitForReviewRequest
     */
    'message': TemplateCreate;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive an account. Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsArchive: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsArchive', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/archive`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {boolean} [logout] Closes the account and logs out from the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClose: async (accountId: string, logout?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsClose', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/close`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)

            if (logout !== undefined) {
                localVarQueryParameter['logout'] = logout;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsDelete', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] search accounts by ID/Nickname
         * @param {boolean} [all] 
         * @param {AccountState} [state] only fetch accounts with a state
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet: async (q?: string, all?: boolean, state?: AccountState, page?: number, count?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout and clear credentials from the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogout: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsLogout', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/logout`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsOpen: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsOpen', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/open`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update name of the account or its settings
         * @summary Update an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch: async (accountId: string, accountsPatchRequest?: AccountsPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsPatch', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new account
         * @param {AccountsPostRequest} [accountsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost: async (accountsPostRequest?: AccountsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Archive an account. Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsArchive(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsArchive(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {boolean} [logout] Closes the account and logs out from the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClose(accountId: string, logout?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClose(accountId, logout, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsDelete(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsDelete(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] search accounts by ID/Nickname
         * @param {boolean} [all] 
         * @param {AccountState} [state] only fetch accounts with a state
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsGet(q?: string, all?: boolean, state?: AccountState, page?: number, count?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(q, all, state, page, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout and clear credentials from the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLogout(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLogout(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsOpen(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsOpen(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update name of the account or its settings
         * @summary Update an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPatch(accountId: string, accountsPatchRequest?: AccountsPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPatch(accountId, accountsPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new account
         * @param {AccountsPostRequest} [accountsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPost(accountsPostRequest?: AccountsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPost(accountsPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Archive an account. Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsArchive(accountId: string, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.accountsArchive(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {boolean} [logout] Closes the account and logs out from the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClose(accountId: string, logout?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.accountsClose(accountId, logout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete(accountId: string, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.accountsDelete(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] search accounts by ID/Nickname
         * @param {boolean} [all] 
         * @param {AccountState} [state] only fetch accounts with a state
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(q?: string, all?: boolean, state?: AccountState, page?: number, count?: number, options?: any): AxiosPromise<AccountsGet200Response> {
            return localVarFp.accountsGet(q, all, state, page, count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout and clear credentials from the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogout(accountId: string, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.accountsLogout(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsOpen(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsOpen(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update name of the account or its settings
         * @summary Update an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch(accountId: string, accountsPatchRequest?: AccountsPatchRequest, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.accountsPatch(accountId, accountsPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new account
         * @param {AccountsPostRequest} [accountsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost(accountsPostRequest?: AccountsPostRequest, options?: any): AxiosPromise<Account> {
            return localVarFp.accountsPost(accountsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for accountsArchive operation in AccountApi.
 * @export
 * @interface AccountApiAccountsArchiveRequest
 */
export interface AccountApiAccountsArchiveRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsArchive
     */
    readonly accountId: string
}

/**
 * Request parameters for accountsClose operation in AccountApi.
 * @export
 * @interface AccountApiAccountsCloseRequest
 */
export interface AccountApiAccountsCloseRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsClose
     */
    readonly accountId: string

    /**
     * Closes the account and logs out from the account
     * @type {boolean}
     * @memberof AccountApiAccountsClose
     */
    readonly logout?: boolean
}

/**
 * Request parameters for accountsDelete operation in AccountApi.
 * @export
 * @interface AccountApiAccountsDeleteRequest
 */
export interface AccountApiAccountsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsDelete
     */
    readonly accountId: string
}

/**
 * Request parameters for accountsGet operation in AccountApi.
 * @export
 * @interface AccountApiAccountsGetRequest
 */
export interface AccountApiAccountsGetRequest {
    /**
     * search accounts by ID/Nickname
     * @type {string}
     * @memberof AccountApiAccountsGet
     */
    readonly q?: string

    /**
     * 
     * @type {boolean}
     * @memberof AccountApiAccountsGet
     */
    readonly all?: boolean

    /**
     * only fetch accounts with a state
     * @type {AccountState}
     * @memberof AccountApiAccountsGet
     */
    readonly state?: AccountState

    /**
     * 
     * @type {number}
     * @memberof AccountApiAccountsGet
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof AccountApiAccountsGet
     */
    readonly count?: number
}

/**
 * Request parameters for accountsLogout operation in AccountApi.
 * @export
 * @interface AccountApiAccountsLogoutRequest
 */
export interface AccountApiAccountsLogoutRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsLogout
     */
    readonly accountId: string
}

/**
 * Request parameters for accountsOpen operation in AccountApi.
 * @export
 * @interface AccountApiAccountsOpenRequest
 */
export interface AccountApiAccountsOpenRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsOpen
     */
    readonly accountId: string
}

/**
 * Request parameters for accountsPatch operation in AccountApi.
 * @export
 * @interface AccountApiAccountsPatchRequest
 */
export interface AccountApiAccountsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {AccountsPatchRequest}
     * @memberof AccountApiAccountsPatch
     */
    readonly accountsPatchRequest?: AccountsPatchRequest
}

/**
 * Request parameters for accountsPost operation in AccountApi.
 * @export
 * @interface AccountApiAccountsPostRequest
 */
export interface AccountApiAccountsPostRequest {
    /**
     * 
     * @type {AccountsPostRequest}
     * @memberof AccountApiAccountsPost
     */
    readonly accountsPostRequest?: AccountsPostRequest
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Archive an account. Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
     * @param {AccountApiAccountsArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsArchive(requestParameters: AccountApiAccountsArchiveRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsArchive(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Close connection to the account
     * @param {AccountApiAccountsCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsClose(requestParameters: AccountApiAccountsCloseRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsClose(requestParameters.accountId, requestParameters.logout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an account
     * @param {AccountApiAccountsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsDelete(requestParameters: AccountApiAccountsDeleteRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsDelete(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all accounts
     * @param {AccountApiAccountsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsGet(requestParameters: AccountApiAccountsGetRequest = {}, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsGet(requestParameters.q, requestParameters.all, requestParameters.state, requestParameters.page, requestParameters.count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout and clear credentials from the account
     * @param {AccountApiAccountsLogoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsLogout(requestParameters: AccountApiAccountsLogoutRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsLogout(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Open connection to the account
     * @param {AccountApiAccountsOpenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsOpen(requestParameters: AccountApiAccountsOpenRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsOpen(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update name of the account or its settings
     * @summary Update an account
     * @param {AccountApiAccountsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsPatch(requestParameters: AccountApiAccountsPatchRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsPatch(requestParameters.accountId, requestParameters.accountsPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new account
     * @param {AccountApiAccountsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsPost(requestParameters: AccountApiAccountsPostRequest = {}, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsPost(requestParameters.accountsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChatsApi - axios parameter creator
 * @export
 */
export const ChatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] 
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [hasFailedMessage] 
         * @param {boolean} [lastMessageFromMe] 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet: async (count?: number, page?: string, archive?: boolean, unread?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, hasFailedMessage?: boolean, lastMessageFromMe?: boolean, tags?: Array<string>, contacts?: Array<string>, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnUnreadChatCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (hasPendingMessage !== undefined) {
                localVarQueryParameter['hasPendingMessage'] = hasPendingMessage;
            }

            if (mentioned !== undefined) {
                localVarQueryParameter['mentioned'] = mentioned;
            }

            if (hasUnsolvedNote !== undefined) {
                localVarQueryParameter['hasUnsolvedNote'] = hasUnsolvedNote;
            }

            if (hasFailedMessage !== undefined) {
                localVarQueryParameter['hasFailedMessage'] = hasFailedMessage;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (returnUnreadChatCount !== undefined) {
                localVarQueryParameter['returnUnreadChatCount'] = returnUnreadChatCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPatch: async (accountId: string, id: string, chatAction?: ChatAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('chatsPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsPatch', 'id', id)
            const localVarPath = `/chats/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPresencePost: async (accountId: string, id: string, presence: PresenceType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('chatsPresencePost', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsPresencePost', 'id', id)
            // verify required parameter 'presence' is not null or undefined
            assertParamExists('chatsPresencePost', 'presence', presence)
            const localVarPath = `/chats/{accountId}/{id}/presence`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ASSIGNED", "CHATS_ACCESS_ALL"], configuration)

            if (presence !== undefined) {
                localVarQueryParameter['presence'] = presence;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatsApi - functional programming interface
 * @export
 */
export const ChatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] 
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [hasFailedMessage] 
         * @param {boolean} [lastMessageFromMe] 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsGet(count?: number, page?: string, archive?: boolean, unread?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, hasFailedMessage?: boolean, lastMessageFromMe?: boolean, tags?: Array<string>, contacts?: Array<string>, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnUnreadChatCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsGet(count, page, archive, unread, hasPendingMessage, mentioned, hasUnsolvedNote, hasFailedMessage, lastMessageFromMe, tags, contacts, q, assignee, accountId, type, returnUnreadChatCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPatch(accountId: string, id: string, chatAction?: ChatAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPatch(accountId, id, chatAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPresencePost(accountId: string, id: string, presence: PresenceType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPresencePost(accountId, id, presence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatsApi - factory interface
 * @export
 */
export const ChatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] 
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [hasFailedMessage] 
         * @param {boolean} [lastMessageFromMe] 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet(count?: number, page?: string, archive?: boolean, unread?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, hasFailedMessage?: boolean, lastMessageFromMe?: boolean, tags?: Array<string>, contacts?: Array<string>, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnUnreadChatCount?: boolean, options?: any): AxiosPromise<ChatsGet200Response> {
            return localVarFp.chatsGet(count, page, archive, unread, hasPendingMessage, mentioned, hasUnsolvedNote, hasFailedMessage, lastMessageFromMe, tags, contacts, q, assignee, accountId, type, returnUnreadChatCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPatch(accountId: string, id: string, chatAction?: ChatAction, options?: any): AxiosPromise<Chat> {
            return localVarFp.chatsPatch(accountId, id, chatAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPresencePost(accountId: string, id: string, presence: PresenceType, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.chatsPresencePost(accountId, id, presence, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for chatsGet operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsGetRequest
 */
export interface ChatsApiChatsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ChatsApiChatsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsGet
     */
    readonly page?: string

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly archive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly unread?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly hasPendingMessage?: boolean

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsGet
     */
    readonly mentioned?: string

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly hasUnsolvedNote?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly hasFailedMessage?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly lastMessageFromMe?: boolean

    /**
     * Get contacts who fall in either of these tags
     * @type {Array<string>}
     * @memberof ChatsApiChatsGet
     */
    readonly tags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {Array<string>}
     * @memberof ChatsApiChatsGet
     */
    readonly contacts?: Array<string>

    /**
     * Search string for contact name/phone number/email
     * @type {string}
     * @memberof ChatsApiChatsGet
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ChatsApiChatsGet
     */
    readonly assignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ChatsApiChatsGet
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {'group' | 'individual'}
     * @memberof ChatsApiChatsGet
     */
    readonly type?: 'group' | 'individual'

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly returnUnreadChatCount?: boolean
}

/**
 * Request parameters for chatsPatch operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsPatchRequest
 */
export interface ChatsApiChatsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPatch
     */
    readonly id: string

    /**
     * 
     * @type {ChatAction}
     * @memberof ChatsApiChatsPatch
     */
    readonly chatAction?: ChatAction
}

/**
 * Request parameters for chatsPresencePost operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsPresencePostRequest
 */
export interface ChatsApiChatsPresencePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPresencePost
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPresencePost
     */
    readonly id: string

    /**
     * 
     * @type {PresenceType}
     * @memberof ChatsApiChatsPresencePost
     */
    readonly presence: PresenceType
}

/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
export class ChatsApi extends BaseAPI {
    /**
     * 
     * @summary Get chats
     * @param {ChatsApiChatsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsGet(requestParameters: ChatsApiChatsGetRequest = {}, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsGet(requestParameters.count, requestParameters.page, requestParameters.archive, requestParameters.unread, requestParameters.hasPendingMessage, requestParameters.mentioned, requestParameters.hasUnsolvedNote, requestParameters.hasFailedMessage, requestParameters.lastMessageFromMe, requestParameters.tags, requestParameters.contacts, requestParameters.q, requestParameters.assignee, requestParameters.accountId, requestParameters.type, requestParameters.returnUnreadChatCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a chat -- read, unread, archive, pin etc.
     * @param {ChatsApiChatsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsPatch(requestParameters: ChatsApiChatsPatchRequest, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsPatch(requestParameters.accountId, requestParameters.id, requestParameters.chatAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
     * @summary Update a chat\'s presence.
     * @param {ChatsApiChatsPresencePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsPresencePost(requestParameters: ChatsApiChatsPresencePostRequest, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsPresencePost(requestParameters.accountId, requestParameters.id, requestParameters.presence, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Eg. provide a phone number to check whether the user is registered on WhatsApp
         * @summary Check a given user exists on the IM platform
         * @param {'whatsapp'} type which account type to check from
         * @param {string} [phoneNumber] check for the given phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsCheckExists: async (type: 'whatsapp', phoneNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('contactsCheckExists', 'type', type)
            const localVarPath = `/contacts/exists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_READ_ALL"], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDelete: async (tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_DELETE"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [returnLastMessage] 
         * @param {string} [page] 
         * @param {ContactsGetCountParameter} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet: async (tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnTotalCount?: boolean, returnLastMessage?: boolean, page?: string, count?: ContactsGetCountParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_READ_ALL", "CONTACTS_READ_ASSIGNED"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (returnLastMessage !== undefined) {
                localVarQueryParameter['returnLastMessage'] = returnLastMessage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {'preview' | 'full'} [type] Whether to fetch preview sized image or the full image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsImageGet: async (id: string, accountId: string, type?: 'preview' | 'full', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsImageGet', 'id', id)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('contactsImageGet', 'accountId', accountId)
            const localVarPath = `/contacts/{accountId}/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {string} [messageContainsText] 
         * @param {string} [messageFrom] 
         * @param {string} [messageTo] 
         * @param {boolean} [messageFromMe] 
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPatch: async (tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', messageContainsText?: string, messageFrom?: string, messageTo?: string, messageFromMe?: boolean, contactsPatch?: ContactsPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_UPDATE"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (messageContainsText !== undefined) {
                localVarQueryParameter['messageContainsText'] = messageContainsText;
            }

            if (messageFrom !== undefined) {
                localVarQueryParameter['messageFrom'] = (messageFrom as any instanceof Date) ?
                    (messageFrom as any).toISOString() :
                    messageFrom;
            }

            if (messageTo !== undefined) {
                localVarQueryParameter['messageTo'] = (messageTo as any instanceof Date) ?
                    (messageTo as any).toISOString() :
                    messageTo;
            }

            if (messageFromMe !== undefined) {
                localVarQueryParameter['messageFromMe'] = messageFromMe;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPost: async (contactsPost?: ContactsPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts/upsert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Eg. provide a phone number to check whether the user is registered on WhatsApp
         * @summary Check a given user exists on the IM platform
         * @param {'whatsapp'} type which account type to check from
         * @param {string} [phoneNumber] check for the given phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsCheckExists(type: 'whatsapp', phoneNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsCheckExists200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsCheckExists(type, phoneNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDelete(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDelete(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [returnLastMessage] 
         * @param {string} [page] 
         * @param {ContactsGetCountParameter} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGet(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnTotalCount?: boolean, returnLastMessage?: boolean, page?: string, count?: ContactsGetCountParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGet(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, returnTotalCount, returnLastMessage, page, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {'preview' | 'full'} [type] Whether to fetch preview sized image or the full image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsImageGet(id: string, accountId: string, type?: 'preview' | 'full', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsImageGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsImageGet(id, accountId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {string} [messageContainsText] 
         * @param {string} [messageFrom] 
         * @param {string} [messageTo] 
         * @param {boolean} [messageFromMe] 
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPatch(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', messageContainsText?: string, messageFrom?: string, messageTo?: string, messageFromMe?: boolean, contactsPatch?: ContactsPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPatch(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, messageContainsText, messageFrom, messageTo, messageFromMe, contactsPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPost(contactsPost?: ContactsPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPost(contactsPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * Eg. provide a phone number to check whether the user is registered on WhatsApp
         * @summary Check a given user exists on the IM platform
         * @param {'whatsapp'} type which account type to check from
         * @param {string} [phoneNumber] check for the given phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsCheckExists(type: 'whatsapp', phoneNumber?: string, options?: any): AxiosPromise<ContactsCheckExists200Response> {
            return localVarFp.contactsCheckExists(type, phoneNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDelete(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.contactsDelete(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [returnLastMessage] 
         * @param {string} [page] 
         * @param {ContactsGetCountParameter} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', returnTotalCount?: boolean, returnLastMessage?: boolean, page?: string, count?: ContactsGetCountParameter, options?: any): AxiosPromise<ContactsGet200Response> {
            return localVarFp.contactsGet(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, returnTotalCount, returnLastMessage, page, count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {'preview' | 'full'} [type] Whether to fetch preview sized image or the full image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsImageGet(id: string, accountId: string, type?: 'preview' | 'full', options?: any): AxiosPromise<ContactsImageGet200Response> {
            return localVarFp.contactsImageGet(id, accountId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update contacts
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {string} [messageContainsText] 
         * @param {string} [messageFrom] 
         * @param {string} [messageTo] 
         * @param {boolean} [messageFromMe] 
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPatch(tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', messageContainsText?: string, messageFrom?: string, messageTo?: string, messageFromMe?: boolean, contactsPatch?: ContactsPatch, options?: any): AxiosPromise<ContactsPatch200Response> {
            return localVarFp.contactsPatch(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, messageContainsText, messageFrom, messageTo, messageFromMe, contactsPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPost(contactsPost?: ContactsPost, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.contactsPost(contactsPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contactsCheckExists operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsCheckExistsRequest
 */
export interface ContactsApiContactsCheckExistsRequest {
    /**
     * which account type to check from
     * @type {'whatsapp'}
     * @memberof ContactsApiContactsCheckExists
     */
    readonly type: 'whatsapp'

    /**
     * check for the given phone number
     * @type {string}
     * @memberof ContactsApiContactsCheckExists
     */
    readonly phoneNumber?: string
}

/**
 * Request parameters for contactsDelete operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsDeleteRequest
 */
export interface ContactsApiContactsDeleteRequest {
    /**
     * Get contacts who fall in either of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly tags?: Array<string>

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly contacts?: Array<string>

    /**
     * Do not get these specific contacts
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly notContacts?: Array<string>

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly maxMessagesRecv?: number

    /**
     * Search string for contact name/phone number/email
     * @type {string}
     * @memberof ContactsApiContactsDelete
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly assignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {'group' | 'individual'}
     * @memberof ContactsApiContactsDelete
     */
    readonly type?: 'group' | 'individual'
}

/**
 * Request parameters for contactsGet operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsGetRequest
 */
export interface ContactsApiContactsGetRequest {
    /**
     * Get contacts who fall in either of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly tags?: Array<string>

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly contacts?: Array<string>

    /**
     * Do not get these specific contacts
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly notContacts?: Array<string>

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly maxMessagesRecv?: number

    /**
     * Search string for contact name/phone number/email
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly assignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {'group' | 'individual'}
     * @memberof ContactsApiContactsGet
     */
    readonly type?: 'group' | 'individual'

    /**
     * 
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly returnLastMessage?: boolean

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly page?: string

    /**
     * 
     * @type {ContactsGetCountParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly count?: ContactsGetCountParameter
}

/**
 * Request parameters for contactsImageGet operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsImageGetRequest
 */
export interface ContactsApiContactsImageGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsImageGet
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsImageGet
     */
    readonly accountId: string

    /**
     * Whether to fetch preview sized image or the full image
     * @type {'preview' | 'full'}
     * @memberof ContactsApiContactsImageGet
     */
    readonly type?: 'preview' | 'full'
}

/**
 * Request parameters for contactsPatch operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsPatchRequest
 */
export interface ContactsApiContactsPatchRequest {
    /**
     * Get contacts who fall in either of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly tags?: Array<string>

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly contacts?: Array<string>

    /**
     * Do not get these specific contacts
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly notContacts?: Array<string>

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly maxMessagesRecv?: number

    /**
     * Search string for contact name/phone number/email
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly assignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {'group' | 'individual'}
     * @memberof ContactsApiContactsPatch
     */
    readonly type?: 'group' | 'individual'

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly messageContainsText?: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly messageFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly messageTo?: string

    /**
     * 
     * @type {boolean}
     * @memberof ContactsApiContactsPatch
     */
    readonly messageFromMe?: boolean

    /**
     * 
     * @type {ContactsPatch}
     * @memberof ContactsApiContactsPatch
     */
    readonly contactsPatch?: ContactsPatch
}

/**
 * Request parameters for contactsPost operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsPostRequest
 */
export interface ContactsApiContactsPostRequest {
    /**
     * 
     * @type {ContactsPost}
     * @memberof ContactsApiContactsPost
     */
    readonly contactsPost?: ContactsPost
}

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * Eg. provide a phone number to check whether the user is registered on WhatsApp
     * @summary Check a given user exists on the IM platform
     * @param {ContactsApiContactsCheckExistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsCheckExists(requestParameters: ContactsApiContactsCheckExistsRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsCheckExists(requestParameters.type, requestParameters.phoneNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete contacts
     * @param {ContactsApiContactsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsDelete(requestParameters: ContactsApiContactsDeleteRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsDelete(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.accountId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contacts
     * @param {ContactsApiContactsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsGet(requestParameters: ContactsApiContactsGetRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsGet(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.accountId, requestParameters.type, requestParameters.returnTotalCount, requestParameters.returnLastMessage, requestParameters.page, requestParameters.count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the display image of a contact
     * @param {ContactsApiContactsImageGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsImageGet(requestParameters: ContactsApiContactsImageGetRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsImageGet(requestParameters.id, requestParameters.accountId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update contacts
     * @param {ContactsApiContactsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsPatch(requestParameters: ContactsApiContactsPatchRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsPatch(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.accountId, requestParameters.type, requestParameters.messageContainsText, requestParameters.messageFrom, requestParameters.messageTo, requestParameters.messageFromMe, requestParameters.contactsPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create contacts
     * @param {ContactsApiContactsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsPost(requestParameters: ContactsApiContactsPostRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsPost(requestParameters.contactsPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the aggregate metadata about a team\'\'s performance.  Returns data sorted by chat, user and mentions the messages sent, tasks completed etc. 
         * @summary Get the aggregate metadata
         * @param {Array<string>} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet: async (accountId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the aggregate metadata about a team\'\'s performance.  Returns data sorted by chat, user and mentions the messages sent, tasks completed etc. 
         * @summary Get the aggregate metadata
         * @param {Array<string>} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataGet(accountId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * Returns the aggregate metadata about a team\'\'s performance.  Returns data sorted by chat, user and mentions the messages sent, tasks completed etc. 
         * @summary Get the aggregate metadata
         * @param {Array<string>} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet(accountId?: Array<string>, options?: any): AxiosPromise<DataModel> {
            return localVarFp.dataGet(accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataGet operation in DataApi.
 * @export
 * @interface DataApiDataGetRequest
 */
export interface DataApiDataGetRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DataApiDataGet
     */
    readonly accountId?: Array<string>
}

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Returns the aggregate metadata about a team\'\'s performance.  Returns data sorted by chat, user and mentions the messages sent, tasks completed etc. 
     * @summary Get the aggregate metadata
     * @param {DataApiDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public dataGet(requestParameters: DataApiDataGetRequest = {}, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).dataGet(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost: async (mimetype: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mimetype' is not null or undefined
            assertParamExists('filesPost', 'mimetype', mimetype)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('filesPost', 'name', name)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (mimetype !== undefined) {
                localVarQueryParameter['mimetype'] = mimetype;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesPost(mimetype: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesPost(mimetype, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost(mimetype: string, name: string, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.filesPost(mimetype, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for filesPost operation in FilesApi.
 * @export
 * @interface FilesApiFilesPostRequest
 */
export interface FilesApiFilesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof FilesApiFilesPost
     */
    readonly mimetype: string

    /**
     * 
     * @type {string}
     * @memberof FilesApiFilesPost
     */
    readonly name: string
}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Upload a file to the media files bucket
     * @param {FilesApiFilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesPost(requestParameters: FilesApiFilesPostRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesPost(requestParameters.mimetype, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet: async (accountId: string, id: string, forceRefresh?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsGet', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsGet', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)

            if (forceRefresh !== undefined) {
                localVarQueryParameter['forceRefresh'] = forceRefresh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsInviteCode: async (accountId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsInviteCode', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsInviteCode', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}/invite-code`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsJoin: async (accountId: string, id: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsJoin', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsJoin', 'id', id)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('groupsJoin', 'code', code)
            const localVarPath = `/groups/{accountId}/{id}/join`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsLeave: async (accountId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsLeave', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsLeave', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}/leave`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPatch: async (accountId: string, id: string, groupAction?: GroupAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsPatch', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost: async (accountId: string, groupCreate?: GroupCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsPost', 'accountId', accountId)
            const localVarPath = `/groups/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGet(accountId: string, id: string, forceRefresh?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGet(accountId, id, forceRefresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsInviteCode(accountId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupsInviteCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsInviteCode(accountId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsJoin(accountId: string, id: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsJoin(accountId, id, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsLeave(accountId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsLeave(accountId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPatch(accountId: string, id: string, groupAction?: GroupAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPatch(accountId, id, groupAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPost(accountId: string, groupCreate?: GroupCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPost(accountId, groupCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet(accountId: string, id: string, forceRefresh?: boolean, options?: any): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsGet(accountId, id, forceRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsInviteCode(accountId: string, id: string, options?: any): AxiosPromise<GroupsInviteCode200Response> {
            return localVarFp.groupsInviteCode(accountId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsJoin(accountId: string, id: string, code: string, options?: any): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsJoin(accountId, id, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsLeave(accountId: string, id: string, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.groupsLeave(accountId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPatch(accountId: string, id: string, groupAction?: GroupAction, options?: any): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsPatch(accountId, id, groupAction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost(accountId: string, groupCreate?: GroupCreate, options?: any): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsPost(accountId, groupCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for groupsGet operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsGetRequest
 */
export interface GroupsApiGroupsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsGet
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsGet
     */
    readonly id: string

    /**
     * Fetches the group metadata again from the platform
     * @type {boolean}
     * @memberof GroupsApiGroupsGet
     */
    readonly forceRefresh?: boolean
}

/**
 * Request parameters for groupsInviteCode operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsInviteCodeRequest
 */
export interface GroupsApiGroupsInviteCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsInviteCode
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsInviteCode
     */
    readonly id: string
}

/**
 * Request parameters for groupsJoin operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsJoinRequest
 */
export interface GroupsApiGroupsJoinRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsJoin
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsJoin
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsJoin
     */
    readonly code: string
}

/**
 * Request parameters for groupsLeave operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsLeaveRequest
 */
export interface GroupsApiGroupsLeaveRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsLeave
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsLeave
     */
    readonly id: string
}

/**
 * Request parameters for groupsPatch operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsPatchRequest
 */
export interface GroupsApiGroupsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsPatch
     */
    readonly id: string

    /**
     * 
     * @type {GroupAction}
     * @memberof GroupsApiGroupsPatch
     */
    readonly groupAction?: GroupAction
}

/**
 * Request parameters for groupsPost operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsPostRequest
 */
export interface GroupsApiGroupsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsPost
     */
    readonly accountId: string

    /**
     * 
     * @type {GroupCreate}
     * @memberof GroupsApiGroupsPost
     */
    readonly groupCreate?: GroupCreate
}

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Get metadata for a group
     * @param {GroupsApiGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGet(requestParameters: GroupsApiGroupsGetRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGet(requestParameters.accountId, requestParameters.id, requestParameters.forceRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invite code for a group
     * @param {GroupsApiGroupsInviteCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsInviteCode(requestParameters: GroupsApiGroupsInviteCodeRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsInviteCode(requestParameters.accountId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a group using invite code
     * @param {GroupsApiGroupsJoinRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsJoin(requestParameters: GroupsApiGroupsJoinRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsJoin(requestParameters.accountId, requestParameters.id, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave a group
     * @param {GroupsApiGroupsLeaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsLeave(requestParameters: GroupsApiGroupsLeaveRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsLeave(requestParameters.accountId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a group
     * @param {GroupsApiGroupsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPatch(requestParameters: GroupsApiGroupsPatchRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsPatch(requestParameters.accountId, requestParameters.id, requestParameters.groupAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new group
     * @param {GroupsApiGroupsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPost(requestParameters: GroupsApiGroupsPostRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsPost(requestParameters.accountId, requestParameters.groupCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete: async (accountId: string, chatId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesDelete', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesDelete', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesDelete', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clears all pending/error messages
         * @param {'pending' | 'error'} status 
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDeletePending: async (status: 'pending' | 'error', accountId?: string, chatId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('messagesDeletePending', 'status', status)
            const localVarPath = `/messages/{status}/retry`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_DELETE"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {Array<string>} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesForward: async (accountId: string, chatId: string, id: string, toChatId: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesForward', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesForward', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesForward', 'id', id)
            // verify required parameter 'toChatId' is not null or undefined
            assertParamExists('messagesForward', 'toChatId', toChatId)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/forward`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL"], configuration)

            if (toChatId) {
                localVarQueryParameter['toChatId'] = toChatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {'note' | 'pending' | 'error'} [status] fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesGet: async (accountId: string, chatId: string, beforeId?: string, count?: number, forceReload?: boolean, status?: 'note' | 'pending' | 'error', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesGet', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesGet', 'chatId', chatId)
            const localVarPath = `/messages/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (beforeId !== undefined) {
                localVarQueryParameter['beforeId'] = beforeId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (forceReload !== undefined) {
                localVarQueryParameter['forceReload'] = forceReload;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesPatchRequest} [messagesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatch: async (accountId: string, chatId: string, id: string, messagesPatchRequest?: MessagesPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesPatch', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesPatch', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesPatch', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messagesPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry all the messages in a given status
         * @param {'pending' | 'error'} status 
         * @param {MessagesPatchPendingRequest} [messagesPatchPendingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatchPending: async (status: 'pending' | 'error', messagesPatchPendingRequest?: MessagesPatchPendingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('messagesPatchPending', 'status', status)
            const localVarPath = `/messages/{status}/retry`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messagesPatchPendingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message
         * @param {string} accountId The account to use to send the message.  Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId The contact to send the message to.   To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {boolean} [useRandomAccountIfAccountClosed] Use random account (if available) to send the message, if the account specified is closed
         * @param {boolean} [includeMarketingMessage] Includes the default marketing message for the account in the message
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPost: async (accountId: string, chatId: string, requireOpenAccount?: boolean, useRandomAccountIfAccountClosed?: boolean, includeMarketingMessage?: boolean, messageCompose?: MessageCompose, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesPost', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesPost', 'chatId', chatId)
            const localVarPath = `/messages/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)

            if (requireOpenAccount !== undefined) {
                localVarQueryParameter['requireOpenAccount'] = requireOpenAccount;
            }

            if (useRandomAccountIfAccountClosed !== undefined) {
                localVarQueryParameter['useRandomAccountIfAccountClosed'] = useRandomAccountIfAccountClosed;
            }

            if (includeMarketingMessage !== undefined) {
                localVarQueryParameter['includeMarketingMessage'] = includeMarketingMessage;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCompose, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesRefresh: async (accountId: string, chatId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesRefresh', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesRefresh', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesRefresh', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/refresh`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search messages
         * @param {string} q 
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {string} [chatId] 
         * @param {number} [page] Page number
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSearch: async (q: string, accountId?: Array<string>, chatId?: string, page?: number, count?: number, returnChats?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('messagesSearch', 'q', q)
            const localVarPath = `/messages/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (returnChats !== undefined) {
                localVarQueryParameter['returnChats'] = returnChats;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesDelete(accountId: string, chatId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesDelete(accountId, chatId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Clears all pending/error messages
         * @param {'pending' | 'error'} status 
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesDeletePending(status: 'pending' | 'error', accountId?: string, chatId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesDeletePending(status, accountId, chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {Array<string>} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesForward(accountId: string, chatId: string, id: string, toChatId: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesForward(accountId, chatId, id, toChatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {'note' | 'pending' | 'error'} [status] fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesGet(accountId: string, chatId: string, beforeId?: string, count?: number, forceReload?: boolean, status?: 'note' | 'pending' | 'error', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesGet(accountId, chatId, beforeId, count, forceReload, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesPatchRequest} [messagesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPatch(accountId: string, chatId: string, id: string, messagesPatchRequest?: MessagesPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPatch(accountId, chatId, id, messagesPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retry all the messages in a given status
         * @param {'pending' | 'error'} status 
         * @param {MessagesPatchPendingRequest} [messagesPatchPendingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPatchPending(status: 'pending' | 'error', messagesPatchPendingRequest?: MessagesPatchPendingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPatchPending(status, messagesPatchPendingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message
         * @param {string} accountId The account to use to send the message.  Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId The contact to send the message to.   To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {boolean} [useRandomAccountIfAccountClosed] Use random account (if available) to send the message, if the account specified is closed
         * @param {boolean} [includeMarketingMessage] Includes the default marketing message for the account in the message
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPost(accountId: string, chatId: string, requireOpenAccount?: boolean, useRandomAccountIfAccountClosed?: boolean, includeMarketingMessage?: boolean, messageCompose?: MessageCompose, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPost(accountId, chatId, requireOpenAccount, useRandomAccountIfAccountClosed, includeMarketingMessage, messageCompose, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesRefresh(accountId: string, chatId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesRefresh(accountId, chatId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search messages
         * @param {string} q 
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {string} [chatId] 
         * @param {number} [page] Page number
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesSearch(q: string, accountId?: Array<string>, chatId?: string, page?: number, count?: number, returnChats?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesSearch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesSearch(q, accountId, chatId, page, count, returnChats, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete(accountId: string, chatId: string, id: string, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.messagesDelete(accountId, chatId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clears all pending/error messages
         * @param {'pending' | 'error'} status 
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDeletePending(status: 'pending' | 'error', accountId?: string, chatId?: string, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.messagesDeletePending(status, accountId, chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {Array<string>} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesForward(accountId: string, chatId: string, id: string, toChatId: Array<string>, options?: any): AxiosPromise<Array<Message>> {
            return localVarFp.messagesForward(accountId, chatId, id, toChatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {'note' | 'pending' | 'error'} [status] fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesGet(accountId: string, chatId: string, beforeId?: string, count?: number, forceReload?: boolean, status?: 'note' | 'pending' | 'error', options?: any): AxiosPromise<MessagesGet200Response> {
            return localVarFp.messagesGet(accountId, chatId, beforeId, count, forceReload, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesPatchRequest} [messagesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatch(accountId: string, chatId: string, id: string, messagesPatchRequest?: MessagesPatchRequest, options?: any): AxiosPromise<Message> {
            return localVarFp.messagesPatch(accountId, chatId, id, messagesPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retry all the messages in a given status
         * @param {'pending' | 'error'} status 
         * @param {MessagesPatchPendingRequest} [messagesPatchPendingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatchPending(status: 'pending' | 'error', messagesPatchPendingRequest?: MessagesPatchPendingRequest, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.messagesPatchPending(status, messagesPatchPendingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message
         * @param {string} accountId The account to use to send the message.  Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId The contact to send the message to.   To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {boolean} [useRandomAccountIfAccountClosed] Use random account (if available) to send the message, if the account specified is closed
         * @param {boolean} [includeMarketingMessage] Includes the default marketing message for the account in the message
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPost(accountId: string, chatId: string, requireOpenAccount?: boolean, useRandomAccountIfAccountClosed?: boolean, includeMarketingMessage?: boolean, messageCompose?: MessageCompose, options?: any): AxiosPromise<Array<Message>> {
            return localVarFp.messagesPost(accountId, chatId, requireOpenAccount, useRandomAccountIfAccountClosed, includeMarketingMessage, messageCompose, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesRefresh(accountId: string, chatId: string, id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.messagesRefresh(accountId, chatId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search messages
         * @param {string} q 
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {string} [chatId] 
         * @param {number} [page] Page number
         * @param {number} [count] Number of messages to fetch
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSearch(q: string, accountId?: Array<string>, chatId?: string, page?: number, count?: number, returnChats?: boolean, options?: any): AxiosPromise<MessagesSearch200Response> {
            return localVarFp.messagesSearch(q, accountId, chatId, page, count, returnChats, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for messagesDelete operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesDeleteRequest
 */
export interface MessagesApiMessagesDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesDelete
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesDelete
     */
    readonly id: string
}

/**
 * Request parameters for messagesDeletePending operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesDeletePendingRequest
 */
export interface MessagesApiMessagesDeletePendingRequest {
    /**
     * 
     * @type {'pending' | 'error'}
     * @memberof MessagesApiMessagesDeletePending
     */
    readonly status: 'pending' | 'error'

    /**
     * If specified, only clears messages of this account
     * @type {string}
     * @memberof MessagesApiMessagesDeletePending
     */
    readonly accountId?: string

    /**
     * If specified, only clears messages of this chat
     * @type {string}
     * @memberof MessagesApiMessagesDeletePending
     */
    readonly chatId?: string
}

/**
 * Request parameters for messagesForward operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesForwardRequest
 */
export interface MessagesApiMessagesForwardRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesForward
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesForward
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesForward
     */
    readonly id: string

    /**
     * 
     * @type {Array<string>}
     * @memberof MessagesApiMessagesForward
     */
    readonly toChatId: Array<string>
}

/**
 * Request parameters for messagesGet operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesGetRequest
 */
export interface MessagesApiMessagesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesGet
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesGet
     */
    readonly chatId: string

    /**
     * Get messages before this message ID
     * @type {string}
     * @memberof MessagesApiMessagesGet
     */
    readonly beforeId?: string

    /**
     * Number of messages to fetch
     * @type {number}
     * @memberof MessagesApiMessagesGet
     */
    readonly count?: number

    /**
     * Deletes all cached messages for this chat &amp; fetches messages again from the original API source
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly forceReload?: boolean

    /**
     * fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
     * @type {'note' | 'pending' | 'error'}
     * @memberof MessagesApiMessagesGet
     */
    readonly status?: 'note' | 'pending' | 'error'
}

/**
 * Request parameters for messagesPatch operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesPatchRequest
 */
export interface MessagesApiMessagesPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesPatch
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesPatch
     */
    readonly id: string

    /**
     * 
     * @type {MessagesPatchRequest}
     * @memberof MessagesApiMessagesPatch
     */
    readonly messagesPatchRequest?: MessagesPatchRequest
}

/**
 * Request parameters for messagesPatchPending operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesPatchPendingRequest
 */
export interface MessagesApiMessagesPatchPendingRequest {
    /**
     * 
     * @type {'pending' | 'error'}
     * @memberof MessagesApiMessagesPatchPending
     */
    readonly status: 'pending' | 'error'

    /**
     * 
     * @type {MessagesPatchPendingRequest}
     * @memberof MessagesApiMessagesPatchPending
     */
    readonly messagesPatchPendingRequest?: MessagesPatchPendingRequest
}

/**
 * Request parameters for messagesPost operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesPostRequest
 */
export interface MessagesApiMessagesPostRequest {
    /**
     * The account to use to send the message.  Pass as the literal \&quot;random\&quot; to use a random account 
     * @type {string}
     * @memberof MessagesApiMessagesPost
     */
    readonly accountId: string

    /**
     * The contact to send the message to.   To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
     * @type {string}
     * @memberof MessagesApiMessagesPost
     */
    readonly chatId: string

    /**
     * Only sends the message if the account is open, returns 428 otherwise
     * @type {boolean}
     * @memberof MessagesApiMessagesPost
     */
    readonly requireOpenAccount?: boolean

    /**
     * Use random account (if available) to send the message, if the account specified is closed
     * @type {boolean}
     * @memberof MessagesApiMessagesPost
     */
    readonly useRandomAccountIfAccountClosed?: boolean

    /**
     * Includes the default marketing message for the account in the message
     * @type {boolean}
     * @memberof MessagesApiMessagesPost
     */
    readonly includeMarketingMessage?: boolean

    /**
     * 
     * @type {MessageCompose}
     * @memberof MessagesApiMessagesPost
     */
    readonly messageCompose?: MessageCompose
}

/**
 * Request parameters for messagesRefresh operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesRefreshRequest
 */
export interface MessagesApiMessagesRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesRefresh
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesRefresh
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesRefresh
     */
    readonly id: string
}

/**
 * Request parameters for messagesSearch operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesSearchRequest
 */
export interface MessagesApiMessagesSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesSearch
     */
    readonly q: string

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof MessagesApiMessagesSearch
     */
    readonly accountId?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesSearch
     */
    readonly chatId?: string

    /**
     * Page number
     * @type {number}
     * @memberof MessagesApiMessagesSearch
     */
    readonly page?: number

    /**
     * Number of messages to fetch
     * @type {number}
     * @memberof MessagesApiMessagesSearch
     */
    readonly count?: number

    /**
     * Return the corresponding chats alongside the messages
     * @type {boolean}
     * @memberof MessagesApiMessagesSearch
     */
    readonly returnChats?: boolean
}

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a message
     * @param {MessagesApiMessagesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesDelete(requestParameters: MessagesApiMessagesDeleteRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesDelete(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clears all pending/error messages
     * @param {MessagesApiMessagesDeletePendingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesDeletePending(requestParameters: MessagesApiMessagesDeletePendingRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesDeletePending(requestParameters.status, requestParameters.accountId, requestParameters.chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MessagesApiMessagesForwardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesForward(requestParameters: MessagesApiMessagesForwardRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesForward(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.toChatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch messages of the chat
     * @param {MessagesApiMessagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesGet(requestParameters: MessagesApiMessagesGetRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesGet(requestParameters.accountId, requestParameters.chatId, requestParameters.beforeId, requestParameters.count, requestParameters.forceReload, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can reschedule a message, update the content of a note or mark it as resolved 
     * @summary Modify a message/note
     * @param {MessagesApiMessagesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPatch(requestParameters: MessagesApiMessagesPatchRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesPatch(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.messagesPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retry all the messages in a given status
     * @param {MessagesApiMessagesPatchPendingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPatchPending(requestParameters: MessagesApiMessagesPatchPendingRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesPatchPending(requestParameters.status, requestParameters.messagesPatchPendingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
     * @summary Send a message
     * @param {MessagesApiMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPost(requestParameters: MessagesApiMessagesPostRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesPost(requestParameters.accountId, requestParameters.chatId, requestParameters.requireOpenAccount, requestParameters.useRandomAccountIfAccountClosed, requestParameters.includeMarketingMessage, requestParameters.messageCompose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refresh a message, in case the media expired
     * @param {MessagesApiMessagesRefreshRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesRefresh(requestParameters: MessagesApiMessagesRefreshRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesRefresh(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search messages
     * @param {MessagesApiMessagesSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesSearch(requestParameters: MessagesApiMessagesSearchRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesSearch(requestParameters.q, requestParameters.accountId, requestParameters.chatId, requestParameters.page, requestParameters.count, requestParameters.returnChats, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch details of an order (likely from an order message)
         * @param {string} accountId 
         * @param {string} orderId 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailsGet: async (accountId: string, orderId: string, token?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('orderDetailsGet', 'accountId', accountId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderDetailsGet', 'orderId', orderId)
            const localVarPath = `/{accountId}/{orderId}/order-details`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the categories (collections) from WA catalog.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a product from the WA catalog
         * @param {string} accountId 
         * @param {Array<string>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsDelete: async (accountId: string, id: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsDelete', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('platformProductsDelete', 'id', id)
            const localVarPath = `/products/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_DELETE"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the WA catalog. Only available on WA Business apps. 
         * @summary Get the products from WA catalog.
         * @param {Array<string>} [accountId] 
         * @param {string} [q] Filter if product title/description contains this
         * @param {string} [category] Filter based on collection/category
         * @param {Array<string>} [id] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsGet: async (accountId?: Array<string>, q?: string, category?: string, id?: Array<string>, cursor?: string, returnTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_GET"], configuration)

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a product in the WA catalog
         * @param {string} accountId 
         * @param {string} id 
         * @param {PlatformProductUpdate} [platformProductUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPatch: async (accountId: string, id: string, platformProductUpdate?: PlatformProductUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('platformProductsPatch', 'id', id)
            const localVarPath = `/products/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformProductUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a product to the WA catalog
         * @param {string} accountId 
         * @param {PlatformProductCreate} [platformProductCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPost: async (accountId: string, platformProductCreate?: PlatformProductCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsPost', 'accountId', accountId)
            const localVarPath = `/products/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformProductCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {Array<string>} [id] Products to sync with WhatsApp. Leave unspecified to trigger all
         * @param {boolean} [syncForward] Sync products from ChatDaddy to WhatsApp
         * @param {boolean} [syncBackward] Sync missing products from WhatsApp to ChatDaddy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsSync: async (id?: Array<string>, syncForward?: boolean, syncBackward?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (syncForward !== undefined) {
                localVarQueryParameter['syncForward'] = syncForward;
            }

            if (syncBackward !== undefined) {
                localVarQueryParameter['syncBackward'] = syncBackward;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch details of an order (likely from an order message)
         * @param {string} accountId 
         * @param {string} orderId 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDetailsGet(accountId: string, orderId: string, token?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDetailsGet(accountId, orderId, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the categories (collections) from WA catalog.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductCategoriesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductCategoriesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductCategoriesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a product from the WA catalog
         * @param {string} accountId 
         * @param {Array<string>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsDelete(accountId: string, id: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsDelete(accountId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the WA catalog. Only available on WA Business apps. 
         * @summary Get the products from WA catalog.
         * @param {Array<string>} [accountId] 
         * @param {string} [q] Filter if product title/description contains this
         * @param {string} [category] Filter based on collection/category
         * @param {Array<string>} [id] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsGet(accountId?: Array<string>, q?: string, category?: string, id?: Array<string>, cursor?: string, returnTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsGet(accountId, q, category, id, cursor, returnTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a product in the WA catalog
         * @param {string} accountId 
         * @param {string} id 
         * @param {PlatformProductUpdate} [platformProductUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsPatch(accountId: string, id: string, platformProductUpdate?: PlatformProductUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsPatch(accountId, id, platformProductUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a product to the WA catalog
         * @param {string} accountId 
         * @param {PlatformProductCreate} [platformProductCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsPost(accountId: string, platformProductCreate?: PlatformProductCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsPost(accountId, platformProductCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {Array<string>} [id] Products to sync with WhatsApp. Leave unspecified to trigger all
         * @param {boolean} [syncForward] Sync products from ChatDaddy to WhatsApp
         * @param {boolean} [syncBackward] Sync missing products from WhatsApp to ChatDaddy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsSync(id?: Array<string>, syncForward?: boolean, syncBackward?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsSync(id, syncForward, syncBackward, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch details of an order (likely from an order message)
         * @param {string} accountId 
         * @param {string} orderId 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailsGet(accountId: string, orderId: string, token?: string, options?: any): AxiosPromise<OrderDetails> {
            return localVarFp.orderDetailsGet(accountId, orderId, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the categories (collections) from WA catalog.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesGet(options?: any): AxiosPromise<PlatformProductCategoriesGet200Response> {
            return localVarFp.platformProductCategoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a product from the WA catalog
         * @param {string} accountId 
         * @param {Array<string>} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsDelete(accountId: string, id: Array<string>, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.platformProductsDelete(accountId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the WA catalog. Only available on WA Business apps. 
         * @summary Get the products from WA catalog.
         * @param {Array<string>} [accountId] 
         * @param {string} [q] Filter if product title/description contains this
         * @param {string} [category] Filter based on collection/category
         * @param {Array<string>} [id] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsGet(accountId?: Array<string>, q?: string, category?: string, id?: Array<string>, cursor?: string, returnTotalCount?: boolean, options?: any): AxiosPromise<PlatformProductsGet200Response> {
            return localVarFp.platformProductsGet(accountId, q, category, id, cursor, returnTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a product in the WA catalog
         * @param {string} accountId 
         * @param {string} id 
         * @param {PlatformProductUpdate} [platformProductUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPatch(accountId: string, id: string, platformProductUpdate?: PlatformProductUpdate, options?: any): AxiosPromise<PlatformProduct> {
            return localVarFp.platformProductsPatch(accountId, id, platformProductUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a product to the WA catalog
         * @param {string} accountId 
         * @param {PlatformProductCreate} [platformProductCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPost(accountId: string, platformProductCreate?: PlatformProductCreate, options?: any): AxiosPromise<PlatformProduct> {
            return localVarFp.platformProductsPost(accountId, platformProductCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {Array<string>} [id] Products to sync with WhatsApp. Leave unspecified to trigger all
         * @param {boolean} [syncForward] Sync products from ChatDaddy to WhatsApp
         * @param {boolean} [syncBackward] Sync missing products from WhatsApp to ChatDaddy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsSync(id?: Array<string>, syncForward?: boolean, syncBackward?: boolean, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.platformProductsSync(id, syncForward, syncBackward, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orderDetailsGet operation in ProductApi.
 * @export
 * @interface ProductApiOrderDetailsGetRequest
 */
export interface ProductApiOrderDetailsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiOrderDetailsGet
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiOrderDetailsGet
     */
    readonly orderId: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiOrderDetailsGet
     */
    readonly token?: string
}

/**
 * Request parameters for platformProductsDelete operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsDeleteRequest
 */
export interface ProductApiPlatformProductsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly id: Array<string>
}

/**
 * Request parameters for platformProductsGet operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsGetRequest
 */
export interface ProductApiPlatformProductsGetRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly accountId?: Array<string>

    /**
     * Filter if product title/description contains this
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly q?: string

    /**
     * Filter based on collection/category
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly category?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {boolean}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly returnTotalCount?: boolean
}

/**
 * Request parameters for platformProductsPatch operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsPatchRequest
 */
export interface ProductApiPlatformProductsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly id: string

    /**
     * 
     * @type {PlatformProductUpdate}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly platformProductUpdate?: PlatformProductUpdate
}

/**
 * Request parameters for platformProductsPost operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsPostRequest
 */
export interface ProductApiPlatformProductsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsPost
     */
    readonly accountId: string

    /**
     * 
     * @type {PlatformProductCreate}
     * @memberof ProductApiPlatformProductsPost
     */
    readonly platformProductCreate?: PlatformProductCreate
}

/**
 * Request parameters for platformProductsSync operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsSyncRequest
 */
export interface ProductApiPlatformProductsSyncRequest {
    /**
     * Products to sync with WhatsApp. Leave unspecified to trigger all
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly id?: Array<string>

    /**
     * Sync products from ChatDaddy to WhatsApp
     * @type {boolean}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly syncForward?: boolean

    /**
     * Sync missing products from WhatsApp to ChatDaddy
     * @type {boolean}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly syncBackward?: boolean
}

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary Fetch details of an order (likely from an order message)
     * @param {ProductApiOrderDetailsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public orderDetailsGet(requestParameters: ProductApiOrderDetailsGetRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).orderDetailsGet(requestParameters.accountId, requestParameters.orderId, requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the categories (collections) from WA catalog.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductCategoriesGet(options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductCategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a product from the WA catalog
     * @param {ProductApiPlatformProductsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsDelete(requestParameters: ProductApiPlatformProductsDeleteRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsDelete(requestParameters.accountId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the WA catalog. Only available on WA Business apps. 
     * @summary Get the products from WA catalog.
     * @param {ProductApiPlatformProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsGet(requestParameters: ProductApiPlatformProductsGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsGet(requestParameters.accountId, requestParameters.q, requestParameters.category, requestParameters.id, requestParameters.cursor, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a product in the WA catalog
     * @param {ProductApiPlatformProductsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsPatch(requestParameters: ProductApiPlatformProductsPatchRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsPatch(requestParameters.accountId, requestParameters.id, requestParameters.platformProductUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a product to the WA catalog
     * @param {ProductApiPlatformProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsPost(requestParameters: ProductApiPlatformProductsPostRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsPost(requestParameters.accountId, requestParameters.platformProductCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger sync of the specified products on ChatDaddy with WhatsApp
     * @param {ProductApiPlatformProductsSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsSync(requestParameters: ProductApiPlatformProductsSyncRequest = {}, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsSync(requestParameters.id, requestParameters.syncForward, requestParameters.syncBackward, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsDelete', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_DELETE"], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {TagsPatchRequest} [tagsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPatch: async (name: string, tagsPatchRequest?: TagsPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsPatch', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_CREATE"], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagsPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost: async (name: string, tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsPost', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_CREATE"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsDelete(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsDelete(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all the tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {TagsPatchRequest} [tagsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPatch(name: string, tagsPatchRequest?: TagsPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPatch(name, tagsPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPost(name: string, tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPost(name, tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete(name: string, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.tagsDelete(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(options?: any): AxiosPromise<TagsGet200Response> {
            return localVarFp.tagsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {TagsPatchRequest} [tagsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPatch(name: string, tagsPatchRequest?: TagsPatchRequest, options?: any): AxiosPromise<Tag> {
            return localVarFp.tagsPatch(name, tagsPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {Array<string>} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {Array<string>} [contacts] Get these specific contact ids
         * @param {Array<string>} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search string for contact name/phone number/email
         * @param {Array<string>} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {'group' | 'individual'} [type] only get contacts of type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost(name: string, tags?: Array<string>, notTags?: Array<string>, contacts?: Array<string>, notContacts?: Array<string>, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: Array<string>, accountId?: Array<string>, type?: 'group' | 'individual', options?: any): AxiosPromise<Tag> {
            return localVarFp.tagsPost(name, tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, accountId, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tagsDelete operation in TagsApi.
 * @export
 * @interface TagsApiTagsDeleteRequest
 */
export interface TagsApiTagsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsDelete
     */
    readonly name: string
}

/**
 * Request parameters for tagsPatch operation in TagsApi.
 * @export
 * @interface TagsApiTagsPatchRequest
 */
export interface TagsApiTagsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsPatch
     */
    readonly name: string

    /**
     * 
     * @type {TagsPatchRequest}
     * @memberof TagsApiTagsPatch
     */
    readonly tagsPatchRequest?: TagsPatchRequest
}

/**
 * Request parameters for tagsPost operation in TagsApi.
 * @export
 * @interface TagsApiTagsPostRequest
 */
export interface TagsApiTagsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsPost
     */
    readonly name: string

    /**
     * Get contacts who fall in either of these tags
     * @type {Array<string>}
     * @memberof TagsApiTagsPost
     */
    readonly tags?: Array<string>

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof TagsApiTagsPost
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {Array<string>}
     * @memberof TagsApiTagsPost
     */
    readonly contacts?: Array<string>

    /**
     * Do not get these specific contacts
     * @type {Array<string>}
     * @memberof TagsApiTagsPost
     */
    readonly notContacts?: Array<string>

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof TagsApiTagsPost
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof TagsApiTagsPost
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof TagsApiTagsPost
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof TagsApiTagsPost
     */
    readonly maxMessagesRecv?: number

    /**
     * Search string for contact name/phone number/email
     * @type {string}
     * @memberof TagsApiTagsPost
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof TagsApiTagsPost
     */
    readonly assignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof TagsApiTagsPost
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {'group' | 'individual'}
     * @memberof TagsApiTagsPost
     */
    readonly type?: 'group' | 'individual'
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a tag
     * @param {TagsApiTagsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsDelete(requestParameters: TagsApiTagsDeleteRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsDelete(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGet(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TagsApiTagsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPatch(requestParameters: TagsApiTagsPatchRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsPatch(requestParameters.name, requestParameters.tagsPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a tag
     * @param {TagsApiTagsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPost(requestParameters: TagsApiTagsPostRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsPost(requestParameters.name, requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.accountId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Submit a template for review
         * @param {string} accountId 
         * @param {TemplatesSubmitForReviewRequest} [templatesSubmitForReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesSubmitForReview: async (accountId: string, templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('templatesSubmitForReview', 'accountId', accountId)
            const localVarPath = `/templates/{accountId}/submit-for-review`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesSubmitForReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Submit a template for review
         * @param {string} accountId 
         * @param {TemplatesSubmitForReviewRequest} [templatesSubmitForReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesSubmitForReview(accountId: string, templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesSubmitForReview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesSubmitForReview(accountId, templatesSubmitForReviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Submit a template for review
         * @param {string} accountId 
         * @param {TemplatesSubmitForReviewRequest} [templatesSubmitForReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesSubmitForReview(accountId: string, templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest, options?: any): AxiosPromise<TemplatesSubmitForReview200Response> {
            return localVarFp.templatesSubmitForReview(accountId, templatesSubmitForReviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for templatesSubmitForReview operation in TemplatesApi.
 * @export
 * @interface TemplatesApiTemplatesSubmitForReviewRequest
 */
export interface TemplatesApiTemplatesSubmitForReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof TemplatesApiTemplatesSubmitForReview
     */
    readonly accountId: string

    /**
     * 
     * @type {TemplatesSubmitForReviewRequest}
     * @memberof TemplatesApiTemplatesSubmitForReview
     */
    readonly templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest
}

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Submit a template for review
     * @param {TemplatesApiTemplatesSubmitForReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesSubmitForReview(requestParameters: TemplatesApiTemplatesSubmitForReviewRequest, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesSubmitForReview(requestParameters.accountId, requestParameters.templatesSubmitForReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Receive a message from Alibaba CAMS API
         * @param {string} accountId 
         * @param {string} secret 
         * @param {Array<AlibabaCAMSWebhookItem>} [alibabaCAMSWebhookItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookAlibabaCamsPost: async (accountId: string, secret: string, alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('webhookAlibabaCamsPost', 'accountId', accountId)
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('webhookAlibabaCamsPost', 'secret', secret)
            const localVarPath = `/webhook/{accountId}/{secret}/alibaba-cams`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCAMSWebhookItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Receive a message from Alibaba CAMS API
         * @param {string} accountId 
         * @param {string} secret 
         * @param {Array<AlibabaCAMSWebhookItem>} [alibabaCAMSWebhookItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookAlibabaCamsPost(accountId: string, secret: string, alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookAlibabaCamsPost(accountId, secret, alibabaCAMSWebhookItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @summary Receive a message from Alibaba CAMS API
         * @param {string} accountId 
         * @param {string} secret 
         * @param {Array<AlibabaCAMSWebhookItem>} [alibabaCAMSWebhookItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookAlibabaCamsPost(accountId: string, secret: string, alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>, options?: any): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.webhookAlibabaCamsPost(accountId, secret, alibabaCAMSWebhookItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for webhookAlibabaCamsPost operation in WebhookApi.
 * @export
 * @interface WebhookApiWebhookAlibabaCamsPostRequest
 */
export interface WebhookApiWebhookAlibabaCamsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhookApiWebhookAlibabaCamsPost
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof WebhookApiWebhookAlibabaCamsPost
     */
    readonly secret: string

    /**
     * 
     * @type {Array<AlibabaCAMSWebhookItem>}
     * @memberof WebhookApiWebhookAlibabaCamsPost
     */
    readonly alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>
}

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @summary Receive a message from Alibaba CAMS API
     * @param {WebhookApiWebhookAlibabaCamsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookAlibabaCamsPost(requestParameters: WebhookApiWebhookAlibabaCamsPostRequest, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookAlibabaCamsPost(requestParameters.accountId, requestParameters.secret, requestParameters.alibabaCAMSWebhookItem, options).then((request) => request(this.axios, this.basePath));
    }
}


