const BASE_PATH = "https://25u5hq78w6.execute-api.ap-east-1.amazonaws.com/v1".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Payments Service
 * Manage all payment/subscription related operations
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {Array<Feature>}
     * @memberof Access
     */
    'features': Array<Feature>;
    /**
     * 
     * @type {LimitationMap}
     * @memberof Access
     */
    'limits': LimitationMap;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Access
     */
    'lastExpiryOrRenewalDate'?: string;
}
/**
 * 
 * @export
 * @interface AccountAccess
 */
export interface AccountAccess {
    /**
     * 
     * @type {Array<AccountFeature>}
     * @memberof AccountAccess
     */
    'features': Array<AccountFeature>;
    /**
     * 
     * @type {AccountLimitationMap}
     * @memberof AccountAccess
     */
    'limits': AccountLimitationMap;
}
/**
 * 
 * @export
 * @interface AccountAccessDetail
 */
export interface AccountAccessDetail {
    /**
     * 
     * @type {AccountAccess}
     * @memberof AccountAccessDetail
     */
    'access': AccountAccess;
    /**
     * 
     * @type {LimitationMap}
     * @memberof AccountAccessDetail
     */
    'usage': LimitationMap;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountFeature = {
    TeamInbox: 'team-inbox',
    CustomMarketingMessage: 'custom-marketing-message',
    ChatHistorySync: 'chat-history-sync'
} as const;

export type AccountFeature = typeof AccountFeature[keyof typeof AccountFeature];


/**
 * 
 * @export
 * @interface AccountLimitationMap
 */
export interface AccountLimitationMap {
    /**
     * The number of messages that can be sent per month.
     * @type {number}
     * @memberof AccountLimitationMap
     */
    'messages'?: number;
}
/**
 * 
 * @export
 * @interface AmountWithCurrency
 */
export interface AmountWithCurrency {
    /**
     * The amount in cents. So 100 is $1.00
     * @type {number}
     * @memberof AmountWithCurrency
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof AmountWithCurrency
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface AutoChargeProduct
 */
export interface AutoChargeProduct {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProduct
     */
    'item': LimitedItem;
    /**
     * 
     * @type {string}
     * @memberof AutoChargeProduct
     */
    'stripePriceId': string;
}
/**
 * 
 * @export
 * @interface AutoChargeProductSet
 */
export interface AutoChargeProductSet {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProductSet
     */
    'item': LimitedItem;
    /**
     * If null, auto charge for this item is disabled. Otherwise, this is the stripe price ID to charge for this item.
     * @type {string}
     * @memberof AutoChargeProductSet
     */
    'stripePriceId': string | null;
}
/**
 * 
 * @export
 * @interface AutoChargeProductsGet200Response
 */
export interface AutoChargeProductsGet200Response {
    /**
     * 
     * @type {Array<AutoChargeProduct>}
     * @memberof AutoChargeProductsGet200Response
     */
    'items': Array<AutoChargeProduct>;
}
/**
 * 
 * @export
 * @interface AutoChargeProductsPrepare200Response
 */
export interface AutoChargeProductsPrepare200Response {
    /**
     * 
     * @type {Access}
     * @memberof AutoChargeProductsPrepare200Response
     */
    'access': Access;
    /**
     * 
     * @type {LimitationMap}
     * @memberof AutoChargeProductsPrepare200Response
     */
    'usage': LimitationMap;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BillingPeriod = {
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;

export type BillingPeriod = typeof BillingPeriod[keyof typeof BillingPeriod];


/**
 * 
 * @export
 * @interface BillingSessionPost200Response
 */
export interface BillingSessionPost200Response {
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CheckoutCreateOptions
 */
export interface CheckoutCreateOptions {
    /**
     * 
     * @type {CheckoutCreateOptionsCallbackUrls}
     * @memberof CheckoutCreateOptions
     */
    'callbackUrls': CheckoutCreateOptionsCallbackUrls;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptions
     */
    'coupon'?: string;
    /**
     * 
     * @type {Array<ProductsSelectionInner>}
     * @memberof CheckoutCreateOptions
     */
    'products': Array<ProductsSelectionInner>;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CheckoutCreateOptions
     */
    'extraDays'?: number;
}
/**
 * 
 * @export
 * @interface CheckoutCreateOptionsCallbackUrls
 */
export interface CheckoutCreateOptionsCallbackUrls {
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptionsCallbackUrls
     */
    'success': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptionsCallbackUrls
     */
    'failure': string;
}
/**
 * 
 * @export
 * @interface CouponCodeCreateOptions
 */
export interface CouponCodeCreateOptions {
    /**
     * 
     * @type {string}
     * @memberof CouponCodeCreateOptions
     */
    'category': string;
    /**
     * limit coupon code to products
     * @type {Array<string>}
     * @memberof CouponCodeCreateOptions
     */
    'products'?: Array<string>;
    /**
     * set free trial. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'freeTrialDays'?: number;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'discountPercentageOff': number;
}
/**
 * 
 * @export
 * @interface CouponsPost200Response
 */
export interface CouponsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof CouponsPost200Response
     */
    'code': string;
}
/**
 * List of features
 * @export
 * @enum {string}
 */

export const Feature = {
    TeamInbox: 'team-inbox',
    ChatHistorySync: 'chat-history-sync',
    CustomMarketingMessage: 'custom-marketing-message',
    Audience: 'audience',
    Notifications: 'notifications',
    KeywordReply: 'keyword-reply',
    Broadcast: 'broadcast',
    MessageFlows: 'message-flows',
    Shop: 'shop',
    Autocomplete: 'autocomplete'
} as const;

export type Feature = typeof Feature[keyof typeof Feature];


/**
 * @type FeatureConfig
 * @export
 */
export type FeatureConfig = Array<Feature> | FeatureConfigOneOf;

/**
 * Give access to all features, present & future
 * @export
 * @enum {string}
 */

export const FeatureConfigOneOf = {
    All: 'all'
} as const;

export type FeatureConfigOneOf = typeof FeatureConfigOneOf[keyof typeof FeatureConfigOneOf];


/**
 * 
 * @export
 * @interface GetPartner200Response
 */
export interface GetPartner200Response {
    /**
     * 
     * @type {string}
     * @memberof GetPartner200Response
     */
    'partnerAdmin'?: string;
}
/**
 * 
 * @export
 * @interface LimitationMap
 */
export interface LimitationMap {
    /**
     * The number of messages that can be sent per month. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'messages'?: number;
    /**
     * The number of team members allowed in the team. This usage carries over to the next month.
     * @type {number}
     * @memberof LimitationMap
     */
    'seats'?: number;
    /**
     * The number of Inbox accounts allowed in the team. This usage carries over to the next month.
     * @type {number}
     * @memberof LimitationMap
     */
    'fullAccount'?: number;
    /**
     * The number of API accounts used on a per-day basis. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'limitedMsgNoHistoryAccountDay'?: number;
    /**
     * The number of API accounts used on a per-day basis. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'unlimitedMsgHistoryAccountDay'?: number;
}
/**
 * List of items that are limited in quantity
 * @export
 * @enum {string}
 */

export const LimitedItem = {
    Messages: 'messages',
    Seats: 'seats',
    FullAccount: 'fullAccount',
    LimitedMsgNoHistoryAccountDay: 'limitedMsgNoHistoryAccountDay',
    UnlimitedMsgHistoryAccountDay: 'unlimitedMsgHistoryAccountDay'
} as const;

export type LimitedItem = typeof LimitedItem[keyof typeof LimitedItem];


/**
 * Object which stores referral code details
 * @export
 * @interface PartnerReferral
 */
export interface PartnerReferral {
    /**
     * referralCode string; ID for the code
     * @type {string}
     * @memberof PartnerReferral
     */
    'referralCode': string;
    /**
     * ID of the stripe price, the usage of this referral code will give access to
     * @type {string}
     * @memberof PartnerReferral
     */
    'stripePriceId': string | null;
    /**
     * 
     * @type {StripePrice}
     * @memberof PartnerReferral
     */
    'stripePrice'?: StripePrice;
    /**
     * teamId of partnerAdmin associated with the referralCode
     * @type {string}
     * @memberof PartnerReferral
     */
    'partnerAdminTeam': string;
    /**
     * partnerAdmin of team associated with the referralCode
     * @type {string}
     * @memberof PartnerReferral
     */
    'partnerAdmin': string;
    /**
     * Time the product can be used for in days
     * @type {number}
     * @memberof PartnerReferral
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferral
     */
    'referralCodeExpiry'?: string;
    /**
     * userId of creator of the code
     * @type {string}
     * @memberof PartnerReferral
     */
    'createdBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferral
     */
    'createdAt': string;
}
/**
 * options to generate partnerReferral
 * @export
 * @interface PartnerReferralCreateOptions
 */
export interface PartnerReferralCreateOptions {
    /**
     * ID of the product that\'ll be given for free when the referral code is used
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'stripePriceId': string | null;
    /**
     * time the product can be used for in days
     * @type {number}
     * @memberof PartnerReferralCreateOptions
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'referralCodeExpiry'?: string;
    /**
     * a string to be appended to the generated referral code
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'includeInReferralCode'?: string;
}
/**
 * 
 * @export
 * @interface PartnerReferralsGet200Response
 */
export interface PartnerReferralsGet200Response {
    /**
     * 
     * @type {Array<PartnerReferral>}
     * @memberof PartnerReferralsGet200Response
     */
    'items': Array<PartnerReferral>;
    /**
     * 
     * @type {number}
     * @memberof PartnerReferralsGet200Response
     */
    'nextPageCursor'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartnerReferralsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface PartnerReferralsPost200Response
 */
export interface PartnerReferralsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof PartnerReferralsPost200Response
     */
    'referralCode': string;
}
/**
 * 
 * @export
 * @interface PaymentData
 */
export interface PaymentData {
    /**
     * 
     * @type {string}
     * @memberof PaymentData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentData
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {AmountWithCurrency}
     * @memberof PaymentData
     */
    'amount': AmountWithCurrency;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentData
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * The ID of a product
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {ProductAccess}
     * @memberof Product
     */
    'access': ProductAccess;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Product
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Product
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<StripePrice>}
     * @memberof Product
     */
    'stripePrices'?: Array<StripePrice>;
}
/**
 * 
 * @export
 * @interface ProductAccess
 */
export interface ProductAccess {
    /**
     * 
     * @type {FeatureConfig}
     * @memberof ProductAccess
     */
    'features': FeatureConfig;
    /**
     * 
     * @type {LimitationMap}
     * @memberof ProductAccess
     */
    'limits': LimitationMap;
}
/**
 * 
 * @export
 * @interface ProductCreate
 */
export interface ProductCreate {
    /**
     * 
     * @type {string}
     * @memberof ProductCreate
     */
    'name': string;
    /**
     * 
     * @type {ProductAccess}
     * @memberof ProductCreate
     */
    'access': ProductAccess;
}
/**
 * 
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
    /**
     * 
     * @type {ProductAccess}
     * @memberof ProductUpdate
     */
    'access'?: ProductAccess;
    /**
     * Attach/detach some stripe price IDs
     * @type {Array<StripePriceAttachmentUpdate>}
     * @memberof ProductUpdate
     */
    'stripePriceIds'?: Array<StripePriceAttachmentUpdate>;
}
/**
 * 
 * @export
 * @interface ProductsGet200Response
 */
export interface ProductsGet200Response {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductsGet200Response
     */
    'items': Array<Product>;
}
/**
 * 
 * @export
 * @interface ProductsSelectionInner
 */
export interface ProductsSelectionInner {
    /**
     * The ID of a product
     * @type {string}
     * @memberof ProductsSelectionInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductsSelectionInner
     */
    'stripePriceId': string;
    /**
     * 
     * @type {number}
     * @memberof ProductsSelectionInner
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface StripeCheckout200Response
 */
export interface StripeCheckout200Response {
    /**
     * 
     * @type {string}
     * @memberof StripeCheckout200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof StripeCheckout200Response
     */
    'url': string;
}
/**
 * @type StripeCustomerCreate
 * @export
 */
export type StripeCustomerCreate = StripeCustomerCreateOneOf | StripeCustomerCreateOneOf1;

/**
 * Provide to link an existing stripe customer
 * @export
 * @interface StripeCustomerCreateOneOf
 */
export interface StripeCustomerCreateOneOf {
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf
     */
    'id': string;
}
/**
 * Provide to create a new stripe customer
 * @export
 * @interface StripeCustomerCreateOneOf1
 */
export interface StripeCustomerCreateOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface StripePrice
 */
export interface StripePrice {
    /**
     * 
     * @type {string}
     * @memberof StripePrice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StripePrice
     */
    'productName'?: string;
    /**
     * 
     * @type {BillingPeriod}
     * @memberof StripePrice
     */
    'period': BillingPeriod;
    /**
     * 
     * @type {AmountWithCurrency}
     * @memberof StripePrice
     */
    'amount': AmountWithCurrency;
    /**
     * ISO 3166-1 alpha-2 country code, or \"default\" to get the default prices
     * @type {string}
     * @memberof StripePrice
     */
    'region'?: string;
}
/**
 * Update a stripe price ID attachment. Supply ID to attach, or supply remove=true to detach. Supply region to mark price to a specific region.
 * @export
 * @interface StripePriceAttachmentUpdate
 */
export interface StripePriceAttachmentUpdate {
    /**
     * 
     * @type {string}
     * @memberof StripePriceAttachmentUpdate
     */
    'id': string;
    /**
     * ISO 3166-1 alpha-2 country code, or \"default\" to get the default prices
     * @type {string}
     * @memberof StripePriceAttachmentUpdate
     */
    'region'?: string;
    /**
     * Remove this stripe price ID from the product
     * @type {boolean}
     * @memberof StripePriceAttachmentUpdate
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface StripePricesGet200Response
 */
export interface StripePricesGet200Response {
    /**
     * 
     * @type {Array<StripePrice>}
     * @memberof StripePricesGet200Response
     */
    'items': Array<StripePrice>;
    /**
     * 
     * @type {string}
     * @memberof StripePricesGet200Response
     */
    'nextPageCursor'?: string;
}
/**
 * 
 * @export
 * @interface StripeSubscriptionItem
 */
export interface StripeSubscriptionItem {
    /**
     * 
     * @type {string}
     * @memberof StripeSubscriptionItem
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface SubscribedProduct
 */
export interface SubscribedProduct {
    /**
     * 
     * @type {Product}
     * @memberof SubscribedProduct
     */
    'product'?: Product;
    /**
     * 
     * @type {string}
     * @memberof SubscribedProduct
     */
    'productId': string;
    /**
     * The stripe price ID that was used to purchase this subscription product
     * @type {string}
     * @memberof SubscribedProduct
     */
    'stripePriceId': string;
    /**
     * 
     * @type {number}
     * @memberof SubscribedProduct
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * The ID of a subscription
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof Subscription
     */
    'teamId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Subscription
     */
    'startDate': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Subscription
     */
    'endDate'?: string;
    /**
     * Reason for voiding the subscription
     * @type {string}
     * @memberof Subscription
     */
    'voidReason'?: string;
    /**
     * 
     * @type {SubscriptionStripeData}
     * @memberof Subscription
     */
    'stripe'?: SubscriptionStripeData;
    /**
     * 
     * @type {Array<SubscribedProduct>}
     * @memberof Subscription
     */
    'products'?: Array<SubscribedProduct>;
    /**
     * 
     * @type {AutoChargeProduct}
     * @memberof Subscription
     */
    'autoCharge'?: AutoChargeProduct;
}
/**
 * 
 * @export
 * @interface SubscriptionCreate
 */
export interface SubscriptionCreate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'teamId': string;
    /**
     * 
     * @type {Array<ProductsSelectionInner>}
     * @memberof SubscriptionCreate
     */
    'products': Array<ProductsSelectionInner>;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'startDate'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'endDate'?: string;
    /**
     * Extra days to add to the subscription. Invalid request with endDate.
     * @type {number}
     * @memberof SubscriptionCreate
     */
    'extraDays'?: number;
    /**
     * Free trial days to add to the subscription. Invalid request with endDate, extraDays, or nextCycleAnchor, and createOnStripe=false.
     * @type {number}
     * @memberof SubscriptionCreate
     */
    'freeTrialDays'?: number;
    /**
     * Anchor the next cycle to a specific date. Invalid request with endDate. Only valid for stripe subscriptions.
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'nextCycleAnchor'?: string;
    /**
     * Create the subscription on stripe. Will create the subscription on stripe if true. Only works if the customer has a payment method and it can be charged automatically.
     * @type {boolean}
     * @memberof SubscriptionCreate
     */
    'createOnStripe': boolean;
    /**
     * Refresh access after creating the subscription.
     * @type {boolean}
     * @memberof SubscriptionCreate
     */
    'refreshAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface SubscriptionStripeData
 */
export interface SubscriptionStripeData {
    /**
     * The ID of a subscription
     * @type {string}
     * @memberof SubscriptionStripeData
     */
    'subscriptionId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof SubscriptionStripeData
     */
    'nextRenewalDate'?: string;
    /**
     * 
     * @type {Array<StripeSubscriptionItem>}
     * @memberof SubscriptionStripeData
     */
    'items': Array<StripeSubscriptionItem>;
    /**
     * 
     * @type {Array<PaymentData>}
     * @memberof SubscriptionStripeData
     */
    'payments': Array<PaymentData>;
}
/**
 * 
 * @export
 * @interface SubscriptionUpdate
 */
export interface SubscriptionUpdate {
    /**
     * Cancel the subscription. Will set the end date to the end of the current period. Features will continue to work until the end of the period.
     * @type {boolean}
     * @memberof SubscriptionUpdate
     */
    'cancel'?: boolean;
    /**
     * Reason for voiding the subscription. Will cancel the subscription if provided. Will set the end date to now.
     * @type {string}
     * @memberof SubscriptionUpdate
     */
    'voidReason'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionsGet200Response
 */
export interface SubscriptionsGet200Response {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof SubscriptionsGet200Response
     */
    'items': Array<Subscription>;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsGet200Response
     */
    'nextPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TeamDetail
 */
export interface TeamDetail {
    /**
     * The ID of a team
     * @type {string}
     * @memberof TeamDetail
     */
    'id': string;
    /**
     * 
     * @type {Access}
     * @memberof TeamDetail
     */
    'access': Access;
    /**
     * 
     * @type {LimitationMap}
     * @memberof TeamDetail
     */
    'usage': LimitationMap;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'updatedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'lastAccessComputedAt': string;
    /**
     * 
     * @type {Array<LimitedItem>}
     * @memberof TeamDetail
     */
    'autoChargeItems': Array<LimitedItem>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'stripeCustomerId'?: string;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof TeamDetail
     */
    'subscriptions'?: Array<Subscription>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'partnership'?: string;
}
/**
 * 
 * @export
 * @interface TeamDetailCreate
 */
export interface TeamDetailCreate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'id': string;
    /**
     * 
     * @type {Set<LimitedItem>}
     * @memberof TeamDetailCreate
     */
    'autoChargeItems'?: Set<LimitedItem>;
    /**
     * 
     * @type {StripeCustomerCreate}
     * @memberof TeamDetailCreate
     */
    'stripeCustomer': StripeCustomerCreate;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'partnership'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @interface TeamDetailUpdate
 */
export interface TeamDetailUpdate {
    /**
     * 
     * @type {Set<LimitedItem>}
     * @memberof TeamDetailUpdate
     */
    'autoChargeItems'?: Set<LimitedItem>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailUpdate
     */
    'stripeCustomerId'?: string;
    /**
     * 
     * @type {LimitationMap}
     * @memberof TeamDetailUpdate
     */
    'usage'?: LimitationMap;
}

/**
 * AutoChargeProductsApi - axios parameter creator
 * @export
 */
export const AutoChargeProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch All Auto Charge Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auto-charge-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {LimitedItem} item 
         * @param {string} [accountId] The account ID to prepare usage for. Relevant for messages only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsPrepare: async (item: LimitedItem, accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('autoChargeProductsPrepare', 'item', item)
            const localVarPath = `/auto-charge-products/prepare/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets config for auto charge product
         * @param {AutoChargeProductSet} [autoChargeProductSet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsSet: async (autoChargeProductSet?: AutoChargeProductSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auto-charge-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoChargeProductSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoChargeProductsApi - functional programming interface
 * @export
 */
export const AutoChargeProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutoChargeProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch All Auto Charge Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoChargeProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {LimitedItem} item 
         * @param {string} [accountId] The account ID to prepare usage for. Relevant for messages only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsPrepare(item: LimitedItem, accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoChargeProductsPrepare200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsPrepare(item, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets config for auto charge product
         * @param {AutoChargeProductSet} [autoChargeProductSet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsSet(autoChargeProductSet?: AutoChargeProductSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsSet(autoChargeProductSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutoChargeProductsApi - factory interface
 * @export
 */
export const AutoChargeProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutoChargeProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch All Auto Charge Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsGet(options?: any): AxiosPromise<AutoChargeProductsGet200Response> {
            return localVarFp.autoChargeProductsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {LimitedItem} item 
         * @param {string} [accountId] The account ID to prepare usage for. Relevant for messages only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsPrepare(item: LimitedItem, accountId?: string, options?: any): AxiosPromise<AutoChargeProductsPrepare200Response> {
            return localVarFp.autoChargeProductsPrepare(item, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets config for auto charge product
         * @param {AutoChargeProductSet} [autoChargeProductSet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsSet(autoChargeProductSet?: AutoChargeProductSet, options?: any): AxiosPromise<void> {
            return localVarFp.autoChargeProductsSet(autoChargeProductSet, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autoChargeProductsPrepare operation in AutoChargeProductsApi.
 * @export
 * @interface AutoChargeProductsApiAutoChargeProductsPrepareRequest
 */
export interface AutoChargeProductsApiAutoChargeProductsPrepareRequest {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProductsApiAutoChargeProductsPrepare
     */
    readonly item: LimitedItem

    /**
     * The account ID to prepare usage for. Relevant for messages only.
     * @type {string}
     * @memberof AutoChargeProductsApiAutoChargeProductsPrepare
     */
    readonly accountId?: string
}

/**
 * Request parameters for autoChargeProductsSet operation in AutoChargeProductsApi.
 * @export
 * @interface AutoChargeProductsApiAutoChargeProductsSetRequest
 */
export interface AutoChargeProductsApiAutoChargeProductsSetRequest {
    /**
     * 
     * @type {AutoChargeProductSet}
     * @memberof AutoChargeProductsApiAutoChargeProductsSet
     */
    readonly autoChargeProductSet?: AutoChargeProductSet
}

/**
 * AutoChargeProductsApi - object-oriented interface
 * @export
 * @class AutoChargeProductsApi
 * @extends {BaseAPI}
 */
export class AutoChargeProductsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch All Auto Charge Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsGet(options?: AxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
     * @summary Prepares the team for auto charge
     * @param {AutoChargeProductsApiAutoChargeProductsPrepareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsPrepare(requestParameters: AutoChargeProductsApiAutoChargeProductsPrepareRequest, options?: AxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsPrepare(requestParameters.item, requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets config for auto charge product
     * @param {AutoChargeProductsApiAutoChargeProductsSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsSet(requestParameters: AutoChargeProductsApiAutoChargeProductsSetRequest = {}, options?: AxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsSet(requestParameters.autoChargeProductSet, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CouponCodesApi - axios parameter creator
 * @export
 */
export const CouponCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost: async (couponCodeCreateOptions?: CouponCodeCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponCodeCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponCodesApi - functional programming interface
 * @export
 */
export const CouponCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsPost(couponCodeCreateOptions?: CouponCodeCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsPost(couponCodeCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CouponCodesApi - factory interface
 * @export
 */
export const CouponCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponCodesApiFp(configuration)
    return {
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost(couponCodeCreateOptions?: CouponCodeCreateOptions, options?: any): AxiosPromise<CouponsPost200Response> {
            return localVarFp.couponsPost(couponCodeCreateOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for couponsPost operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCouponsPostRequest
 */
export interface CouponCodesApiCouponsPostRequest {
    /**
     * 
     * @type {CouponCodeCreateOptions}
     * @memberof CouponCodesApiCouponsPost
     */
    readonly couponCodeCreateOptions?: CouponCodeCreateOptions
}

/**
 * CouponCodesApi - object-oriented interface
 * @export
 * @class CouponCodesApi
 * @extends {BaseAPI}
 */
export class CouponCodesApi extends BaseAPI {
    /**
     * Generate a coupon code
     * @param {CouponCodesApiCouponsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public couponsPost(requestParameters: CouponCodesApiCouponsPostRequest = {}, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).couponsPost(requestParameters.couponCodeCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {string} [region] The region to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (region?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch: async (id: string, productUpdate?: ProductUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsPatch', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductCreate} [productCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost: async (productCreate?: ProductCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {string} [region] The region to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(region?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPatch(id: string, productUpdate?: ProductUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPatch(id, productUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductCreate} [productCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPost(productCreate?: ProductCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPost(productCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {string} [region] The region to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(region?: string, options?: any): AxiosPromise<ProductsGet200Response> {
            return localVarFp.productsGet(region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch(id: string, productUpdate?: ProductUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.productsPatch(id, productUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductCreate} [productCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost(productCreate?: ProductCreate, options?: any): AxiosPromise<Product> {
            return localVarFp.productsPost(productCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsGet operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsGetRequest
 */
export interface ProductsApiProductsGetRequest {
    /**
     * The region to filter by
     * @type {string}
     * @memberof ProductsApiProductsGet
     */
    readonly region?: string
}

/**
 * Request parameters for productsPatch operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsPatchRequest
 */
export interface ProductsApiProductsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPatch
     */
    readonly id: string

    /**
     * 
     * @type {ProductUpdate}
     * @memberof ProductsApiProductsPatch
     */
    readonly productUpdate?: ProductUpdate
}

/**
 * Request parameters for productsPost operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsPostRequest
 */
export interface ProductsApiProductsPostRequest {
    /**
     * 
     * @type {ProductCreate}
     * @memberof ProductsApiProductsPost
     */
    readonly productCreate?: ProductCreate
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch All Available Products
     * @param {ProductsApiProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGet(requestParameters: ProductsApiProductsGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGet(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a product\'s properties
     * @param {ProductsApiProductsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPatch(requestParameters: ProductsApiProductsPatchRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPatch(requestParameters.id, requestParameters.productUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new product
     * @param {ProductsApiProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPost(requestParameters: ProductsApiProductsPostRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPost(requestParameters.productCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferralsApi - axios parameter creator
 * @export
 */
export const ReferralsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner: async (referralCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('getPartner', 'referralCode', referralCode)
            const localVarPath = `/partner-referral/get-partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsDelete: async (referralCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('partnerReferralsDelete', 'referralCode', referralCode)
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {boolean} [returnTotal] Include the total number of referralCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsGet: async (page?: number, count?: number, id?: Array<string>, q?: string, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsPost: async (partnerReferralCreateOptions?: PartnerReferralCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerReferralCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralsApi - functional programming interface
 * @export
 */
export const ReferralsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartner(referralCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPartner200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartner(referralCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsDelete(referralCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsDelete(referralCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {boolean} [returnTotal] Include the total number of referralCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsGet(page?: number, count?: number, id?: Array<string>, q?: string, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerReferralsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsGet(page, count, id, q, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsPost(partnerReferralCreateOptions?: PartnerReferralCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerReferralsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsPost(partnerReferralCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferralsApi - factory interface
 * @export
 */
export const ReferralsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner(referralCode: string, options?: any): AxiosPromise<GetPartner200Response> {
            return localVarFp.getPartner(referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsDelete(referralCode: string, options?: any): AxiosPromise<void> {
            return localVarFp.partnerReferralsDelete(referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {boolean} [returnTotal] Include the total number of referralCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsGet(page?: number, count?: number, id?: Array<string>, q?: string, returnTotal?: boolean, options?: any): AxiosPromise<PartnerReferralsGet200Response> {
            return localVarFp.partnerReferralsGet(page, count, id, q, returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsPost(partnerReferralCreateOptions?: PartnerReferralCreateOptions, options?: any): AxiosPromise<PartnerReferralsPost200Response> {
            return localVarFp.partnerReferralsPost(partnerReferralCreateOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPartner operation in ReferralsApi.
 * @export
 * @interface ReferralsApiGetPartnerRequest
 */
export interface ReferralsApiGetPartnerRequest {
    /**
     * 
     * @type {string}
     * @memberof ReferralsApiGetPartner
     */
    readonly referralCode: string
}

/**
 * Request parameters for partnerReferralsDelete operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsDeleteRequest
 */
export interface ReferralsApiPartnerReferralsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ReferralsApiPartnerReferralsDelete
     */
    readonly referralCode: string
}

/**
 * Request parameters for partnerReferralsGet operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsGetRequest
 */
export interface ReferralsApiPartnerReferralsGetRequest {
    /**
     * The page for the cursor
     * @type {number}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly page?: number

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly count?: number

    /**
     * The array of referralCodes to be fetched
     * @type {Array<string>}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly id?: Array<string>

    /**
     * Search by id, productId, etc
     * @type {string}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly q?: string

    /**
     * Include the total number of referralCodes
     * @type {boolean}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for partnerReferralsPost operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsPostRequest
 */
export interface ReferralsApiPartnerReferralsPostRequest {
    /**
     * 
     * @type {PartnerReferralCreateOptions}
     * @memberof ReferralsApiPartnerReferralsPost
     */
    readonly partnerReferralCreateOptions?: PartnerReferralCreateOptions
}

/**
 * ReferralsApi - object-oriented interface
 * @export
 * @class ReferralsApi
 * @extends {BaseAPI}
 */
export class ReferralsApi extends BaseAPI {
    /**
     * 
     * @param {ReferralsApiGetPartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public getPartner(requestParameters: ReferralsApiGetPartnerRequest, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).getPartner(requestParameters.referralCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsDelete(requestParameters: ReferralsApiPartnerReferralsDeleteRequest, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsDelete(requestParameters.referralCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsGet(requestParameters: ReferralsApiPartnerReferralsGetRequest = {}, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsGet(requestParameters.page, requestParameters.count, requestParameters.id, requestParameters.q, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsPost(requestParameters: ReferralsApiPartnerReferralsPostRequest = {}, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsPost(requestParameters.partnerReferralCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost: async (returnUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'returnUrl' is not null or undefined
            assertParamExists('billingSessionPost', 'returnUrl', returnUrl)
            const localVarPath = `/billing-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {CheckoutCreateOptions} [checkoutCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckout: async (checkoutCreateOptions?: CheckoutCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/checkout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {string} secret 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook: async (secret: string, requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('stripeHook', 'secret', secret)
            const localVarPath = `/stripe/webhook/{secret}`
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use results from here to attach prices to products.
         * @summary Get prices from Stripe
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {string} [q] Filter by stripe query. See https://stripe.com/docs/search#search-query-language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripePricesGet: async (count?: number, cursor?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingSessionPost(returnUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSessionPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingSessionPost(returnUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {CheckoutCreateOptions} [checkoutCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeCheckout(checkoutCreateOptions?: CheckoutCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeCheckout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeCheckout(checkoutCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {string} secret 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeHook(secret: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeHook(secret, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use results from here to attach prices to products.
         * @summary Get prices from Stripe
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {string} [q] Filter by stripe query. See https://stripe.com/docs/search#search-query-language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripePricesGet(count?: number, cursor?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePricesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripePricesGet(count, cursor, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost(returnUrl: string, options?: any): AxiosPromise<BillingSessionPost200Response> {
            return localVarFp.billingSessionPost(returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {CheckoutCreateOptions} [checkoutCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckout(checkoutCreateOptions?: CheckoutCreateOptions, options?: any): AxiosPromise<StripeCheckout200Response> {
            return localVarFp.stripeCheckout(checkoutCreateOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {string} secret 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook(secret: string, requestBody?: { [key: string]: any; }, options?: any): AxiosPromise<void> {
            return localVarFp.stripeHook(secret, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use results from here to attach prices to products.
         * @summary Get prices from Stripe
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {string} [q] Filter by stripe query. See https://stripe.com/docs/search#search-query-language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripePricesGet(count?: number, cursor?: string, q?: string, options?: any): AxiosPromise<StripePricesGet200Response> {
            return localVarFp.stripePricesGet(count, cursor, q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for billingSessionPost operation in StripeApi.
 * @export
 * @interface StripeApiBillingSessionPostRequest
 */
export interface StripeApiBillingSessionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiBillingSessionPost
     */
    readonly returnUrl: string
}

/**
 * Request parameters for stripeCheckout operation in StripeApi.
 * @export
 * @interface StripeApiStripeCheckoutRequest
 */
export interface StripeApiStripeCheckoutRequest {
    /**
     * 
     * @type {CheckoutCreateOptions}
     * @memberof StripeApiStripeCheckout
     */
    readonly checkoutCreateOptions?: CheckoutCreateOptions
}

/**
 * Request parameters for stripeHook operation in StripeApi.
 * @export
 * @interface StripeApiStripeHookRequest
 */
export interface StripeApiStripeHookRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiStripeHook
     */
    readonly secret: string

    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof StripeApiStripeHook
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for stripePricesGet operation in StripeApi.
 * @export
 * @interface StripeApiStripePricesGetRequest
 */
export interface StripeApiStripePricesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof StripeApiStripePricesGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof StripeApiStripePricesGet
     */
    readonly cursor?: string

    /**
     * Filter by stripe query. See https://stripe.com/docs/search#search-query-language
     * @type {string}
     * @memberof StripeApiStripePricesGet
     */
    readonly q?: string
}

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @summary Create a new billing portal session to manage payment details
     * @param {StripeApiBillingSessionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public billingSessionPost(requestParameters: StripeApiBillingSessionPostRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).billingSessionPost(requestParameters.returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a checkout session
     * @param {StripeApiStripeCheckoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeCheckout(requestParameters: StripeApiStripeCheckoutRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeCheckout(requestParameters.checkoutCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive stripe hook
     * @param {StripeApiStripeHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeHook(requestParameters: StripeApiStripeHookRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeHook(requestParameters.secret, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use results from here to attach prices to products.
     * @summary Get prices from Stripe
     * @param {StripeApiStripePricesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripePricesGet(requestParameters: StripeApiStripePricesGetRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripePricesGet(requestParameters.count, requestParameters.cursor, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {string} [q] Search by subscription ID, team ID or product name
         * @param {boolean} [includeFreeTier] Include free tier subscriptions
         * @param {'startDate' | 'endOrNextRenewalDate'} [sortBy] Sort by the given field
         * @param {'asc' | 'desc'} [sortDirection] Sort direction
         * @param {string} [endsOrRenewsAfter] Filter subscriptions that end or renew after the given date
         * @param {string} [endsOrRenewsBefore] Filter subscriptions that end or renew before the given date
         * @param {boolean} [stripeOnly] Filter subscriptions that are only in Stripe
         * @param {Array<string>} [product] Filter subscriptions by product
         * @param {boolean} [returnTotal] Return total number of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet: async (teamId?: string, count?: number, page?: number, q?: string, includeFreeTier?: boolean, sortBy?: 'startDate' | 'endOrNextRenewalDate', sortDirection?: 'asc' | 'desc', endsOrRenewsAfter?: string, endsOrRenewsBefore?: string, stripeOnly?: boolean, product?: Array<string>, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (includeFreeTier !== undefined) {
                localVarQueryParameter['includeFreeTier'] = includeFreeTier;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (endsOrRenewsAfter !== undefined) {
                localVarQueryParameter['endsOrRenewsAfter'] = (endsOrRenewsAfter as any instanceof Date) ?
                    (endsOrRenewsAfter as any).toISOString() :
                    endsOrRenewsAfter;
            }

            if (endsOrRenewsBefore !== undefined) {
                localVarQueryParameter['endsOrRenewsBefore'] = (endsOrRenewsBefore as any instanceof Date) ?
                    (endsOrRenewsBefore as any).toISOString() :
                    endsOrRenewsBefore;
            }

            if (stripeOnly !== undefined) {
                localVarQueryParameter['stripeOnly'] = stripeOnly;
            }

            if (product) {
                localVarQueryParameter['product'] = product;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {string} id 
         * @param {SubscriptionUpdate} [subscriptionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch: async (id: string, subscriptionUpdate?: SubscriptionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subscriptionsPatch', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
         * @summary Manually create a subscription for the team
         * @param {SubscriptionCreate} [subscriptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPost: async (subscriptionCreate?: SubscriptionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {string} [q] Search by subscription ID, team ID or product name
         * @param {boolean} [includeFreeTier] Include free tier subscriptions
         * @param {'startDate' | 'endOrNextRenewalDate'} [sortBy] Sort by the given field
         * @param {'asc' | 'desc'} [sortDirection] Sort direction
         * @param {string} [endsOrRenewsAfter] Filter subscriptions that end or renew after the given date
         * @param {string} [endsOrRenewsBefore] Filter subscriptions that end or renew before the given date
         * @param {boolean} [stripeOnly] Filter subscriptions that are only in Stripe
         * @param {Array<string>} [product] Filter subscriptions by product
         * @param {boolean} [returnTotal] Return total number of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsGet(teamId?: string, count?: number, page?: number, q?: string, includeFreeTier?: boolean, sortBy?: 'startDate' | 'endOrNextRenewalDate', sortDirection?: 'asc' | 'desc', endsOrRenewsAfter?: string, endsOrRenewsBefore?: string, stripeOnly?: boolean, product?: Array<string>, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsGet(teamId, count, page, q, includeFreeTier, sortBy, sortDirection, endsOrRenewsAfter, endsOrRenewsBefore, stripeOnly, product, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {string} id 
         * @param {SubscriptionUpdate} [subscriptionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsPatch(id: string, subscriptionUpdate?: SubscriptionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsPatch(id, subscriptionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
         * @summary Manually create a subscription for the team
         * @param {SubscriptionCreate} [subscriptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsPost(subscriptionCreate?: SubscriptionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsPost(subscriptionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {string} [q] Search by subscription ID, team ID or product name
         * @param {boolean} [includeFreeTier] Include free tier subscriptions
         * @param {'startDate' | 'endOrNextRenewalDate'} [sortBy] Sort by the given field
         * @param {'asc' | 'desc'} [sortDirection] Sort direction
         * @param {string} [endsOrRenewsAfter] Filter subscriptions that end or renew after the given date
         * @param {string} [endsOrRenewsBefore] Filter subscriptions that end or renew before the given date
         * @param {boolean} [stripeOnly] Filter subscriptions that are only in Stripe
         * @param {Array<string>} [product] Filter subscriptions by product
         * @param {boolean} [returnTotal] Return total number of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet(teamId?: string, count?: number, page?: number, q?: string, includeFreeTier?: boolean, sortBy?: 'startDate' | 'endOrNextRenewalDate', sortDirection?: 'asc' | 'desc', endsOrRenewsAfter?: string, endsOrRenewsBefore?: string, stripeOnly?: boolean, product?: Array<string>, returnTotal?: boolean, options?: any): AxiosPromise<SubscriptionsGet200Response> {
            return localVarFp.subscriptionsGet(teamId, count, page, q, includeFreeTier, sortBy, sortDirection, endsOrRenewsAfter, endsOrRenewsBefore, stripeOnly, product, returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {string} id 
         * @param {SubscriptionUpdate} [subscriptionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch(id: string, subscriptionUpdate?: SubscriptionUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.subscriptionsPatch(id, subscriptionUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
         * @summary Manually create a subscription for the team
         * @param {SubscriptionCreate} [subscriptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPost(subscriptionCreate?: SubscriptionCreate, options?: any): AxiosPromise<Subscription> {
            return localVarFp.subscriptionsPost(subscriptionCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for subscriptionsGet operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsGetRequest
 */
export interface SubscriptionsApiSubscriptionsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly teamId?: string

    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly page?: number

    /**
     * Search by subscription ID, team ID or product name
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly q?: string

    /**
     * Include free tier subscriptions
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly includeFreeTier?: boolean

    /**
     * Sort by the given field
     * @type {'startDate' | 'endOrNextRenewalDate'}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly sortBy?: 'startDate' | 'endOrNextRenewalDate'

    /**
     * Sort direction
     * @type {'asc' | 'desc'}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly sortDirection?: 'asc' | 'desc'

    /**
     * Filter subscriptions that end or renew after the given date
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly endsOrRenewsAfter?: string

    /**
     * Filter subscriptions that end or renew before the given date
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly endsOrRenewsBefore?: string

    /**
     * Filter subscriptions that are only in Stripe
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly stripeOnly?: boolean

    /**
     * Filter subscriptions by product
     * @type {Array<string>}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly product?: Array<string>

    /**
     * Return total number of subscriptions
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for subscriptionsPatch operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsPatchRequest
 */
export interface SubscriptionsApiSubscriptionsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsPatch
     */
    readonly id: string

    /**
     * 
     * @type {SubscriptionUpdate}
     * @memberof SubscriptionsApiSubscriptionsPatch
     */
    readonly subscriptionUpdate?: SubscriptionUpdate
}

/**
 * Request parameters for subscriptionsPost operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsPostRequest
 */
export interface SubscriptionsApiSubscriptionsPostRequest {
    /**
     * 
     * @type {SubscriptionCreate}
     * @memberof SubscriptionsApiSubscriptionsPost
     */
    readonly subscriptionCreate?: SubscriptionCreate
}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Get the list of subscriptions
     * @param {SubscriptionsApiSubscriptionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsGet(requestParameters: SubscriptionsApiSubscriptionsGetRequest = {}, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsGet(requestParameters.teamId, requestParameters.count, requestParameters.page, requestParameters.q, requestParameters.includeFreeTier, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.endsOrRenewsAfter, requestParameters.endsOrRenewsBefore, requestParameters.stripeOnly, requestParameters.product, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a subscription\'s properties
     * @param {SubscriptionsApiSubscriptionsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsPatch(requestParameters: SubscriptionsApiSubscriptionsPatchRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsPatch(requestParameters.id, requestParameters.subscriptionUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
     * @summary Manually create a subscription for the team
     * @param {SubscriptionsApiSubscriptionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsPost(requestParameters: SubscriptionsApiSubscriptionsPostRequest = {}, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsPost(requestParameters.subscriptionCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamDetailApi - axios parameter creator
 * @export
 */
export const TeamDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailAccountAccessGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('teamDetailAccountAccessGet', 'accountId', accountId)
            const localVarPath = `/team-detail/account-access/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailUpdate} [teamDetailUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPatch: async (teamDetailUpdate?: TeamDetailUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamDetailUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initialise a team with the free tier
         * @param {TeamDetailCreate} [teamDetailCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPost: async (teamDetailCreate?: TeamDetailCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamDetailCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {boolean} [refreshUsage] Refreshes usage statistics as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailRefreshAccess: async (refreshUsage?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail/refresh-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (refreshUsage !== undefined) {
                localVarQueryParameter['refreshUsage'] = refreshUsage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamDetailApi - functional programming interface
 * @export
 */
export const TeamDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailAccountAccessGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAccessDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailAccountAccessGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailUpdate} [teamDetailUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailPatch(teamDetailUpdate?: TeamDetailUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailPatch(teamDetailUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Initialise a team with the free tier
         * @param {TeamDetailCreate} [teamDetailCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailPost(teamDetailCreate?: TeamDetailCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailPost(teamDetailCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {boolean} [refreshUsage] Refreshes usage statistics as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailRefreshAccess(refreshUsage?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailRefreshAccess(refreshUsage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamDetailApi - factory interface
 * @export
 */
export const TeamDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamDetailApiFp(configuration)
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailAccountAccessGet(accountId: string, options?: any): AxiosPromise<AccountAccessDetail> {
            return localVarFp.teamDetailAccountAccessGet(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailGet(options?: any): AxiosPromise<TeamDetail> {
            return localVarFp.teamDetailGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailUpdate} [teamDetailUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPatch(teamDetailUpdate?: TeamDetailUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.teamDetailPatch(teamDetailUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initialise a team with the free tier
         * @param {TeamDetailCreate} [teamDetailCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPost(teamDetailCreate?: TeamDetailCreate, options?: any): AxiosPromise<TeamDetail> {
            return localVarFp.teamDetailPost(teamDetailCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {boolean} [refreshUsage] Refreshes usage statistics as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailRefreshAccess(refreshUsage?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.teamDetailRefreshAccess(refreshUsage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for teamDetailAccountAccessGet operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailAccountAccessGetRequest
 */
export interface TeamDetailApiTeamDetailAccountAccessGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TeamDetailApiTeamDetailAccountAccessGet
     */
    readonly accountId: string
}

/**
 * Request parameters for teamDetailPatch operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailPatchRequest
 */
export interface TeamDetailApiTeamDetailPatchRequest {
    /**
     * 
     * @type {TeamDetailUpdate}
     * @memberof TeamDetailApiTeamDetailPatch
     */
    readonly teamDetailUpdate?: TeamDetailUpdate
}

/**
 * Request parameters for teamDetailPost operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailPostRequest
 */
export interface TeamDetailApiTeamDetailPostRequest {
    /**
     * 
     * @type {TeamDetailCreate}
     * @memberof TeamDetailApiTeamDetailPost
     */
    readonly teamDetailCreate?: TeamDetailCreate
}

/**
 * Request parameters for teamDetailRefreshAccess operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailRefreshAccessRequest
 */
export interface TeamDetailApiTeamDetailRefreshAccessRequest {
    /**
     * Refreshes usage statistics as well
     * @type {boolean}
     * @memberof TeamDetailApiTeamDetailRefreshAccess
     */
    readonly refreshUsage?: boolean
}

/**
 * TeamDetailApi - object-oriented interface
 * @export
 * @class TeamDetailApi
 * @extends {BaseAPI}
 */
export class TeamDetailApi extends BaseAPI {
    /**
     * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
     * @summary Get the access details for the given account
     * @param {TeamDetailApiTeamDetailAccountAccessGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailAccountAccessGet(requestParameters: TeamDetailApiTeamDetailAccountAccessGetRequest, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailAccountAccessGet(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the team\'s subscription and payment details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailGet(options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the team\'s subscription and payment details
     * @param {TeamDetailApiTeamDetailPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailPatch(requestParameters: TeamDetailApiTeamDetailPatchRequest = {}, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailPatch(requestParameters.teamDetailUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initialise a team with the free tier
     * @param {TeamDetailApiTeamDetailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailPost(requestParameters: TeamDetailApiTeamDetailPostRequest = {}, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailPost(requestParameters.teamDetailCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
     * @summary Refreshes the access given by subscriptions
     * @param {TeamDetailApiTeamDetailRefreshAccessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailRefreshAccess(requestParameters: TeamDetailApiTeamDetailRefreshAccessRequest = {}, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailRefreshAccess(requestParameters.refreshUsage, options).then((request) => request(this.axios, this.basePath));
    }
}


