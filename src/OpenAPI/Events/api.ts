const BASE_PATH = "https://api-events.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Events Service
 * Receive live events from ChatDaddy via a WebSocket or register a web hook 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @enum {string}
 */

export const EventName = {
    GroupParticipantsUpdate: 'group-participants-update',
    GroupUpdate: 'group-update',
    PresenceUpdate: 'presence-update',
    OrderInsert: 'order-insert',
    ActionExecute: 'action-execute',
    ContactInsert: 'contact-insert',
    ContactUpdate: 'contact-update',
    ContactDelete: 'contact-delete',
    ChatInsert: 'chat-insert',
    ChatUpdate: 'chat-update',
    ChatDelete: 'chat-delete',
    AccountInsert: 'account-insert',
    AccountUpdate: 'account-update',
    AccountDelete: 'account-delete',
    MessageInsert: 'message-insert',
    MessageUpdate: 'message-update',
    MessageDelete: 'message-delete',
    UserInsert: 'user-insert',
    UserUpdate: 'user-update',
    UserDelete: 'user-delete',
    TeamInsert: 'team-insert',
    TeamUpdate: 'team-update',
    TeamDelete: 'team-delete',
    TeammemberInsert: 'teammember-insert',
    TeammemberUpdate: 'teammember-update',
    TeammemberDelete: 'teammember-delete',
    PurchasedetailInsert: 'purchasedetail-insert',
    PurchasedetailUpdate: 'purchasedetail-update',
    PurchasedetailDelete: 'purchasedetail-delete',
    PlatformproductInsert: 'platformproduct-insert',
    PlatformproductUpdate: 'platformproduct-update',
    PlatformproductDelete: 'platformproduct-delete'
} as const;

export type EventName = typeof EventName[keyof typeof EventName];


/**
 * 
 * @export
 * @interface PostSubscription
 */
export interface PostSubscription {
    /**
     * whether the subscription is enabled
     * @type {boolean}
     * @memberof PostSubscription
     */
    'enabled': boolean;
    /**
     * the events to listen for
     * @type {Array<EventName>}
     * @memberof PostSubscription
     */
    'events'?: Array<EventName>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostSubscription
     */
    'accounts'?: Array<string>;
    /**
     * Optionally specify ajv schema object, if validation of data fails -- the subscription will not fire
     * @type {{ [key: string]: any; }}
     * @memberof PostSubscription
     */
    'schema'?: { [key: string]: any; } | null;
    /**
     * Web hook url to fire to
     * @type {string}
     * @memberof PostSubscription
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * ID of the subscription
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * Whether the subscription is enabled
     * @type {boolean}
     * @memberof Subscription
     */
    'enabled': boolean;
    /**
     * The owner id the connection
     * @type {string}
     * @memberof Subscription
     */
    'ownerId'?: string;
    /**
     * The User ID that created the subscription
     * @type {string}
     * @memberof Subscription
     */
    'userId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Subscription
     */
    'createdAt'?: string;
    /**
     * the events to subscribe to
     * @type {Array<EventName>}
     * @memberof Subscription
     */
    'events': Array<EventName>;
    /**
     * the IM accounts to receive events from
     * @type {Array<string>}
     * @memberof Subscription
     */
    'accounts'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Subscription
     */
    'schema'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'type': SubscriptionTypeEnum;
    /**
     * Web hook url to fire to
     * @type {string}
     * @memberof Subscription
     */
    'url'?: string;
}

export const SubscriptionTypeEnum = {
    Webhook: 'webhook',
    Websocket: 'websocket'
} as const;

export type SubscriptionTypeEnum = typeof SubscriptionTypeEnum[keyof typeof SubscriptionTypeEnum];

/**
 * 
 * @export
 * @interface SubscriptionsDelete200Response
 */
export interface SubscriptionsDelete200Response {
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionsDelete200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface SubscriptionsGet200Response
 */
export interface SubscriptionsGet200Response {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof SubscriptionsGet200Response
     */
    'subscriptions': Array<Subscription>;
}
/**
 * 
 * @export
 * @interface UpdateSubscription
 */
export interface UpdateSubscription {
    /**
     * whether the subscription is enabled
     * @type {boolean}
     * @memberof UpdateSubscription
     */
    'enabled'?: boolean;
    /**
     * the events to listen for
     * @type {Array<EventName>}
     * @memberof UpdateSubscription
     */
    'events'?: Array<EventName>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateSubscription
     */
    'accounts'?: Array<string>;
    /**
     * Optionally specify ajv schema object, if validation of data fails -- the subscription will not fire
     * @type {{ [key: string]: any; }}
     * @memberof UpdateSubscription
     */
    'schema'?: { [key: string]: any; } | null;
    /**
     * Web hook url to fire to
     * @type {string}
     * @memberof UpdateSubscription
     */
    'url'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a subscription
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subscriptionsDelete', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATDADDY_HOOK"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all current subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATDADDY_HOOK"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a subscription
         * @param {string} id 
         * @param {UpdateSubscription} [updateSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch: async (id: string, updateSubscription?: UpdateSubscription, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subscriptionsPatch', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATDADDY_HOOK"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a subscription
         * @param {PostSubscription} [postSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPost: async (postSubscription?: PostSubscription, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATDADDY_HOOK"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a subscription
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all current subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a subscription
         * @param {string} id 
         * @param {UpdateSubscription} [updateSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsPatch(id: string, updateSubscription?: UpdateSubscription, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsPatch(id, updateSubscription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a subscription
         * @param {PostSubscription} [postSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsPost(postSubscription?: PostSubscription, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsPost(postSubscription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a subscription
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsDelete(id: string, options?: any): AxiosPromise<SubscriptionsDelete200Response> {
            return localVarFp.subscriptionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all current subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet(options?: any): AxiosPromise<SubscriptionsGet200Response> {
            return localVarFp.subscriptionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a subscription
         * @param {string} id 
         * @param {UpdateSubscription} [updateSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch(id: string, updateSubscription?: UpdateSubscription, options?: any): AxiosPromise<Subscription> {
            return localVarFp.subscriptionsPatch(id, updateSubscription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a subscription
         * @param {PostSubscription} [postSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPost(postSubscription?: PostSubscription, options?: any): AxiosPromise<Subscription> {
            return localVarFp.subscriptionsPost(postSubscription, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for subscriptionsDelete operation in DefaultApi.
 * @export
 * @interface DefaultApiSubscriptionsDeleteRequest
 */
export interface DefaultApiSubscriptionsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubscriptionsDelete
     */
    readonly id: string
}

/**
 * Request parameters for subscriptionsPatch operation in DefaultApi.
 * @export
 * @interface DefaultApiSubscriptionsPatchRequest
 */
export interface DefaultApiSubscriptionsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubscriptionsPatch
     */
    readonly id: string

    /**
     * 
     * @type {UpdateSubscription}
     * @memberof DefaultApiSubscriptionsPatch
     */
    readonly updateSubscription?: UpdateSubscription
}

/**
 * Request parameters for subscriptionsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiSubscriptionsPostRequest
 */
export interface DefaultApiSubscriptionsPostRequest {
    /**
     * 
     * @type {PostSubscription}
     * @memberof DefaultApiSubscriptionsPost
     */
    readonly postSubscription?: PostSubscription
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Delete a subscription
     * @param {DefaultApiSubscriptionsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public subscriptionsDelete(requestParameters: DefaultApiSubscriptionsDeleteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).subscriptionsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all current subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public subscriptionsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).subscriptionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a subscription
     * @param {DefaultApiSubscriptionsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public subscriptionsPatch(requestParameters: DefaultApiSubscriptionsPatchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).subscriptionsPatch(requestParameters.id, requestParameters.updateSubscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a subscription
     * @param {DefaultApiSubscriptionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public subscriptionsPost(requestParameters: DefaultApiSubscriptionsPostRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).subscriptionsPost(requestParameters.postSubscription, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebSocketApi - axios parameter creator
 * @export
 */
export const WebSocketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: you need to fetch the WS from wss://live.chatdaddy.tech
         * @summary The WebSocket Route
         * @param {string} accessToken the JWT authorization token
         * @param {Array<EventName>} events Events to subscribe to
         * @param {Array<string>} [accounts] Set the IM accounts to receive events from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (accessToken: string, events: Array<EventName>, accounts?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('rootGet', 'accessToken', accessToken)
            // verify required parameter 'events' is not null or undefined
            assertParamExists('rootGet', 'events', events)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (accessToken !== undefined) {
                localVarQueryParameter['accessToken'] = accessToken;
            }

            if (events) {
                localVarQueryParameter['events'] = events;
            }

            if (accounts) {
                localVarQueryParameter['accounts'] = accounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebSocketApi - functional programming interface
 * @export
 */
export const WebSocketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebSocketApiAxiosParamCreator(configuration)
    return {
        /**
         * Note: you need to fetch the WS from wss://live.chatdaddy.tech
         * @summary The WebSocket Route
         * @param {string} accessToken the JWT authorization token
         * @param {Array<EventName>} events Events to subscribe to
         * @param {Array<string>} [accounts] Set the IM accounts to receive events from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(accessToken: string, events: Array<EventName>, accounts?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(accessToken, events, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebSocketApi - factory interface
 * @export
 */
export const WebSocketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebSocketApiFp(configuration)
    return {
        /**
         * Note: you need to fetch the WS from wss://live.chatdaddy.tech
         * @summary The WebSocket Route
         * @param {string} accessToken the JWT authorization token
         * @param {Array<EventName>} events Events to subscribe to
         * @param {Array<string>} [accounts] Set the IM accounts to receive events from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(accessToken: string, events: Array<EventName>, accounts?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.rootGet(accessToken, events, accounts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for rootGet operation in WebSocketApi.
 * @export
 * @interface WebSocketApiRootGetRequest
 */
export interface WebSocketApiRootGetRequest {
    /**
     * the JWT authorization token
     * @type {string}
     * @memberof WebSocketApiRootGet
     */
    readonly accessToken: string

    /**
     * Events to subscribe to
     * @type {Array<EventName>}
     * @memberof WebSocketApiRootGet
     */
    readonly events: Array<EventName>

    /**
     * Set the IM accounts to receive events from
     * @type {Array<string>}
     * @memberof WebSocketApiRootGet
     */
    readonly accounts?: Array<string>
}

/**
 * WebSocketApi - object-oriented interface
 * @export
 * @class WebSocketApi
 * @extends {BaseAPI}
 */
export class WebSocketApi extends BaseAPI {
    /**
     * Note: you need to fetch the WS from wss://live.chatdaddy.tech
     * @summary The WebSocket Route
     * @param {WebSocketApiRootGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebSocketApi
     */
    public rootGet(requestParameters: WebSocketApiRootGetRequest, options?: AxiosRequestConfig) {
        return WebSocketApiFp(this.configuration).rootGet(requestParameters.accessToken, requestParameters.events, requestParameters.accounts, options).then((request) => request(this.axios, this.basePath));
    }
}


