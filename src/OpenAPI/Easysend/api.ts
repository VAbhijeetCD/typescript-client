/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Easysend (Notifications) Service
 * Data Processing service to standardize & process data from individual parsers & services. ## Writing a service for ChatDaddy Easysend The job of a service is to parse and clean data from a given data source. If you are writing a parser for an e-commerce website -- your job is to simply extract the required parameters and send them to the EasySend service in the required format (more on the format later).  ## Incorporating the routes Easysend requires just the base url for each service. This can be  - http://abcd.com/api - http://xyz.com/ - etc. Appending to this base url, each service must incorporate the following routes in their app --  ### GET /easysend/schema \'This route is used by easysend to determine all the specifications of the service including:\'\' - the parameters the service can send - credentials required - an image - a description & name View the `ServiceModel` schema to know the exact specifications ### POST /easysend/{id} - This route is for registering a new tracking for a user.  - The `id` parameter is the ID of this tracking. - Service should keep the `id` parameter secret. - Body will be `application/json` encoded and have the following type: ``` ts     type Body = {         // the credentials the service required, specified by the aforementioned schema         credentials: { [_: string]: string }      } ``` - Service must check credentials & return a 400+ code if invalid - If the service returns a 200 code, it will be assumed that the tracking has been saved & validated successfully ### DELETE /easysend/{id} - This route is for deregistering the tracking specified by the `id` parameter in the path. ## Sending Events to Easysend - Easysend expects a JSON encoded body at `PATCH /event/{id}` where ID is the secret identifier of the tracking registered previously - This route is covered in this document along with the required schema [here](/#Events) 
 *
 * The version of the OpenAPI document: 2.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddServiceModel
 */
export interface AddServiceModel {
    /**
     * Name of the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'name': string;
    /**
     * A service that implements only the schema route
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'isEphemeral'?: boolean;
    /**
     * If true, then parameters wont be checked when editing a trigger
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'skipParameterValidation'?: boolean;
    /**
     * any image/link representing the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'imgUrl': string;
    /**
     * Paperform integration for Easysend.
     * @type {string}
     * @memberof AddServiceModel
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: AddServiceModelParametersValue; }}
     * @memberof AddServiceModel
     */
    'parameters': { [key: string]: AddServiceModelParametersValue; };
    /**
     * 
     * @type {{ [key: string]: AddServiceModelSetupValue; }}
     * @memberof AddServiceModel
     */
    'setup': { [key: string]: AddServiceModelSetupValue; };
    /**
     * 
     * @type {AddServiceModelOutput}
     * @memberof AddServiceModel
     */
    'output'?: AddServiceModelOutput;
}
/**
 * 
 * @export
 * @interface AddServiceModelOutput
 */
export interface AddServiceModelOutput {
    /**
     * URL to send webhooks to
     * @type {string}
     * @memberof AddServiceModelOutput
     */
    'webhookUrl'?: string;
}
/**
 * @type AddServiceModelParametersValue
 * @export
 */
export type AddServiceModelParametersValue = AddServiceModelParametersValueOneOf | AddServiceModelParametersValueOneOf1 | AddServiceModelParametersValueOneOf2 | AddServiceModelParametersValueOneOf3;

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf
 */
export interface AddServiceModelParametersValueOneOf {
    /**
     * If this parameter can have conditions. If it is an object, it is forced to be false
     * @type {boolean}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'canBeConditionedOn'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'type'?: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'format'?: FormatEnum;
    /**
     * Inclusive array of possible values this property can take
     * @type {Array<string>}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'enum'?: Array<string>;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<string>}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'examples'?: Array<string>;
}

export const TypeEnum = {
    String: 'string'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];
export const FormatEnum = {
    DateTime: 'date-time',
    Date: 'date'
} as const;

export type FormatEnum = typeof FormatEnum[keyof typeof FormatEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf1
 */
export interface AddServiceModelParametersValueOneOf1 {
    /**
     * If this parameter can have conditions. If it is an object, it is forced to be false
     * @type {boolean}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'canBeConditionedOn'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'type': TypeEnum;
    /**
     * Inclusive array of possible values this property can take
     * @type {Array<number>}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'enum'?: Array<number>;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<number>}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'examples'?: Array<number>;
}

export const TypeEnum = {
    Number: 'number'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf2
 */
export interface AddServiceModelParametersValueOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'type': TypeEnum;
    /**
     * 
     * @type {AddServiceModelParametersValueOneOf2Items}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'items'?: AddServiceModelParametersValueOneOf2Items;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<Array<any>>}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'examples'?: Array<Array<any>>;
}

export const TypeEnum = {
    Array: 'array'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf2Items
 */
export interface AddServiceModelParametersValueOneOf2Items {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf2Items
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf3
 */
export interface AddServiceModelParametersValueOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'type': TypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'properties'?: { [key: string]: any; };
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<{ [key: string]: any; }>}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'examples'?: Array<{ [key: string]: any; }>;
}

export const TypeEnum = {
    Object: 'object'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelSetupValue
 */
export interface AddServiceModelSetupValue {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddServiceModelSetupValue
     */
    'required'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'type': TypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddServiceModelSetupValue
     */
    'enum'?: Array<string>;
    /**
     * the url used for oauth login
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'url'?: string;
}

export const TypeEnum = {
    String: 'string',
    Oauth: 'oauth',
    Password: 'password'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];

/**
 * 
 * @export
 * @interface AdminDataGet200ResponseInner
 */
export interface AdminDataGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof AdminDataGet200ResponseInner
     */
    'accountId': string;
    /**
     * 
     * @type {number}
     * @memberof AdminDataGet200ResponseInner
     */
    'notificationCount': number;
}
/**
 * 
 * @export
 * @interface DataGet200Response
 */
export interface DataGet200Response {
    /**
     * 
     * @type {Array<DataModel>}
     * @memberof DataGet200Response
     */
    'data': Array<DataModel>;
}
/**
 * 
 * @export
 * @interface DataModel
 */
export interface DataModel {
    /**
     * 
     * @type {number}
     * @memberof DataModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DataModel
     */
    'orderId': string;
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof DataModel
     */
    'phoneNumber': NullablePhoneNumber;
    /**
     * 
     * @type {DataModelWaResponse}
     * @memberof DataModel
     */
    'waResponse': DataModelWaResponse;
    /**
     * 
     * @type {number}
     * @memberof DataModel
     */
    'triggerId': number | null;
    /**
     * 
     * @type {string}
     * @memberof DataModel
     */
    'status': StatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DataModel
     */
    'isTest': boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DataModel
     */
    'datetime': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DataModel
     */
    'params': { [key: string]: any; };
}

export const StatusEnum = {
    Sent: 'sent',
    Pending: 'pending',
    Cancelled: 'cancelled'
} as const;

export type StatusEnum = typeof StatusEnum[keyof typeof StatusEnum];

/**
 * the response received from the WA service
 * @export
 * @interface DataModelWaResponse
 */
export interface DataModelWaResponse {
    /**
     * the response code
     * @type {number}
     * @memberof DataModelWaResponse
     */
    'code'?: number;
    /**
     * the body received
     * @type {object}
     * @memberof DataModelWaResponse
     */
    'body'?: object;
}
/**
 * @type DataPatchRequest
 * @export
 */
export type DataPatchRequest = DataPatchRequestOneOf | UpdateOrderModel;

/**
 * 
 * @export
 * @interface DataPatchRequestOneOf
 */
export interface DataPatchRequestOneOf {
    /**
     * 
     * @type {Array<UpdateOrderModel>}
     * @memberof DataPatchRequestOneOf
     */
    'orders': Array<UpdateOrderModel>;
}
/**
 * 
 * @export
 * @interface DataResend200Response
 */
export interface DataResend200Response {
    /**
     * 
     * @type {DataModel}
     * @memberof DataResend200Response
     */
    'data': DataModel;
}
/**
 * The type of delay \"stale\" means that the message is sent out with the aforementioned delay (delayS) if the order is not updated. If the order is updated before the delay is over, then the message is cancelled \"simple\" means that the message is sent out regardless of the order update. 
 * @export
 * @enum {string}
 */

export const DelayTypeModel = {
    Simple: 'simple',
    Stale: 'stale'
} as const;

export type DelayTypeModel = typeof DelayTypeModel[keyof typeof DelayTypeModel];


/**
 * 
 * @export
 * @interface ErrorState
 */
export interface ErrorState {
    /**
     * 
     * @type {number}
     * @memberof ErrorState
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorState
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface EventTrigger
 */
export interface EventTrigger {
    /**
     * 
     * @type {number}
     * @memberof EventTrigger
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EventTrigger
     */
    'delete'?: boolean;
    /**
     * the message template to send when this trigger is activated
     * @type {string}
     * @memberof EventTrigger
     */
    'templateId'?: string;
    /**
     * Whether the condition is enabled
     * @type {boolean}
     * @memberof EventTrigger
     */
    'enabled'?: boolean;
    /**
     * Maximum notifications to be sent per order on this trigger. Default null -- unlimited
     * @type {number}
     * @memberof EventTrigger
     */
    'limit'?: number | null;
    /**
     * 
     * @type {EventTriggerCreateDelay}
     * @memberof EventTrigger
     */
    'delay'?: EventTriggerCreateDelay;
    /**
     * an array of usersIds to notify users when an event is created
     * @type {Array<string>}
     * @memberof EventTrigger
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: EventTriggerCondition; }}
     * @memberof EventTrigger
     */
    'conditions'?: { [key: string]: EventTriggerCondition; };
}
/**
 * 
 * @export
 * @interface EventTriggerAllOf
 */
export interface EventTriggerAllOf {
    /**
     * 
     * @type {number}
     * @memberof EventTriggerAllOf
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EventTriggerAllOf
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface EventTriggerCondition
 */
export interface EventTriggerCondition {
    /**
     * 
     * @type {EventTriggerConditionValues}
     * @memberof EventTriggerCondition
     */
    'values': EventTriggerConditionValues;
    /**
     * the test for the condition. Default is `include`
     * @type {string}
     * @memberof EventTriggerCondition
     */
    'test'?: TestEnum;
}

export const TestEnum = {
    Include: 'include',
    Exclude: 'exclude',
    GreaterThan: 'greater-than',
    LessThan: 'less-than'
} as const;

export type TestEnum = typeof TestEnum[keyof typeof TestEnum];

/**
 * @type EventTriggerConditionValues
 * @export
 */
export type EventTriggerConditionValues = Array<number> | Array<string>;

/**
 * 
 * @export
 * @interface EventTriggerCreate
 */
export interface EventTriggerCreate {
    /**
     * the message template to send when this trigger is activated
     * @type {string}
     * @memberof EventTriggerCreate
     */
    'templateId'?: string;
    /**
     * Whether the condition is enabled
     * @type {boolean}
     * @memberof EventTriggerCreate
     */
    'enabled'?: boolean;
    /**
     * Maximum notifications to be sent per order on this trigger. Default null -- unlimited
     * @type {number}
     * @memberof EventTriggerCreate
     */
    'limit'?: number | null;
    /**
     * 
     * @type {EventTriggerCreateDelay}
     * @memberof EventTriggerCreate
     */
    'delay'?: EventTriggerCreateDelay;
    /**
     * an array of usersIds to notify users when an event is created
     * @type {Array<string>}
     * @memberof EventTriggerCreate
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: EventTriggerCondition; }}
     * @memberof EventTriggerCreate
     */
    'conditions'?: { [key: string]: EventTriggerCondition; };
}
/**
 * the optional delay to attach to this service
 * @export
 * @interface EventTriggerCreateDelay
 */
export interface EventTriggerCreateDelay {
    /**
     * the delay in sending the message
     * @type {number}
     * @memberof EventTriggerCreateDelay
     */
    'seconds'?: number;
    /**
     * 
     * @type {DelayTypeModel}
     * @memberof EventTriggerCreateDelay
     */
    'type'?: DelayTypeModel;
}
/**
 * @type NullablePhoneNumber
 * Phone number to be sent to
 * @export
 */
export type NullablePhoneNumber = number | object | string;

/**
 * @type OverridePhoneModel
 * @export
 */
export type OverridePhoneModel = OverridePhoneModelOneOf | OverridePhoneModelOneOf1;

/**
 * Override with exact phone number
 * @export
 * @interface OverridePhoneModelOneOf
 */
export interface OverridePhoneModelOneOf {
    /**
     * 
     * @type {number}
     * @memberof OverridePhoneModelOneOf
     */
    'exact': number;
}
/**
 * Override with a field from the data
 * @export
 * @interface OverridePhoneModelOneOf1
 */
export interface OverridePhoneModelOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof OverridePhoneModelOneOf1
     */
    'field': string;
}
/**
 * 
 * @export
 * @interface PostServiceModel
 */
export interface PostServiceModel {
    /**
     * 
     * @type {string}
     * @memberof PostServiceModel
     */
    'id': string;
    /**
     * Base route on top of which all easysend paths are appended
     * @type {string}
     * @memberof PostServiceModel
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface PostTracking
 */
export interface PostTracking {
    /**
     * service ID
     * @type {string}
     * @memberof PostTracking
     */
    'serviceId': string;
    /**
     * Nickname to identify this tracking
     * @type {string}
     * @memberof PostTracking
     */
    'name': string;
    /**
     * The triggers
     * @type {Array<EventTriggerCreate>}
     * @memberof PostTracking
     */
    'events': Array<EventTriggerCreate>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PostTracking
     */
    'credentials': { [key: string]: any; };
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof PostTracking
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof PostTracking
     */
    'accountId'?: string | null;
}
/**
 * 
 * @export
 * @interface ServiceModel
 */
export interface ServiceModel {
    /**
     * Used to store and uniquely identify a service/scraper
     * @type {string}
     * @memberof ServiceModel
     */
    'id': string;
    /**
     * URL of the service
     * @type {string}
     * @memberof ServiceModel
     */
    'url'?: string;
    /**
     * Name of the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'name': string;
    /**
     * A service that implements only the schema route
     * @type {boolean}
     * @memberof ServiceModel
     */
    'isEphemeral'?: boolean;
    /**
     * If true, then parameters wont be checked when editing a trigger
     * @type {boolean}
     * @memberof ServiceModel
     */
    'skipParameterValidation'?: boolean;
    /**
     * any image/link representing the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'imgUrl': string;
    /**
     * Paperform integration for Easysend.
     * @type {string}
     * @memberof ServiceModel
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: AddServiceModelParametersValue; }}
     * @memberof ServiceModel
     */
    'parameters': { [key: string]: AddServiceModelParametersValue; };
    /**
     * 
     * @type {{ [key: string]: AddServiceModelSetupValue; }}
     * @memberof ServiceModel
     */
    'setup': { [key: string]: AddServiceModelSetupValue; };
    /**
     * 
     * @type {AddServiceModelOutput}
     * @memberof ServiceModel
     */
    'output'?: AddServiceModelOutput;
}
/**
 * 
 * @export
 * @interface ServiceModelAllOf
 */
export interface ServiceModelAllOf {
    /**
     * Used to store and uniquely identify a service/scraper
     * @type {string}
     * @memberof ServiceModelAllOf
     */
    'id': string;
    /**
     * URL of the service
     * @type {string}
     * @memberof ServiceModelAllOf
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface Services
 */
export interface Services {
    /**
     * 
     * @type {Array<ServiceModel>}
     * @memberof Services
     */
    'services': Array<ServiceModel>;
}
/**
 * 
 * @export
 * @interface TrackServiceModel
 */
export interface TrackServiceModel {
    /**
     * 
     * @type {number}
     * @memberof TrackServiceModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TrackServiceModel
     */
    'secretId': string;
    /**
     * 
     * @type {string}
     * @memberof TrackServiceModel
     */
    'name': string;
    /**
     * Used to store and uniquely identify a service/scraper.
     * @type {string}
     * @memberof TrackServiceModel
     */
    'serviceId'?: string;
    /**
     * The team ID this tracking belongs to
     * @type {string}
     * @memberof TrackServiceModel
     */
    'teamId': string;
    /**
     * The triggers setup for this service
     * @type {Array<EventTrigger>}
     * @memberof TrackServiceModel
     */
    'events': Array<EventTrigger>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TrackServiceModel
     */
    'lastActivity': string;
    /**
     * number of times tracking has received an event
     * @type {number}
     * @memberof TrackServiceModel
     */
    'triggered': number;
    /**
     * Whether the tracking is active or not. If the service isn\'t active -- no events are sent out
     * @type {boolean}
     * @memberof TrackServiceModel
     */
    'isActive': boolean;
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof TrackServiceModel
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof TrackServiceModel
     */
    'accountId': string | null;
    /**
     * 
     * @type {ErrorState}
     * @memberof TrackServiceModel
     */
    'error': ErrorState | null;
}
/**
 * 
 * @export
 * @interface TrackServices
 */
export interface TrackServices {
    /**
     * 
     * @type {Array<TrackServiceModel>}
     * @memberof TrackServices
     */
    'trackings': Array<TrackServiceModel>;
}
/**
 * 
 * @export
 * @interface TrackingPatch200Response
 */
export interface TrackingPatch200Response {
    /**
     * 
     * @type {string}
     * @memberof TrackingPatch200Response
     */
    'message'?: string;
    /**
     * 
     * @type {TrackServiceModel}
     * @memberof TrackingPatch200Response
     */
    'tracking'?: TrackServiceModel;
}
/**
 * 
 * @export
 * @interface TrackingPost200Response
 */
export interface TrackingPost200Response {
    /**
     * 
     * @type {string}
     * @memberof TrackingPost200Response
     */
    'message': string;
    /**
     * 
     * @type {TrackServiceModel}
     * @memberof TrackingPost200Response
     */
    'tracking': TrackServiceModel;
}
/**
 * 
 * @export
 * @interface TriggerTest200Response
 */
export interface TriggerTest200Response {
    /**
     * the parameter that was sent
     * @type {object}
     * @memberof TriggerTest200Response
     */
    'params'?: object;
    /**
     * mock order ID
     * @type {string}
     * @memberof TriggerTest200Response
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateOrderModel
 */
export interface UpdateOrderModel {
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof UpdateOrderModel
     */
    'phoneNumber'?: NullablePhoneNumber;
    /**
     * Unique identifier for the order. Is used to track the status internally
     * @type {string}
     * @memberof UpdateOrderModel
     */
    'orderId': string;
    /**
     * Is it a test order
     * @type {boolean}
     * @memberof UpdateOrderModel
     */
    'isTest'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateOrderModel
     */
    'params': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateTracking
 */
export interface UpdateTracking {
    /**
     * Nickname to identify this tracking
     * @type {string}
     * @memberof UpdateTracking
     */
    'name'?: string;
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof UpdateTracking
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateTracking
     */
    'credentials'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<EventTrigger>}
     * @memberof UpdateTracking
     */
    'events'?: Array<EventTrigger>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTracking
     */
    'isActive'?: boolean;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof UpdateTracking
     */
    'accountId'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateTrackingErrorState
 */
export interface UpdateTrackingErrorState {
    /**
     * 
     * @type {ErrorState}
     * @memberof UpdateTrackingErrorState
     */
    'error': ErrorState | null;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDataGet: async (teamId?: Array<string>, direction?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (teamId) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDataGet(teamId?: Array<string>, direction?: 'ASC' | 'DESC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdminDataGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDataGet(teamId, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDataGet(teamId?: Array<string>, direction?: 'ASC' | 'DESC', options?: any): AxiosPromise<Array<AdminDataGet200ResponseInner>> {
            return localVarFp.adminDataGet(teamId, direction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for adminDataGet operation in AdminApi.
 * @export
 * @interface AdminApiAdminDataGetRequest
 */
export interface AdminApiAdminDataGetRequest {
    /**
     * Fetch orders of the specified teamIds
     * @type {Array<string>}
     * @memberof AdminApiAdminDataGet
     */
    readonly teamId?: Array<string>

    /**
     * Fetch orders sent to the specified phone number
     * @type {'ASC' | 'DESC'}
     * @memberof AdminApiAdminDataGet
     */
    readonly direction?: 'ASC' | 'DESC'
}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Get admin data
     * @param {AdminApiAdminDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDataGet(requestParameters: AdminApiAdminDataGetRequest = {}, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDataGet(requestParameters.teamId, requestParameters.direction, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataResend: async (dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('dataResend', 'dataId', dataId)
            const localVarPath = `/data/{dataId}/resend-wa`
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataResend(dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResend200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataResend(dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataResend(dataId: string, options?: any): AxiosPromise<DataResend200Response> {
            return localVarFp.dataResend(dataId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataResend operation in DataApi.
 * @export
 * @interface DataApiDataResendRequest
 */
export interface DataApiDataResendRequest {
    /**
     * The secret sent to the parsing service
     * @type {string}
     * @memberof DataApiDataResend
     */
    readonly dataId: string
}

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * 
     * @summary Resend the WA message associated with this data point
     * @param {DataApiDataResendRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public dataResend(requestParameters: DataApiDataResendRequest, options?: AxiosRequestConfig) {
        return DataApiFp(this.configuration).dataResend(requestParameters.dataId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPatch: async (secretId: string, dataPatchRequest?: DataPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('dataPatch', 'secretId', secretId)
            const localVarPath = `/event/{secretId}`
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataPatch(secretId: string, dataPatchRequest?: DataPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataPatch(secretId, dataPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPatch(secretId: string, dataPatchRequest?: DataPatchRequest, options?: any): AxiosPromise<void> {
            return localVarFp.dataPatch(secretId, dataPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataPatch operation in EventsApi.
 * @export
 * @interface EventsApiDataPatchRequest
 */
export interface EventsApiDataPatchRequest {
    /**
     * The secret ID of the tracking made available to the service
     * @type {string}
     * @memberof EventsApiDataPatch
     */
    readonly secretId: string

    /**
     * 
     * @type {DataPatchRequest}
     * @memberof EventsApiDataPatch
     */
    readonly dataPatchRequest?: DataPatchRequest
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
     * @summary Update data/order details of a tracking
     * @param {EventsApiDataPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public dataPatch(requestParameters: EventsApiDataPatchRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).dataPatch(requestParameters.secretId, requestParameters.dataPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Removes the specified service from the list
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('servicesDelete', 'id', id)
            const localVarPath = `/services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all supported scraper services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost: async (postServiceModel?: PostServiceModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postServiceModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesReload: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Removes the specified service from the list
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all supported scraper services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Services>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesPost(postServiceModel?: PostServiceModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesPost(postServiceModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesReload(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesReload(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Removes the specified service from the list
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.servicesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all supported scraper services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet(options?: any): AxiosPromise<Services> {
            return localVarFp.servicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost(postServiceModel?: PostServiceModel, options?: any): AxiosPromise<void> {
            return localVarFp.servicesPost(postServiceModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesReload(options?: any): AxiosPromise<void> {
            return localVarFp.servicesReload(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for servicesDelete operation in ServicesApi.
 * @export
 * @interface ServicesApiServicesDeleteRequest
 */
export interface ServicesApiServicesDeleteRequest {
    /**
     * ID of service to remove
     * @type {string}
     * @memberof ServicesApiServicesDelete
     */
    readonly id: string
}

/**
 * Request parameters for servicesPost operation in ServicesApi.
 * @export
 * @interface ServicesApiServicesPostRequest
 */
export interface ServicesApiServicesPostRequest {
    /**
     * 
     * @type {PostServiceModel}
     * @memberof ServicesApiServicesPost
     */
    readonly postServiceModel?: PostServiceModel
}

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * 
     * @summary Removes the specified service from the list
     * @param {ServicesApiServicesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesDelete(requestParameters: ServicesApiServicesDeleteRequest, options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all supported scraper services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesGet(options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a new service to the list
     * @param {ServicesApiServicesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesPost(requestParameters: ServicesApiServicesPostRequest = {}, options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesPost(requestParameters.postServiceModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reload all service schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesReload(options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesReload(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackingsApi - axios parameter creator
 * @export
 */
export const TrackingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the data/order history
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {number} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet: async (trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: number, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)

            if (trackingId !== undefined) {
                localVarQueryParameter['trackingId'] = trackingId;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (excludeTests !== undefined) {
                localVarQueryParameter['excludeTests'] = excludeTests;
            }

            if (includeNullTriggers !== undefined) {
                localVarQueryParameter['includeNullTriggers'] = includeNullTriggers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingDelete: async (trackingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('trackingDelete', 'trackingId', trackingId)
            const localVarPath = `/tracking/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all services currently tracked by a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPatch: async (trackingId: number, updateTracking?: UpdateTracking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('trackingPatch', 'trackingId', trackingId)
            const localVarPath = `/tracking/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTracking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPost: async (postTracking?: PostTracking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTracking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingUpdateErrorState: async (secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('trackingUpdateErrorState', 'secretId', secretId)
            const localVarPath = `/tracking/{secretId}/update-error-state`
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTrackingErrorState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTest: async (trackingId: number, triggerId: number, recipientPhoneNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('triggerTest', 'trackingId', trackingId)
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('triggerTest', 'triggerId', triggerId)
            const localVarPath = `/tracking/{trackingId}/{triggerId}/test`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)))
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)

            if (recipientPhoneNumber !== undefined) {
                localVarQueryParameter['recipientPhoneNumber'] = recipientPhoneNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackingsApi - functional programming interface
 * @export
 */
export const TrackingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the data/order history
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {number} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataGet(trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: number, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataGet(trackingId, phoneNumber, triggerId, pageSize, cursor, q, excludeTests, includeNullTriggers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingDelete(trackingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingDelete(trackingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all services currently tracked by a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackServices>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingPatch(trackingId: number, updateTracking?: UpdateTracking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingPatch(trackingId, updateTracking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingPost(postTracking?: PostTracking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingPost(postTracking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingUpdateErrorState(secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingUpdateErrorState(secretId, updateTrackingErrorState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerTest(trackingId: number, triggerId: number, recipientPhoneNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerTest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerTest(trackingId, triggerId, recipientPhoneNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackingsApi - factory interface
 * @export
 */
export const TrackingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the data/order history
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {number} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet(trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: number, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, options?: any): AxiosPromise<DataGet200Response> {
            return localVarFp.dataGet(trackingId, phoneNumber, triggerId, pageSize, cursor, q, excludeTests, includeNullTriggers, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingDelete(trackingId: number, options?: any): AxiosPromise<void> {
            return localVarFp.trackingDelete(trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all services currently tracked by a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingGet(options?: any): AxiosPromise<TrackServices> {
            return localVarFp.trackingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPatch(trackingId: number, updateTracking?: UpdateTracking, options?: any): AxiosPromise<TrackingPatch200Response> {
            return localVarFp.trackingPatch(trackingId, updateTracking, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPost(postTracking?: PostTracking, options?: any): AxiosPromise<TrackingPost200Response> {
            return localVarFp.trackingPost(postTracking, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingUpdateErrorState(secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options?: any): AxiosPromise<void> {
            return localVarFp.trackingUpdateErrorState(secretId, updateTrackingErrorState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTest(trackingId: number, triggerId: number, recipientPhoneNumber?: string, options?: any): AxiosPromise<TriggerTest200Response> {
            return localVarFp.triggerTest(trackingId, triggerId, recipientPhoneNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataGet operation in TrackingsApi.
 * @export
 * @interface TrackingsApiDataGetRequest
 */
export interface TrackingsApiDataGetRequest {
    /**
     * Fetch orders of the specified trackingId
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly trackingId?: number

    /**
     * Fetch orders sent to the specified phone number
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly phoneNumber?: number

    /**
     * Fetch orders of the specified triggerId
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly triggerId?: number

    /**
     * Number of items to retreive
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly pageSize?: number

    /**
     * Cursor to retreive items. It is the ID before which you want to retrieve the orders
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly cursor?: number

    /**
     * Query to retrieve select orders
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly q?: string

    /**
     * Should tests be excluded
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly excludeTests?: boolean

    /**
     * Should events which did not trigger an EventTrigger be included?
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly includeNullTriggers?: boolean
}

/**
 * Request parameters for trackingDelete operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingDeleteRequest
 */
export interface TrackingsApiTrackingDeleteRequest {
    /**
     * The Tracking
     * @type {number}
     * @memberof TrackingsApiTrackingDelete
     */
    readonly trackingId: number
}

/**
 * Request parameters for trackingPatch operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingPatchRequest
 */
export interface TrackingsApiTrackingPatchRequest {
    /**
     * The Tracking
     * @type {number}
     * @memberof TrackingsApiTrackingPatch
     */
    readonly trackingId: number

    /**
     * 
     * @type {UpdateTracking}
     * @memberof TrackingsApiTrackingPatch
     */
    readonly updateTracking?: UpdateTracking
}

/**
 * Request parameters for trackingPost operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingPostRequest
 */
export interface TrackingsApiTrackingPostRequest {
    /**
     * 
     * @type {PostTracking}
     * @memberof TrackingsApiTrackingPost
     */
    readonly postTracking?: PostTracking
}

/**
 * Request parameters for trackingUpdateErrorState operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingUpdateErrorStateRequest
 */
export interface TrackingsApiTrackingUpdateErrorStateRequest {
    /**
     * The secret ID of the tracking made available to the service
     * @type {string}
     * @memberof TrackingsApiTrackingUpdateErrorState
     */
    readonly secretId: string

    /**
     * 
     * @type {UpdateTrackingErrorState}
     * @memberof TrackingsApiTrackingUpdateErrorState
     */
    readonly updateTrackingErrorState?: UpdateTrackingErrorState
}

/**
 * Request parameters for triggerTest operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTriggerTestRequest
 */
export interface TrackingsApiTriggerTestRequest {
    /**
     * The trackingId to test
     * @type {number}
     * @memberof TrackingsApiTriggerTest
     */
    readonly trackingId: number

    /**
     * The triggerId to test
     * @type {number}
     * @memberof TrackingsApiTriggerTest
     */
    readonly triggerId: number

    /**
     * Phone number to send the test to
     * @type {string}
     * @memberof TrackingsApiTriggerTest
     */
    readonly recipientPhoneNumber?: string
}

/**
 * TrackingsApi - object-oriented interface
 * @export
 * @class TrackingsApi
 * @extends {BaseAPI}
 */
export class TrackingsApi extends BaseAPI {
    /**
     * 
     * @summary Get the data/order history
     * @param {TrackingsApiDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public dataGet(requestParameters: TrackingsApiDataGetRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).dataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.triggerId, requestParameters.pageSize, requestParameters.cursor, requestParameters.q, requestParameters.excludeTests, requestParameters.includeNullTriggers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes the tracking and its associated flowIds from the Database permanently.
     * @summary Stop tracking
     * @param {TrackingsApiTrackingDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingDelete(requestParameters: TrackingsApiTrackingDeleteRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingDelete(requestParameters.trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all services currently tracked by a team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingGet(options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
     * @summary Update events, credentials, notifyUsers or isActive of a tracking
     * @param {TrackingsApiTrackingPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingPatch(requestParameters: TrackingsApiTrackingPatchRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingPatch(requestParameters.trackingId, requestParameters.updateTracking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start tracking of a new service for a team
     * @param {TrackingsApiTrackingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingPost(requestParameters: TrackingsApiTrackingPostRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingPost(requestParameters.postTracking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TrackingsApiTrackingUpdateErrorStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingUpdateErrorState(requestParameters: TrackingsApiTrackingUpdateErrorStateRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingUpdateErrorState(requestParameters.secretId, requestParameters.updateTrackingErrorState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test a trigger
     * @param {TrackingsApiTriggerTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public triggerTest(requestParameters: TrackingsApiTriggerTestRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).triggerTest(requestParameters.trackingId, requestParameters.triggerId, requestParameters.recipientPhoneNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


