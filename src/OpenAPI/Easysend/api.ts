const BASE_PATH = "https://api-notifications.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Easysend (Notifications) Service
 * Data Processing service to standardize & process data from individual parsers & services. ## Writing a service for ChatDaddy Easysend The job of a service is to parse and clean data from a given data source. If you are writing a parser for an e-commerce website -- your job is to simply extract the required parameters and send them to the EasySend service in the required format (more on the format later).  ## Incorporating the routes Easysend requires just the base url for each service. This can be  - http://abcd.com/api - http://xyz.com/ - etc. Appending to this base url, each service must incorporate the following routes in their app --  ### GET /easysend/schema \'This route is used by easysend to determine all the specifications of the service including:\'\' - the parameters the service can send - credentials required - an image - a description & name View the `ServiceModel` schema to know the exact specifications ### POST /easysend/{id} - This route is for registering a new tracking for a user.  - The `id` parameter is the ID of this tracking. - Service should keep the `id` parameter secret. - Body will be `application/json` encoded and have the following type: ``` ts     type Body = {         // the credentials the service required, specified by the aforementioned schema         credentials: { [_: string]: string }      } ``` - Service must check credentials & return a 400+ code if invalid - If the service returns a 200 code, it will be assumed that the tracking has been saved & validated successfully ### DELETE /easysend/{id} - This route is for deregistering the tracking specified by the `id` parameter in the path. ### GET /easysend/{id}/products - This route is optional - This route is for the service to return a list of products for the tracking - Returned schema should look like `{ products: PlatformProduct[] }` ## Sending Events to Easysend - Easysend expects a JSON encoded body at `PATCH /event/{id}` where ID is the secret identifier of the tracking registered previously - This route is covered in this document along with the required schema [here](/#Events) 
 *
 * The version of the OpenAPI document: 2.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface AddServiceModel
 */
export interface AddServiceModel {
    /**
     * Name of the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'name': string;
    /**
     * A service that implements only the schema route
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'isEphemeral'?: boolean;
    /**
     * If true, then parameters wont be checked when editing a trigger
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'skipParameterValidation'?: boolean;
    /**
     * any image/link representing the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'imgUrl': string;
    /**
     * Description of the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'description': string;
    /**
     * Whether the service supports the products API
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'supportsProducts'?: boolean;
    /**
     * 
     * @type {{ [key: string]: AddServiceModelParametersValue; }}
     * @memberof AddServiceModel
     */
    'parameters': { [key: string]: AddServiceModelParametersValue; };
    /**
     * 
     * @type {{ [key: string]: AddServiceModelSetupValue; }}
     * @memberof AddServiceModel
     */
    'setup': { [key: string]: AddServiceModelSetupValue; };
    /**
     * 
     * @type {AddServiceModelOutput}
     * @memberof AddServiceModel
     */
    'output'?: AddServiceModelOutput;
}
/**
 * 
 * @export
 * @interface AddServiceModelOutput
 */
export interface AddServiceModelOutput {
    /**
     * URL to send webhooks to
     * @type {string}
     * @memberof AddServiceModelOutput
     */
    'webhookUrl'?: string;
}
/**
 * @type AddServiceModelParametersValue
 * @export
 */
export type AddServiceModelParametersValue = AddServiceModelParametersValueOneOf | AddServiceModelParametersValueOneOf1 | AddServiceModelParametersValueOneOf2 | AddServiceModelParametersValueOneOf3;

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf
 */
export interface AddServiceModelParametersValueOneOf {
    /**
     * If this parameter can have conditions. If it is an object, it is forced to be false
     * @type {boolean}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'canBeConditionedOn'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'type'?: AddServiceModelParametersValueOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'format'?: AddServiceModelParametersValueOneOfFormatEnum;
    /**
     * Inclusive array of possible values this property can take
     * @type {Array<string>}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'enum'?: Array<string>;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<string>}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'examples'?: Array<string>;
}

export const AddServiceModelParametersValueOneOfTypeEnum = {
    String: 'string'
} as const;

export type AddServiceModelParametersValueOneOfTypeEnum = typeof AddServiceModelParametersValueOneOfTypeEnum[keyof typeof AddServiceModelParametersValueOneOfTypeEnum];
export const AddServiceModelParametersValueOneOfFormatEnum = {
    DateTime: 'date-time',
    Date: 'date'
} as const;

export type AddServiceModelParametersValueOneOfFormatEnum = typeof AddServiceModelParametersValueOneOfFormatEnum[keyof typeof AddServiceModelParametersValueOneOfFormatEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf1
 */
export interface AddServiceModelParametersValueOneOf1 {
    /**
     * If this parameter can have conditions. If it is an object, it is forced to be false
     * @type {boolean}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'canBeConditionedOn'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'type': AddServiceModelParametersValueOneOf1TypeEnum;
    /**
     * Inclusive array of possible values this property can take
     * @type {Array<number>}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'enum'?: Array<number>;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<number>}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'examples'?: Array<number>;
}

export const AddServiceModelParametersValueOneOf1TypeEnum = {
    Number: 'number'
} as const;

export type AddServiceModelParametersValueOneOf1TypeEnum = typeof AddServiceModelParametersValueOneOf1TypeEnum[keyof typeof AddServiceModelParametersValueOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf2
 */
export interface AddServiceModelParametersValueOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'type': AddServiceModelParametersValueOneOf2TypeEnum;
    /**
     * 
     * @type {AddServiceModelParametersValueOneOf2Items}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'items'?: AddServiceModelParametersValueOneOf2Items;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<Array<any>>}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'examples'?: Array<Array<any>>;
}

export const AddServiceModelParametersValueOneOf2TypeEnum = {
    Array: 'array'
} as const;

export type AddServiceModelParametersValueOneOf2TypeEnum = typeof AddServiceModelParametersValueOneOf2TypeEnum[keyof typeof AddServiceModelParametersValueOneOf2TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf2Items
 */
export interface AddServiceModelParametersValueOneOf2Items {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf2Items
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf3
 */
export interface AddServiceModelParametersValueOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'type': AddServiceModelParametersValueOneOf3TypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'properties'?: { [key: string]: any; };
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<{ [key: string]: any; }>}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'examples'?: Array<{ [key: string]: any; }>;
}

export const AddServiceModelParametersValueOneOf3TypeEnum = {
    Object: 'object'
} as const;

export type AddServiceModelParametersValueOneOf3TypeEnum = typeof AddServiceModelParametersValueOneOf3TypeEnum[keyof typeof AddServiceModelParametersValueOneOf3TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelSetupValue
 */
export interface AddServiceModelSetupValue {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddServiceModelSetupValue
     */
    'required'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'type': AddServiceModelSetupValueTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddServiceModelSetupValue
     */
    'enum'?: Array<string>;
    /**
     * the url used for oauth login
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'url'?: string;
}

export const AddServiceModelSetupValueTypeEnum = {
    String: 'string',
    Oauth: 'oauth',
    Password: 'password'
} as const;

export type AddServiceModelSetupValueTypeEnum = typeof AddServiceModelSetupValueTypeEnum[keyof typeof AddServiceModelSetupValueTypeEnum];

/**
 * 
 * @export
 * @interface AdminDataGet200ResponseInner
 */
export interface AdminDataGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof AdminDataGet200ResponseInner
     */
    'accountId': string;
    /**
     * 
     * @type {number}
     * @memberof AdminDataGet200ResponseInner
     */
    'notificationCount': number;
}
/**
 * 
 * @export
 * @interface CreatePaymentIntegrationRequest
 */
export interface CreatePaymentIntegrationRequest {
    /**
     * payment integration system used
     * @type {string}
     * @memberof CreatePaymentIntegrationRequest
     */
    'paymentSystemId': string;
    /**
     * 
     * @type {DataType}
     * @memberof CreatePaymentIntegrationRequest
     */
    'dataType': DataType;
}
/**
 * 
 * @export
 * @interface DataGet200Response
 */
export interface DataGet200Response {
    /**
     * 
     * @type {Array<EasysendDataModel>}
     * @memberof DataGet200Response
     */
    'data': Array<EasysendDataModel>;
    /**
     * 
     * @type {number}
     * @memberof DataGet200Response
     */
    'total'?: number;
}
/**
 * @type DataPatchRequest
 * @export
 */
export type DataPatchRequest = DataPatchRequestOneOf | UpdateOrderModel;

/**
 * 
 * @export
 * @interface DataPatchRequestOneOf
 */
export interface DataPatchRequestOneOf {
    /**
     * 
     * @type {Array<UpdateOrderModel>}
     * @memberof DataPatchRequestOneOf
     */
    'orders': Array<UpdateOrderModel>;
}
/**
 * 
 * @export
 * @interface DataResend200Response
 */
export interface DataResend200Response {
    /**
     * 
     * @type {EasysendDataModel}
     * @memberof DataResend200Response
     */
    'data': EasysendDataModel;
}
/**
 * 
 * @export
 * @interface DataType
 */
export interface DataType {
    /**
     * 
     * @type {string}
     * @memberof DataType
     */
    'qrCodeUrl'?: string;
}
/**
 * The type of delay \"stale\" means that the message is sent out with the aforementioned delay (delayS) if the order is not updated. If the order is updated before the delay is over, then the message is cancelled \"simple\" means that the message is sent out regardless of the order update. 
 * @export
 * @enum {string}
 */

export const DelayTypeModel = {
    Simple: 'simple',
    Stale: 'stale'
} as const;

export type DelayTypeModel = typeof DelayTypeModel[keyof typeof DelayTypeModel];


/**
 * 
 * @export
 * @interface EasysendDataModel
 */
export interface EasysendDataModel {
    /**
     * 
     * @type {number}
     * @memberof EasysendDataModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EasysendDataModel
     */
    'orderId': string;
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof EasysendDataModel
     */
    'phoneNumber': NullablePhoneNumber;
    /**
     * 
     * @type {EasysendDataModelWaResponse}
     * @memberof EasysendDataModel
     */
    'waResponse': EasysendDataModelWaResponse;
    /**
     * 
     * @type {number}
     * @memberof EasysendDataModel
     */
    'triggerId': number | null;
    /**
     * 
     * @type {string}
     * @memberof EasysendDataModel
     */
    'status': EasysendDataModelStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof EasysendDataModel
     */
    'isTest': boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof EasysendDataModel
     */
    'datetime': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof EasysendDataModel
     */
    'params': { [key: string]: any; };
}

export const EasysendDataModelStatusEnum = {
    Sent: 'sent',
    Pending: 'pending',
    Cancelled: 'cancelled'
} as const;

export type EasysendDataModelStatusEnum = typeof EasysendDataModelStatusEnum[keyof typeof EasysendDataModelStatusEnum];

/**
 * the response received from the WA service
 * @export
 * @interface EasysendDataModelWaResponse
 */
export interface EasysendDataModelWaResponse {
    /**
     * the response code
     * @type {number}
     * @memberof EasysendDataModelWaResponse
     */
    'code'?: number;
    /**
     * the body received
     * @type {object}
     * @memberof EasysendDataModelWaResponse
     */
    'body'?: object;
}
/**
 * 
 * @export
 * @interface ErrorState
 */
export interface ErrorState {
    /**
     * 
     * @type {number}
     * @memberof ErrorState
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorState
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface EventTrigger
 */
export interface EventTrigger {
    /**
     * 
     * @type {number}
     * @memberof EventTrigger
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EventTrigger
     */
    'delete'?: boolean;
    /**
     * the message template to send when this trigger is activated
     * @type {string}
     * @memberof EventTrigger
     */
    'templateId'?: string;
    /**
     * Whether the condition is enabled
     * @type {boolean}
     * @memberof EventTrigger
     */
    'enabled'?: boolean;
    /**
     * Maximum notifications to be sent per order on this trigger. Default null -- unlimited
     * @type {number}
     * @memberof EventTrigger
     */
    'limit'?: number | null;
    /**
     * 
     * @type {EventTriggerCreateDelay}
     * @memberof EventTrigger
     */
    'delay'?: EventTriggerCreateDelay;
    /**
     * an array of usersIds to notify users when an event is created
     * @type {Array<string>}
     * @memberof EventTrigger
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: EventTriggerCondition; }}
     * @memberof EventTrigger
     */
    'conditions'?: { [key: string]: EventTriggerCondition; };
}
/**
 * 
 * @export
 * @interface EventTriggerAllOf
 */
export interface EventTriggerAllOf {
    /**
     * 
     * @type {number}
     * @memberof EventTriggerAllOf
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EventTriggerAllOf
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface EventTriggerCondition
 */
export interface EventTriggerCondition {
    /**
     * 
     * @type {EventTriggerConditionValues}
     * @memberof EventTriggerCondition
     */
    'values': EventTriggerConditionValues;
    /**
     * the test for the condition. Default is `include`
     * @type {string}
     * @memberof EventTriggerCondition
     */
    'test'?: EventTriggerConditionTestEnum;
}

export const EventTriggerConditionTestEnum = {
    Include: 'include',
    Exclude: 'exclude',
    GreaterThan: 'greater-than',
    LessThan: 'less-than'
} as const;

export type EventTriggerConditionTestEnum = typeof EventTriggerConditionTestEnum[keyof typeof EventTriggerConditionTestEnum];

/**
 * @type EventTriggerConditionValues
 * @export
 */
export type EventTriggerConditionValues = Array<number> | Array<string>;

/**
 * 
 * @export
 * @interface EventTriggerCreate
 */
export interface EventTriggerCreate {
    /**
     * the message template to send when this trigger is activated
     * @type {string}
     * @memberof EventTriggerCreate
     */
    'templateId'?: string;
    /**
     * Whether the condition is enabled
     * @type {boolean}
     * @memberof EventTriggerCreate
     */
    'enabled'?: boolean;
    /**
     * Maximum notifications to be sent per order on this trigger. Default null -- unlimited
     * @type {number}
     * @memberof EventTriggerCreate
     */
    'limit'?: number | null;
    /**
     * 
     * @type {EventTriggerCreateDelay}
     * @memberof EventTriggerCreate
     */
    'delay'?: EventTriggerCreateDelay;
    /**
     * an array of usersIds to notify users when an event is created
     * @type {Array<string>}
     * @memberof EventTriggerCreate
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: EventTriggerCondition; }}
     * @memberof EventTriggerCreate
     */
    'conditions'?: { [key: string]: EventTriggerCondition; };
}
/**
 * the optional delay to attach to this service
 * @export
 * @interface EventTriggerCreateDelay
 */
export interface EventTriggerCreateDelay {
    /**
     * the delay in sending the message
     * @type {number}
     * @memberof EventTriggerCreateDelay
     */
    'seconds'?: number;
    /**
     * 
     * @type {DelayTypeModel}
     * @memberof EventTriggerCreateDelay
     */
    'type'?: DelayTypeModel;
}
/**
 * 
 * @export
 * @interface GetPaymentIntegrations200Response
 */
export interface GetPaymentIntegrations200Response {
    /**
     * 
     * @type {Array<PaymentIntegration>}
     * @memberof GetPaymentIntegrations200Response
     */
    'integrations': Array<PaymentIntegration>;
}
/**
 * @type NullablePhoneNumber
 * Phone number to be sent to
 * @export
 */
export type NullablePhoneNumber = number | object | string;

/**
 * @type OverridePhoneModel
 * @export
 */
export type OverridePhoneModel = OverridePhoneModelOneOf | OverridePhoneModelOneOf1;

/**
 * Override with exact phone number
 * @export
 * @interface OverridePhoneModelOneOf
 */
export interface OverridePhoneModelOneOf {
    /**
     * 
     * @type {number}
     * @memberof OverridePhoneModelOneOf
     */
    'exact': number;
}
/**
 * Override with a field from the data
 * @export
 * @interface OverridePhoneModelOneOf1
 */
export interface OverridePhoneModelOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof OverridePhoneModelOneOf1
     */
    'field': string;
}
/**
 * 
 * @export
 * @interface PatchPaymentIntegrationRequest
 */
export interface PatchPaymentIntegrationRequest {
    /**
     * 
     * @type {DataType}
     * @memberof PatchPaymentIntegrationRequest
     */
    'dataType'?: DataType;
}
/**
 * 
 * @export
 * @interface PaymentIntegration
 */
export interface PaymentIntegration {
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentIntegration
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'teamId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentIntegration
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentIntegration
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'paymentSystemId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'qrCodeUrl'?: string;
}
/**
 * 
 * @export
 * @interface PaymentRecord
 */
export interface PaymentRecord {
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentRecord
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof PaymentRecord
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'orderId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'paymentSystemId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'contactId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'status': PaymentRecordStatusEnum;
}

export const PaymentRecordStatusEnum = {
    Pending: 'pending',
    Cancelled: 'cancelled',
    Completed: 'completed'
} as const;

export type PaymentRecordStatusEnum = typeof PaymentRecordStatusEnum[keyof typeof PaymentRecordStatusEnum];

/**
 * 
 * @export
 * @interface PaymentRecordPostRequest
 */
export interface PaymentRecordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'integrationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'status': PaymentRecordPostRequestStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PaymentRecordPostRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'contactId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'messageId'?: string;
}

export const PaymentRecordPostRequestStatusEnum = {
    Completed: 'completed',
    Pending: 'pending',
    Cancelled: 'cancelled'
} as const;

export type PaymentRecordPostRequestStatusEnum = typeof PaymentRecordPostRequestStatusEnum[keyof typeof PaymentRecordPostRequestStatusEnum];

/**
 * 
 * @export
 * @interface PaymentRecordsGet200Response
 */
export interface PaymentRecordsGet200Response {
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {Array<PaymentRecord>}
     * @memberof PaymentRecordsGet200Response
     */
    'records': Array<PaymentRecord>;
}
/**
 * 
 * @export
 * @interface PaymentSystem
 */
export interface PaymentSystem {
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'type': PaymentSystemTypeEnum;
    /**
     * 
     * @type {DataType}
     * @memberof PaymentSystem
     */
    'dataType': DataType;
    /**
     * 
     * @type {PaymentIntegration}
     * @memberof PaymentSystem
     */
    'currentIntegration'?: PaymentIntegration;
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'country': string;
}

export const PaymentSystemTypeEnum = {
    Qr: 'qr',
    Url: 'url'
} as const;

export type PaymentSystemTypeEnum = typeof PaymentSystemTypeEnum[keyof typeof PaymentSystemTypeEnum];

/**
 * 
 * @export
 * @interface PaymentSystemsGet200Response
 */
export interface PaymentSystemsGet200Response {
    /**
     * 
     * @type {Array<PaymentSystem>}
     * @memberof PaymentSystemsGet200Response
     */
    'paymentSystems': Array<PaymentSystem>;
}
/**
 * 
 * @export
 * @interface PostServiceModel
 */
export interface PostServiceModel {
    /**
     * 
     * @type {string}
     * @memberof PostServiceModel
     */
    'id': string;
    /**
     * Base route on top of which all easysend paths are appended
     * @type {string}
     * @memberof PostServiceModel
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface PostTracking
 */
export interface PostTracking {
    /**
     * service ID
     * @type {string}
     * @memberof PostTracking
     */
    'serviceId': string;
    /**
     * Nickname to identify this tracking
     * @type {string}
     * @memberof PostTracking
     */
    'name': string;
    /**
     * The triggers
     * @type {Array<EventTriggerCreate>}
     * @memberof PostTracking
     */
    'events': Array<EventTriggerCreate>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PostTracking
     */
    'credentials': { [key: string]: any; };
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof PostTracking
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof PostTracking
     */
    'accountId'?: string | null;
}
/**
 * 
 * @export
 * @interface ServiceModel
 */
export interface ServiceModel {
    /**
     * Used to store and uniquely identify a service/scraper
     * @type {string}
     * @memberof ServiceModel
     */
    'id': string;
    /**
     * URL of the service
     * @type {string}
     * @memberof ServiceModel
     */
    'url'?: string;
    /**
     * Name of the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'name': string;
    /**
     * A service that implements only the schema route
     * @type {boolean}
     * @memberof ServiceModel
     */
    'isEphemeral'?: boolean;
    /**
     * If true, then parameters wont be checked when editing a trigger
     * @type {boolean}
     * @memberof ServiceModel
     */
    'skipParameterValidation'?: boolean;
    /**
     * any image/link representing the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'imgUrl': string;
    /**
     * Description of the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'description': string;
    /**
     * Whether the service supports the products API
     * @type {boolean}
     * @memberof ServiceModel
     */
    'supportsProducts'?: boolean;
    /**
     * 
     * @type {{ [key: string]: AddServiceModelParametersValue; }}
     * @memberof ServiceModel
     */
    'parameters': { [key: string]: AddServiceModelParametersValue; };
    /**
     * 
     * @type {{ [key: string]: AddServiceModelSetupValue; }}
     * @memberof ServiceModel
     */
    'setup': { [key: string]: AddServiceModelSetupValue; };
    /**
     * 
     * @type {AddServiceModelOutput}
     * @memberof ServiceModel
     */
    'output'?: AddServiceModelOutput;
}
/**
 * 
 * @export
 * @interface ServiceModelAllOf
 */
export interface ServiceModelAllOf {
    /**
     * Used to store and uniquely identify a service/scraper
     * @type {string}
     * @memberof ServiceModelAllOf
     */
    'id': string;
    /**
     * URL of the service
     * @type {string}
     * @memberof ServiceModelAllOf
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ServiceProductsData
 */
export interface ServiceProductsData {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ServiceProductsData
     */
    'products': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface Services
 */
export interface Services {
    /**
     * 
     * @type {Array<ServiceModel>}
     * @memberof Services
     */
    'services': Array<ServiceModel>;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuccessResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface TrackServiceModel
 */
export interface TrackServiceModel {
    /**
     * 
     * @type {number}
     * @memberof TrackServiceModel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TrackServiceModel
     */
    'secretId': string;
    /**
     * 
     * @type {string}
     * @memberof TrackServiceModel
     */
    'name': string;
    /**
     * Used to store and uniquely identify a service/scraper.
     * @type {string}
     * @memberof TrackServiceModel
     */
    'serviceId'?: string;
    /**
     * The team ID this tracking belongs to
     * @type {string}
     * @memberof TrackServiceModel
     */
    'teamId': string;
    /**
     * The triggers setup for this service
     * @type {Array<EventTrigger>}
     * @memberof TrackServiceModel
     */
    'events': Array<EventTrigger>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TrackServiceModel
     */
    'lastActivity': string;
    /**
     * number of times tracking has received an event
     * @type {number}
     * @memberof TrackServiceModel
     */
    'triggered': number;
    /**
     * Whether the tracking is active or not. If the service isn\'t active -- no events are sent out
     * @type {boolean}
     * @memberof TrackServiceModel
     */
    'isActive': boolean;
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof TrackServiceModel
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof TrackServiceModel
     */
    'accountId': string | null;
    /**
     * 
     * @type {ErrorState}
     * @memberof TrackServiceModel
     */
    'error': ErrorState | null;
}
/**
 * 
 * @export
 * @interface TrackServices
 */
export interface TrackServices {
    /**
     * 
     * @type {Array<TrackServiceModel>}
     * @memberof TrackServices
     */
    'trackings': Array<TrackServiceModel>;
}
/**
 * 
 * @export
 * @interface TrackingPatch200Response
 */
export interface TrackingPatch200Response {
    /**
     * 
     * @type {string}
     * @memberof TrackingPatch200Response
     */
    'message'?: string;
    /**
     * 
     * @type {TrackServiceModel}
     * @memberof TrackingPatch200Response
     */
    'tracking'?: TrackServiceModel;
}
/**
 * 
 * @export
 * @interface TrackingPost200Response
 */
export interface TrackingPost200Response {
    /**
     * 
     * @type {string}
     * @memberof TrackingPost200Response
     */
    'message': string;
    /**
     * 
     * @type {TrackServiceModel}
     * @memberof TrackingPost200Response
     */
    'tracking': TrackServiceModel;
}
/**
 * 
 * @export
 * @interface TriggerTest200Response
 */
export interface TriggerTest200Response {
    /**
     * the parameter that was sent
     * @type {object}
     * @memberof TriggerTest200Response
     */
    'params'?: object;
    /**
     * mock order ID
     * @type {string}
     * @memberof TriggerTest200Response
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateOrderModel
 */
export interface UpdateOrderModel {
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof UpdateOrderModel
     */
    'phoneNumber'?: NullablePhoneNumber;
    /**
     * Unique identifier for the order. Is used to track the status internally
     * @type {string}
     * @memberof UpdateOrderModel
     */
    'orderId': string;
    /**
     * Is it a test order
     * @type {boolean}
     * @memberof UpdateOrderModel
     */
    'isTest'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateOrderModel
     */
    'params': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateTracking
 */
export interface UpdateTracking {
    /**
     * Nickname to identify this tracking
     * @type {string}
     * @memberof UpdateTracking
     */
    'name'?: string;
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof UpdateTracking
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateTracking
     */
    'credentials'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<EventTrigger>}
     * @memberof UpdateTracking
     */
    'events'?: Array<EventTrigger>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTracking
     */
    'isActive'?: boolean;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof UpdateTracking
     */
    'accountId'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateTrackingErrorState
 */
export interface UpdateTrackingErrorState {
    /**
     * 
     * @type {ErrorState}
     * @memberof UpdateTrackingErrorState
     */
    'error': ErrorState | null;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDataGet: async (teamId?: Array<string>, direction?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (teamId) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDataGet(teamId?: Array<string>, direction?: 'ASC' | 'DESC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdminDataGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDataGet(teamId, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDataGet(teamId?: Array<string>, direction?: 'ASC' | 'DESC', options?: any): AxiosPromise<Array<AdminDataGet200ResponseInner>> {
            return localVarFp.adminDataGet(teamId, direction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for adminDataGet operation in AdminApi.
 * @export
 * @interface AdminApiAdminDataGetRequest
 */
export interface AdminApiAdminDataGetRequest {
    /**
     * Fetch orders of the specified teamIds
     * @type {Array<string>}
     * @memberof AdminApiAdminDataGet
     */
    readonly teamId?: Array<string>

    /**
     * Fetch orders sent to the specified phone number
     * @type {'ASC' | 'DESC'}
     * @memberof AdminApiAdminDataGet
     */
    readonly direction?: 'ASC' | 'DESC'
}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Get admin data
     * @param {AdminApiAdminDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDataGet(requestParameters: AdminApiAdminDataGetRequest = {}, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDataGet(requestParameters.teamId, requestParameters.direction, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPatch: async (secretId: string, dataPatchRequest?: DataPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('dataPatch', 'secretId', secretId)
            const localVarPath = `/event/{secretId}`
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataResend: async (dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('dataResend', 'dataId', dataId)
            const localVarPath = `/data/{dataId}/resend-wa`
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataPatch(secretId: string, dataPatchRequest?: DataPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataPatch(secretId, dataPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataResend(dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResend200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataResend(dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPatch(secretId: string, dataPatchRequest?: DataPatchRequest, options?: any): AxiosPromise<void> {
            return localVarFp.dataPatch(secretId, dataPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataResend(dataId: string, options?: any): AxiosPromise<DataResend200Response> {
            return localVarFp.dataResend(dataId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataPatch operation in EventsApi.
 * @export
 * @interface EventsApiDataPatchRequest
 */
export interface EventsApiDataPatchRequest {
    /**
     * The secret ID of the tracking made available to the service
     * @type {string}
     * @memberof EventsApiDataPatch
     */
    readonly secretId: string

    /**
     * 
     * @type {DataPatchRequest}
     * @memberof EventsApiDataPatch
     */
    readonly dataPatchRequest?: DataPatchRequest
}

/**
 * Request parameters for dataResend operation in EventsApi.
 * @export
 * @interface EventsApiDataResendRequest
 */
export interface EventsApiDataResendRequest {
    /**
     * The secret sent to the parsing service
     * @type {string}
     * @memberof EventsApiDataResend
     */
    readonly dataId: string
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
     * @summary Update data/order details of a tracking
     * @param {EventsApiDataPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public dataPatch(requestParameters: EventsApiDataPatchRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).dataPatch(requestParameters.secretId, requestParameters.dataPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend the WA message associated with this data point
     * @param {EventsApiDataResendRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public dataResend(requestParameters: EventsApiDataResendRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).dataResend(requestParameters.dataId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentIntegrationsApi - axios parameter creator
 * @export
 */
export const PaymentIntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a payment integration
         * @param {CreatePaymentIntegrationRequest} [createPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentIntegration: async (createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentIntegrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete the user\'s payment integration
         * @param {Array<string>} id the ids of the payment integration to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentIntegration: async (id: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePaymentIntegration', 'id', id)
            const localVarPath = `/payment-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all payment integrations available to a user
         * @param {string} [id] Fetch the payment integrations with the id specified
         * @param {boolean} [isInstalled] Fetch only installed integration if true
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntegrations: async (id?: string, isInstalled?: boolean, isEnabled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_READ"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (isInstalled !== undefined) {
                localVarQueryParameter['isInstalled'] = isInstalled;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update the user\'s payment integration
         * @param {string} id the id of the payment integration to patch
         * @param {PatchPaymentIntegrationRequest} [patchPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPaymentIntegration: async (id: string, patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchPaymentIntegration', 'id', id)
            const localVarPath = `/payment-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchPaymentIntegrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentIntegrationsApi - functional programming interface
 * @export
 */
export const PaymentIntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentIntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a payment integration
         * @param {CreatePaymentIntegrationRequest} [createPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentIntegration(createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntegration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentIntegration(createPaymentIntegrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete the user\'s payment integration
         * @param {Array<string>} id the ids of the payment integration to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentIntegration(id: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentIntegration(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all payment integrations available to a user
         * @param {string} [id] Fetch the payment integrations with the id specified
         * @param {boolean} [isInstalled] Fetch only installed integration if true
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentIntegrations(id?: string, isInstalled?: boolean, isEnabled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentIntegrations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentIntegrations(id, isInstalled, isEnabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update the user\'s payment integration
         * @param {string} id the id of the payment integration to patch
         * @param {PatchPaymentIntegrationRequest} [patchPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchPaymentIntegration(id: string, patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPaymentIntegration(id, patchPaymentIntegrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentIntegrationsApi - factory interface
 * @export
 */
export const PaymentIntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentIntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a payment integration
         * @param {CreatePaymentIntegrationRequest} [createPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentIntegration(createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest, options?: any): AxiosPromise<PaymentIntegration> {
            return localVarFp.createPaymentIntegration(createPaymentIntegrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete the user\'s payment integration
         * @param {Array<string>} id the ids of the payment integration to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentIntegration(id: Array<string>, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deletePaymentIntegration(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all payment integrations available to a user
         * @param {string} [id] Fetch the payment integrations with the id specified
         * @param {boolean} [isInstalled] Fetch only installed integration if true
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntegrations(id?: string, isInstalled?: boolean, isEnabled?: boolean, options?: any): AxiosPromise<GetPaymentIntegrations200Response> {
            return localVarFp.getPaymentIntegrations(id, isInstalled, isEnabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update the user\'s payment integration
         * @param {string} id the id of the payment integration to patch
         * @param {PatchPaymentIntegrationRequest} [patchPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPaymentIntegration(id: string, patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.patchPaymentIntegration(id, patchPaymentIntegrationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPaymentIntegration operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiCreatePaymentIntegrationRequest
 */
export interface PaymentIntegrationsApiCreatePaymentIntegrationRequest {
    /**
     * 
     * @type {CreatePaymentIntegrationRequest}
     * @memberof PaymentIntegrationsApiCreatePaymentIntegration
     */
    readonly createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest
}

/**
 * Request parameters for deletePaymentIntegration operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiDeletePaymentIntegrationRequest
 */
export interface PaymentIntegrationsApiDeletePaymentIntegrationRequest {
    /**
     * the ids of the payment integration to delete
     * @type {Array<string>}
     * @memberof PaymentIntegrationsApiDeletePaymentIntegration
     */
    readonly id: Array<string>
}

/**
 * Request parameters for getPaymentIntegrations operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiGetPaymentIntegrationsRequest
 */
export interface PaymentIntegrationsApiGetPaymentIntegrationsRequest {
    /**
     * Fetch the payment integrations with the id specified
     * @type {string}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly id?: string

    /**
     * Fetch only installed integration if true
     * @type {boolean}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly isInstalled?: boolean

    /**
     * Fetch only enabled integrations if true
     * @type {boolean}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly isEnabled?: boolean
}

/**
 * Request parameters for patchPaymentIntegration operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiPatchPaymentIntegrationRequest
 */
export interface PaymentIntegrationsApiPatchPaymentIntegrationRequest {
    /**
     * the id of the payment integration to patch
     * @type {string}
     * @memberof PaymentIntegrationsApiPatchPaymentIntegration
     */
    readonly id: string

    /**
     * 
     * @type {PatchPaymentIntegrationRequest}
     * @memberof PaymentIntegrationsApiPatchPaymentIntegration
     */
    readonly patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest
}

/**
 * PaymentIntegrationsApi - object-oriented interface
 * @export
 * @class PaymentIntegrationsApi
 * @extends {BaseAPI}
 */
export class PaymentIntegrationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a payment integration
     * @param {PaymentIntegrationsApiCreatePaymentIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public createPaymentIntegration(requestParameters: PaymentIntegrationsApiCreatePaymentIntegrationRequest = {}, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).createPaymentIntegration(requestParameters.createPaymentIntegrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete the user\'s payment integration
     * @param {PaymentIntegrationsApiDeletePaymentIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public deletePaymentIntegration(requestParameters: PaymentIntegrationsApiDeletePaymentIntegrationRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).deletePaymentIntegration(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all payment integrations available to a user
     * @param {PaymentIntegrationsApiGetPaymentIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public getPaymentIntegrations(requestParameters: PaymentIntegrationsApiGetPaymentIntegrationsRequest = {}, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).getPaymentIntegrations(requestParameters.id, requestParameters.isInstalled, requestParameters.isEnabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update the user\'s payment integration
     * @param {PaymentIntegrationsApiPatchPaymentIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public patchPaymentIntegration(requestParameters: PaymentIntegrationsApiPatchPaymentIntegrationRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).patchPaymentIntegration(requestParameters.id, requestParameters.patchPaymentIntegrationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentRecordsApi - axios parameter creator
 * @export
 */
export const PaymentRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PaymentRecordPostRequest} [paymentRecordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordPost: async (paymentRecordPostRequest?: PaymentRecordPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_RECORDS_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentRecordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {Array<string>} [ids] Fetch payment records of specified transaction ids
         * @param {Array<string>} [integrationId] Fetch payment records of specified integration ids
         * @param {string} [paymentSystemId] Fetch payment records of specified category
         * @param {string} [beforeDate] Fetch payment records before this data
         * @param {string} [afterDate] Fetch payment records after this data
         * @param {string} [orderId] Fetch payment records by orderId
         * @param {'completed' | 'pending' | 'cancelled'} [status] Fetch payment records with status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordsGet: async (pageSize?: number, cursor?: string, ids?: Array<string>, integrationId?: Array<string>, paymentSystemId?: string, beforeDate?: string, afterDate?: string, orderId?: string, status?: 'completed' | 'pending' | 'cancelled', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_RECORDS_READ"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (integrationId) {
                localVarQueryParameter['integrationId'] = integrationId;
            }

            if (paymentSystemId !== undefined) {
                localVarQueryParameter['paymentSystemId'] = paymentSystemId;
            }

            if (beforeDate !== undefined) {
                localVarQueryParameter['beforeDate'] = (beforeDate as any instanceof Date) ?
                    (beforeDate as any).toISOString() :
                    beforeDate;
            }

            if (afterDate !== undefined) {
                localVarQueryParameter['afterDate'] = (afterDate as any instanceof Date) ?
                    (afterDate as any).toISOString() :
                    afterDate;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentRecordsApi - functional programming interface
 * @export
 */
export const PaymentRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PaymentRecordPostRequest} [paymentRecordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentRecordPost(paymentRecordPostRequest?: PaymentRecordPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentRecordPost(paymentRecordPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {Array<string>} [ids] Fetch payment records of specified transaction ids
         * @param {Array<string>} [integrationId] Fetch payment records of specified integration ids
         * @param {string} [paymentSystemId] Fetch payment records of specified category
         * @param {string} [beforeDate] Fetch payment records before this data
         * @param {string} [afterDate] Fetch payment records after this data
         * @param {string} [orderId] Fetch payment records by orderId
         * @param {'completed' | 'pending' | 'cancelled'} [status] Fetch payment records with status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentRecordsGet(pageSize?: number, cursor?: string, ids?: Array<string>, integrationId?: Array<string>, paymentSystemId?: string, beforeDate?: string, afterDate?: string, orderId?: string, status?: 'completed' | 'pending' | 'cancelled', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecordsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentRecordsGet(pageSize, cursor, ids, integrationId, paymentSystemId, beforeDate, afterDate, orderId, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentRecordsApi - factory interface
 * @export
 */
export const PaymentRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentRecordsApiFp(configuration)
    return {
        /**
         * 
         * @param {PaymentRecordPostRequest} [paymentRecordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordPost(paymentRecordPostRequest?: PaymentRecordPostRequest, options?: any): AxiosPromise<PaymentRecord> {
            return localVarFp.paymentRecordPost(paymentRecordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {Array<string>} [ids] Fetch payment records of specified transaction ids
         * @param {Array<string>} [integrationId] Fetch payment records of specified integration ids
         * @param {string} [paymentSystemId] Fetch payment records of specified category
         * @param {string} [beforeDate] Fetch payment records before this data
         * @param {string} [afterDate] Fetch payment records after this data
         * @param {string} [orderId] Fetch payment records by orderId
         * @param {'completed' | 'pending' | 'cancelled'} [status] Fetch payment records with status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordsGet(pageSize?: number, cursor?: string, ids?: Array<string>, integrationId?: Array<string>, paymentSystemId?: string, beforeDate?: string, afterDate?: string, orderId?: string, status?: 'completed' | 'pending' | 'cancelled', options?: any): AxiosPromise<PaymentRecordsGet200Response> {
            return localVarFp.paymentRecordsGet(pageSize, cursor, ids, integrationId, paymentSystemId, beforeDate, afterDate, orderId, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for paymentRecordPost operation in PaymentRecordsApi.
 * @export
 * @interface PaymentRecordsApiPaymentRecordPostRequest
 */
export interface PaymentRecordsApiPaymentRecordPostRequest {
    /**
     * 
     * @type {PaymentRecordPostRequest}
     * @memberof PaymentRecordsApiPaymentRecordPost
     */
    readonly paymentRecordPostRequest?: PaymentRecordPostRequest
}

/**
 * Request parameters for paymentRecordsGet operation in PaymentRecordsApi.
 * @export
 * @interface PaymentRecordsApiPaymentRecordsGetRequest
 */
export interface PaymentRecordsApiPaymentRecordsGetRequest {
    /**
     * Number of items to retreive
     * @type {number}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly pageSize?: number

    /**
     * Cursor to retreive items. It is the ID before which you want to retrieve the orders
     * @type {string}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly cursor?: string

    /**
     * Fetch payment records of specified transaction ids
     * @type {Array<string>}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly ids?: Array<string>

    /**
     * Fetch payment records of specified integration ids
     * @type {Array<string>}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly integrationId?: Array<string>

    /**
     * Fetch payment records of specified category
     * @type {string}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly paymentSystemId?: string

    /**
     * Fetch payment records before this data
     * @type {string}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly beforeDate?: string

    /**
     * Fetch payment records after this data
     * @type {string}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly afterDate?: string

    /**
     * Fetch payment records by orderId
     * @type {string}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly orderId?: string

    /**
     * Fetch payment records with status
     * @type {'completed' | 'pending' | 'cancelled'}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly status?: 'completed' | 'pending' | 'cancelled'
}

/**
 * PaymentRecordsApi - object-oriented interface
 * @export
 * @class PaymentRecordsApi
 * @extends {BaseAPI}
 */
export class PaymentRecordsApi extends BaseAPI {
    /**
     * 
     * @param {PaymentRecordsApiPaymentRecordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRecordsApi
     */
    public paymentRecordPost(requestParameters: PaymentRecordsApiPaymentRecordPostRequest = {}, options?: AxiosRequestConfig) {
        return PaymentRecordsApiFp(this.configuration).paymentRecordPost(requestParameters.paymentRecordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PaymentRecordsApiPaymentRecordsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRecordsApi
     */
    public paymentRecordsGet(requestParameters: PaymentRecordsApiPaymentRecordsGetRequest = {}, options?: AxiosRequestConfig) {
        return PaymentRecordsApiFp(this.configuration).paymentRecordsGet(requestParameters.pageSize, requestParameters.cursor, requestParameters.ids, requestParameters.integrationId, requestParameters.paymentSystemId, requestParameters.beforeDate, requestParameters.afterDate, requestParameters.orderId, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentSystemsApi - axios parameter creator
 * @export
 */
export const PaymentSystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get available payment systems
         * @param {string} [country] Fetch Payment Systems from a particular country
         * @param {string} [q] Fetch the payment integrations matching string
         * @param {boolean} [isInstalled] Fetch only installed integration if true
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsGet: async (country?: string, q?: string, isInstalled?: boolean, isEnabled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_GET"], configuration)

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (isInstalled !== undefined) {
                localVarQueryParameter['isInstalled'] = isInstalled;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSystemsApi - functional programming interface
 * @export
 */
export const PaymentSystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentSystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get available payment systems
         * @param {string} [country] Fetch Payment Systems from a particular country
         * @param {string} [q] Fetch the payment integrations matching string
         * @param {boolean} [isInstalled] Fetch only installed integration if true
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentSystemsGet(country?: string, q?: string, isInstalled?: boolean, isEnabled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSystemsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentSystemsGet(country, q, isInstalled, isEnabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentSystemsApi - factory interface
 * @export
 */
export const PaymentSystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentSystemsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get available payment systems
         * @param {string} [country] Fetch Payment Systems from a particular country
         * @param {string} [q] Fetch the payment integrations matching string
         * @param {boolean} [isInstalled] Fetch only installed integration if true
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsGet(country?: string, q?: string, isInstalled?: boolean, isEnabled?: boolean, options?: any): AxiosPromise<PaymentSystemsGet200Response> {
            return localVarFp.paymentSystemsGet(country, q, isInstalled, isEnabled, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for paymentSystemsGet operation in PaymentSystemsApi.
 * @export
 * @interface PaymentSystemsApiPaymentSystemsGetRequest
 */
export interface PaymentSystemsApiPaymentSystemsGetRequest {
    /**
     * Fetch Payment Systems from a particular country
     * @type {string}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly country?: string

    /**
     * Fetch the payment integrations matching string
     * @type {string}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly q?: string

    /**
     * Fetch only installed integration if true
     * @type {boolean}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly isInstalled?: boolean

    /**
     * Fetch only enabled integrations if true
     * @type {boolean}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly isEnabled?: boolean
}

/**
 * PaymentSystemsApi - object-oriented interface
 * @export
 * @class PaymentSystemsApi
 * @extends {BaseAPI}
 */
export class PaymentSystemsApi extends BaseAPI {
    /**
     * 
     * @summary Get available payment systems
     * @param {PaymentSystemsApiPaymentSystemsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemsApi
     */
    public paymentSystemsGet(requestParameters: PaymentSystemsApiPaymentSystemsGetRequest = {}, options?: AxiosRequestConfig) {
        return PaymentSystemsApiFp(this.configuration).paymentSystemsGet(requestParameters.country, requestParameters.q, requestParameters.isInstalled, requestParameters.isEnabled, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Removes the specified service from the list
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('servicesDelete', 'id', id)
            const localVarPath = `/services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all supported scraper services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost: async (postServiceModel?: PostServiceModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postServiceModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesReload: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Removes the specified service from the list
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all supported scraper services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Services>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesPost(postServiceModel?: PostServiceModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesPost(postServiceModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesReload(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesReload(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Removes the specified service from the list
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.servicesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all supported scraper services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet(options?: any): AxiosPromise<Services> {
            return localVarFp.servicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost(postServiceModel?: PostServiceModel, options?: any): AxiosPromise<void> {
            return localVarFp.servicesPost(postServiceModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesReload(options?: any): AxiosPromise<void> {
            return localVarFp.servicesReload(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for servicesDelete operation in ServicesApi.
 * @export
 * @interface ServicesApiServicesDeleteRequest
 */
export interface ServicesApiServicesDeleteRequest {
    /**
     * ID of service to remove
     * @type {string}
     * @memberof ServicesApiServicesDelete
     */
    readonly id: string
}

/**
 * Request parameters for servicesPost operation in ServicesApi.
 * @export
 * @interface ServicesApiServicesPostRequest
 */
export interface ServicesApiServicesPostRequest {
    /**
     * 
     * @type {PostServiceModel}
     * @memberof ServicesApiServicesPost
     */
    readonly postServiceModel?: PostServiceModel
}

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * 
     * @summary Removes the specified service from the list
     * @param {ServicesApiServicesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesDelete(requestParameters: ServicesApiServicesDeleteRequest, options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all supported scraper services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesGet(options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a new service to the list
     * @param {ServicesApiServicesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesPost(requestParameters: ServicesApiServicesPostRequest = {}, options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesPost(requestParameters.postServiceModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reload all service schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesReload(options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesReload(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackingProductsApi - axios parameter creator
 * @export
 */
export const TrackingProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get products of the tracking
         * @param {number} trackingId Fetch products of the specified trackingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (trackingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('productsGet', 'trackingId', trackingId)
            const localVarPath = `/products/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackingProductsApi - functional programming interface
 * @export
 */
export const TrackingProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackingProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get products of the tracking
         * @param {number} trackingId Fetch products of the specified trackingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(trackingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProductsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(trackingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackingProductsApi - factory interface
 * @export
 */
export const TrackingProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackingProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get products of the tracking
         * @param {number} trackingId Fetch products of the specified trackingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(trackingId: number, options?: any): AxiosPromise<ServiceProductsData> {
            return localVarFp.productsGet(trackingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsGet operation in TrackingProductsApi.
 * @export
 * @interface TrackingProductsApiProductsGetRequest
 */
export interface TrackingProductsApiProductsGetRequest {
    /**
     * Fetch products of the specified trackingId
     * @type {number}
     * @memberof TrackingProductsApiProductsGet
     */
    readonly trackingId: number
}

/**
 * TrackingProductsApi - object-oriented interface
 * @export
 * @class TrackingProductsApi
 * @extends {BaseAPI}
 */
export class TrackingProductsApi extends BaseAPI {
    /**
     * 
     * @summary Get products of the tracking
     * @param {TrackingProductsApiProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingProductsApi
     */
    public productsGet(requestParameters: TrackingProductsApiProductsGetRequest, options?: AxiosRequestConfig) {
        return TrackingProductsApiFp(this.configuration).productsGet(requestParameters.trackingId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackingsApi - axios parameter creator
 * @export
 */
export const TrackingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the data/order history
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {number} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet: async (trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: number, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)

            if (trackingId !== undefined) {
                localVarQueryParameter['trackingId'] = trackingId;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (excludeTests !== undefined) {
                localVarQueryParameter['excludeTests'] = excludeTests;
            }

            if (includeNullTriggers !== undefined) {
                localVarQueryParameter['includeNullTriggers'] = includeNullTriggers;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingDelete: async (trackingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('trackingDelete', 'trackingId', trackingId)
            const localVarPath = `/tracking/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all services currently tracked by a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPatch: async (trackingId: number, updateTracking?: UpdateTracking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('trackingPatch', 'trackingId', trackingId)
            const localVarPath = `/tracking/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTracking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPost: async (postTracking?: PostTracking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTracking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingUpdateErrorState: async (secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('trackingUpdateErrorState', 'secretId', secretId)
            const localVarPath = `/tracking/{secretId}/update-error-state`
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTrackingErrorState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTest: async (trackingId: number, triggerId: number, recipientPhoneNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('triggerTest', 'trackingId', trackingId)
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('triggerTest', 'triggerId', triggerId)
            const localVarPath = `/tracking/{trackingId}/{triggerId}/test`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)))
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)

            if (recipientPhoneNumber !== undefined) {
                localVarQueryParameter['recipientPhoneNumber'] = recipientPhoneNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackingsApi - functional programming interface
 * @export
 */
export const TrackingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the data/order history
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {number} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataGet(trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: number, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataGet(trackingId, phoneNumber, triggerId, pageSize, cursor, q, excludeTests, includeNullTriggers, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingDelete(trackingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingDelete(trackingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all services currently tracked by a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackServices>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingPatch(trackingId: number, updateTracking?: UpdateTracking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingPatch(trackingId, updateTracking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingPost(postTracking?: PostTracking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingPost(postTracking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingUpdateErrorState(secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingUpdateErrorState(secretId, updateTrackingErrorState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerTest(trackingId: number, triggerId: number, recipientPhoneNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerTest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerTest(trackingId, triggerId, recipientPhoneNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackingsApi - factory interface
 * @export
 */
export const TrackingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the data/order history
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {number} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet(trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: number, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, returnTotal?: boolean, options?: any): AxiosPromise<DataGet200Response> {
            return localVarFp.dataGet(trackingId, phoneNumber, triggerId, pageSize, cursor, q, excludeTests, includeNullTriggers, returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingDelete(trackingId: number, options?: any): AxiosPromise<void> {
            return localVarFp.trackingDelete(trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all services currently tracked by a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingGet(options?: any): AxiosPromise<TrackServices> {
            return localVarFp.trackingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPatch(trackingId: number, updateTracking?: UpdateTracking, options?: any): AxiosPromise<TrackingPatch200Response> {
            return localVarFp.trackingPatch(trackingId, updateTracking, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPost(postTracking?: PostTracking, options?: any): AxiosPromise<TrackingPost200Response> {
            return localVarFp.trackingPost(postTracking, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingUpdateErrorState(secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options?: any): AxiosPromise<void> {
            return localVarFp.trackingUpdateErrorState(secretId, updateTrackingErrorState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTest(trackingId: number, triggerId: number, recipientPhoneNumber?: string, options?: any): AxiosPromise<TriggerTest200Response> {
            return localVarFp.triggerTest(trackingId, triggerId, recipientPhoneNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataGet operation in TrackingsApi.
 * @export
 * @interface TrackingsApiDataGetRequest
 */
export interface TrackingsApiDataGetRequest {
    /**
     * Fetch orders of the specified trackingId
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly trackingId?: number

    /**
     * Fetch orders sent to the specified phone number
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly phoneNumber?: number

    /**
     * Fetch orders of the specified triggerId
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly triggerId?: number

    /**
     * Number of items to retreive
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly pageSize?: number

    /**
     * Cursor to retreive items. It is the ID before which you want to retrieve the orders
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly cursor?: number

    /**
     * Query to retrieve select orders
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly q?: string

    /**
     * Should tests be excluded
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly excludeTests?: boolean

    /**
     * Should events which did not trigger an EventTrigger be included?
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly includeNullTriggers?: boolean

    /**
     * Should a total of the number of orders returned by the given query be included
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for trackingDelete operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingDeleteRequest
 */
export interface TrackingsApiTrackingDeleteRequest {
    /**
     * The Tracking
     * @type {number}
     * @memberof TrackingsApiTrackingDelete
     */
    readonly trackingId: number
}

/**
 * Request parameters for trackingPatch operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingPatchRequest
 */
export interface TrackingsApiTrackingPatchRequest {
    /**
     * The Tracking
     * @type {number}
     * @memberof TrackingsApiTrackingPatch
     */
    readonly trackingId: number

    /**
     * 
     * @type {UpdateTracking}
     * @memberof TrackingsApiTrackingPatch
     */
    readonly updateTracking?: UpdateTracking
}

/**
 * Request parameters for trackingPost operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingPostRequest
 */
export interface TrackingsApiTrackingPostRequest {
    /**
     * 
     * @type {PostTracking}
     * @memberof TrackingsApiTrackingPost
     */
    readonly postTracking?: PostTracking
}

/**
 * Request parameters for trackingUpdateErrorState operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingUpdateErrorStateRequest
 */
export interface TrackingsApiTrackingUpdateErrorStateRequest {
    /**
     * The secret ID of the tracking made available to the service
     * @type {string}
     * @memberof TrackingsApiTrackingUpdateErrorState
     */
    readonly secretId: string

    /**
     * 
     * @type {UpdateTrackingErrorState}
     * @memberof TrackingsApiTrackingUpdateErrorState
     */
    readonly updateTrackingErrorState?: UpdateTrackingErrorState
}

/**
 * Request parameters for triggerTest operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTriggerTestRequest
 */
export interface TrackingsApiTriggerTestRequest {
    /**
     * The trackingId to test
     * @type {number}
     * @memberof TrackingsApiTriggerTest
     */
    readonly trackingId: number

    /**
     * The triggerId to test
     * @type {number}
     * @memberof TrackingsApiTriggerTest
     */
    readonly triggerId: number

    /**
     * Phone number to send the test to
     * @type {string}
     * @memberof TrackingsApiTriggerTest
     */
    readonly recipientPhoneNumber?: string
}

/**
 * TrackingsApi - object-oriented interface
 * @export
 * @class TrackingsApi
 * @extends {BaseAPI}
 */
export class TrackingsApi extends BaseAPI {
    /**
     * 
     * @summary Get the data/order history
     * @param {TrackingsApiDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public dataGet(requestParameters: TrackingsApiDataGetRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).dataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.triggerId, requestParameters.pageSize, requestParameters.cursor, requestParameters.q, requestParameters.excludeTests, requestParameters.includeNullTriggers, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes the tracking and its associated flowIds from the Database permanently.
     * @summary Stop tracking
     * @param {TrackingsApiTrackingDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingDelete(requestParameters: TrackingsApiTrackingDeleteRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingDelete(requestParameters.trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all services currently tracked by a team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingGet(options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
     * @summary Update events, credentials, notifyUsers or isActive of a tracking
     * @param {TrackingsApiTrackingPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingPatch(requestParameters: TrackingsApiTrackingPatchRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingPatch(requestParameters.trackingId, requestParameters.updateTracking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start tracking of a new service for a team
     * @param {TrackingsApiTrackingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingPost(requestParameters: TrackingsApiTrackingPostRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingPost(requestParameters.postTracking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TrackingsApiTrackingUpdateErrorStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingUpdateErrorState(requestParameters: TrackingsApiTrackingUpdateErrorStateRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingUpdateErrorState(requestParameters.secretId, requestParameters.updateTrackingErrorState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test a trigger
     * @param {TrackingsApiTriggerTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public triggerTest(requestParameters: TrackingsApiTriggerTestRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).triggerTest(requestParameters.trackingId, requestParameters.triggerId, requestParameters.recipientPhoneNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


