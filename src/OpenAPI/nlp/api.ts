const BASE_PATH = "https://api-keywordreply.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Keyword Reply Service
 * Manage Whatsapp automated replies.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface AutocompleteInbox200Response
 */
export interface AutocompleteInbox200Response {
    /**
     * 
     * @type {Array<AutocompleteSuggestion>}
     * @memberof AutocompleteInbox200Response
     */
    'suggestions': Array<AutocompleteSuggestion>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AutocompleteModifier = {
    Longer: 'longer',
    Shorter: 'shorter',
    Formal: 'formal',
    Friendlier: 'friendlier',
    Apologetic: 'apologetic',
    Assertive: 'assertive',
    Clearer: 'clearer',
    Ask: 'ask'
} as const;

export type AutocompleteModifier = typeof AutocompleteModifier[keyof typeof AutocompleteModifier];


/**
 * 
 * @export
 * @interface AutocompleteModify200Response
 */
export interface AutocompleteModify200Response {
    /**
     * Modified text
     * @type {string}
     * @memberof AutocompleteModify200Response
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface AutocompleteModifyRequest
 */
export interface AutocompleteModifyRequest {
    /**
     * 
     * @type {AutocompleteModifyRequestChat}
     * @memberof AutocompleteModifyRequest
     */
    'chat'?: AutocompleteModifyRequestChat;
    /**
     * Text to be modified
     * @type {string}
     * @memberof AutocompleteModifyRequest
     */
    'text': string;
}
/**
 * Provide chat as context for the modifier
 * @export
 * @interface AutocompleteModifyRequestChat
 */
export interface AutocompleteModifyRequestChat {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteModifyRequestChat
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteModifyRequestChat
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AutocompleteSuggestion
 */
export interface AutocompleteSuggestion {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteSuggestion
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface Chatbot
 */
export interface Chatbot {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'id': string;
    /**
     * Name of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'name': string;
    /**
     * 
     * @type {Array<StoredLinks>}
     * @memberof Chatbot
     */
    'storedLinks'?: Array<StoredLinks>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chatbot
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chatbot
     */
    'updatedAt': string;
    /**
     * Current training status of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'trainingStatus': ChatbotTrainingStatusEnum;
    /**
     * Fallback message of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'fallbackMessage'?: string;
    /**
     * Prompt message of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'prompt'?: string;
    /**
     * Name of the member to assign to the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'assignedMember'?: string | null;
    /**
     * Name of the channel to deploy to the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'deployedAccount'?: string | null;
    /**
     * Training Progress
     * @type {number}
     * @memberof Chatbot
     */
    'trainingProgress'?: number;
    /**
     * 
     * @type {PendingJob}
     * @memberof Chatbot
     */
    'pendingJob'?: PendingJob;
}

export const ChatbotTrainingStatusEnum = {
    Idle: 'idle',
    InProgress: 'inProgress',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type ChatbotTrainingStatusEnum = typeof ChatbotTrainingStatusEnum[keyof typeof ChatbotTrainingStatusEnum];

/**
 * 
 * @export
 * @interface ChatbotMessageRequest
 */
export interface ChatbotMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotMessageRequest
     */
    'message': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotMessageRequest
     */
    'conversationHistory': Array<string>;
}
/**
 * 
 * @export
 * @interface ChatbotMessageResponse
 */
export interface ChatbotMessageResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotMessageResponse
     */
    'message': Array<string>;
}
/**
 * 
 * @export
 * @interface CrawledLinksResponse
 */
export interface CrawledLinksResponse {
    /**
     * ID of the crawling job
     * @type {string}
     * @memberof CrawledLinksResponse
     */
    'crawlingJobId': string;
    /**
     * 
     * @type {Array<StoredLinks>}
     * @memberof CrawledLinksResponse
     */
    'links': Array<StoredLinks>;
}
/**
 * 
 * @export
 * @interface CreateChatbotRequest
 */
export interface CreateChatbotRequest {
    /**
     * Name of the chatbot
     * @type {string}
     * @memberof CreateChatbotRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateChatbotResponse
 */
export interface CreateChatbotResponse {
    /**
     * 
     * @type {Chatbot}
     * @memberof CreateChatbotResponse
     */
    'chatbot': Chatbot;
}
/**
 * 
 * @export
 * @interface DeleteTrainingLinksRequest
 */
export interface DeleteTrainingLinksRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteTrainingLinksRequest
     */
    'links': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteTriggers200Response
 */
export interface DeleteTriggers200Response {
    /**
     * 
     * @type {number}
     * @memberof DeleteTriggers200Response
     */
    'affected'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof DeleteTriggers200Response
     */
    'raw'?: Array<object>;
}
/**
 * 
 * @export
 * @interface ExecutionFrame
 */
export interface ExecutionFrame {
    /**
     * 
     * @type {string}
     * @memberof ExecutionFrame
     */
    'day'?: ExecutionFrameDayEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionFrame
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionFrame
     */
    'endTime': string;
}

export const ExecutionFrameDayEnum = {
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday',
    Sunday: 'Sunday'
} as const;

export type ExecutionFrameDayEnum = typeof ExecutionFrameDayEnum[keyof typeof ExecutionFrameDayEnum];

/**
 * 
 * @export
 * @interface GetChatbotsResponse
 */
export interface GetChatbotsResponse {
    /**
     * 
     * @type {Array<Chatbot>}
     * @memberof GetChatbotsResponse
     */
    'chatbots': Array<Chatbot>;
}
/**
 * 
 * @export
 * @interface GetCrawlingStatusResponse
 */
export interface GetCrawlingStatusResponse {
    /**
     * ID of the crawling job
     * @type {string}
     * @memberof GetCrawlingStatusResponse
     */
    'crawlingJobId': string;
    /**
     * crawling status
     * @type {string}
     * @memberof GetCrawlingStatusResponse
     */
    'status': GetCrawlingStatusResponseStatusEnum;
    /**
     * crawling progress
     * @type {number}
     * @memberof GetCrawlingStatusResponse
     */
    'progress': number;
}

export const GetCrawlingStatusResponseStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type GetCrawlingStatusResponseStatusEnum = typeof GetCrawlingStatusResponseStatusEnum[keyof typeof GetCrawlingStatusResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetExecutionRecord200Response
 */
export interface GetExecutionRecord200Response {
    /**
     * 
     * @type {Array<KeywordActionExecutionRecord>}
     * @memberof GetExecutionRecord200Response
     */
    'logs'?: Array<KeywordActionExecutionRecord>;
    /**
     * 
     * @type {number}
     * @memberof GetExecutionRecord200Response
     */
    'nextPageCursor'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetExecutionRecord200Response
     */
    'totalTriggered'?: number;
}
/**
 * 
 * @export
 * @interface GetTriggers200Response
 */
export interface GetTriggers200Response {
    /**
     * 
     * @type {Array<KeywordBasedAction>}
     * @memberof GetTriggers200Response
     */
    'triggers'?: Array<KeywordBasedAction>;
    /**
     * 
     * @type {number}
     * @memberof GetTriggers200Response
     */
    'nextPageCursor'?: number;
    /**
     * total keywords present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof GetTriggers200Response
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    'text'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Keyword
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface KeywordActionCreateRequestObj
 */
export interface KeywordActionCreateRequestObj {
    /**
     * Status of reply service
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'enabled'?: boolean;
    /**
     * Accounts the keywords will trigger for
     * @type {Array<string>}
     * @memberof KeywordActionCreateRequestObj
     */
    'accountIds'?: Array<string>;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Toggles whether the keyword reply will trigger for group chats
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'enableOnGroupChats'?: boolean;
    /**
     * Only on the first message in a chat
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'onlyOnFirstMessage'?: boolean;
    /**
     * 
     * @type {TriggerType}
     * @memberof KeywordActionCreateRequestObj
     */
    'triggerType': TriggerType;
    /**
     * Unique triggering keywords
     * @type {Array<Keyword>}
     * @memberof KeywordActionCreateRequestObj
     */
    'keywords': Array<Keyword>;
    /**
     * Flow ids to be triggered
     * @type {Array<string>}
     * @memberof KeywordActionCreateRequestObj
     */
    'flowIds': Array<string>;
    /**
     * Timespan before the keyword can be triggered again, measured in seconds
     * @type {number}
     * @memberof KeywordActionCreateRequestObj
     */
    'delay'?: number;
    /**
     * 
     * @type {Array<ExecutionFrame>}
     * @memberof KeywordActionCreateRequestObj
     */
    'executionFrames'?: Array<ExecutionFrame>;
}
/**
 * 
 * @export
 * @interface KeywordActionEditRequestObj
 */
export interface KeywordActionEditRequestObj {
    /**
     * Keyword Id (auto incrementing)
     * @type {number}
     * @memberof KeywordActionEditRequestObj
     */
    'id': number;
    /**
     * Accounts the keywords will trigger for
     * @type {Array<string>}
     * @memberof KeywordActionEditRequestObj
     */
    'accountIds'?: Array<string>;
    /**
     * Status of reply service
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'enabled'?: boolean;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Only on the first message in a chat
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'onlyOnFirstMessage'?: boolean;
    /**
     * Toggles whether the keyword reply will trigger for group chats
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'enableOnGroupChats'?: boolean;
    /**
     * 
     * @type {TriggerType}
     * @memberof KeywordActionEditRequestObj
     */
    'triggerType'?: TriggerType;
    /**
     * Unique triggering keywords
     * @type {Array<Keyword>}
     * @memberof KeywordActionEditRequestObj
     */
    'keywords'?: Array<Keyword>;
    /**
     * Flow ids to be triggered
     * @type {Array<string>}
     * @memberof KeywordActionEditRequestObj
     */
    'flowIds'?: Array<string>;
    /**
     * Timespan before the keyword can be triggered again, measured in seconds
     * @type {number}
     * @memberof KeywordActionEditRequestObj
     */
    'delay'?: number;
    /**
     * 
     * @type {Array<ExecutionFrame>}
     * @memberof KeywordActionEditRequestObj
     */
    'executionFrames'?: Array<ExecutionFrame>;
}
/**
 * 
 * @export
 * @interface KeywordActionExecutionRecord
 */
export interface KeywordActionExecutionRecord {
    /**
     * Keyword Id (auto incrementing)
     * @type {number}
     * @memberof KeywordActionExecutionRecord
     */
    'id': number;
    /**
     * Triggering chatId (jid)
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'chatId': string;
    /**
     * Incoming message body
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'text': string;
    /**
     * FlowId to be triggered
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'flowId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface KeywordBasedAction
 */
export interface KeywordBasedAction {
    /**
     * Keyword Id (auto incrementing)
     * @type {number}
     * @memberof KeywordBasedAction
     */
    'id': number;
    /**
     * Team the keyword belongs to
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'teamId': string;
    /**
     * Accounts the keywords will trigger for
     * @type {Array<string>}
     * @memberof KeywordBasedAction
     */
    'accountIds'?: Array<string>;
    /**
     * Status of reply service
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'enabled': boolean;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Toggles whether the keyword reply will trigger for group chats
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'enableOnGroupChats'?: boolean;
    /**
     * Only on the first message in a chat
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'onlyOnFirstMessage'?: boolean;
    /**
     * 
     * @type {TriggerType}
     * @memberof KeywordBasedAction
     */
    'triggerType': TriggerType;
    /**
     * Unique triggering keywords
     * @type {Array<Keyword>}
     * @memberof KeywordBasedAction
     */
    'keywords': Array<Keyword>;
    /**
     * Flow ids to be triggered
     * @type {Array<string>}
     * @memberof KeywordBasedAction
     */
    'flowIds'?: Array<string>;
    /**
     * Timespan before the keyword can be triggered again, measured in seconds
     * @type {number}
     * @memberof KeywordBasedAction
     */
    'delay'?: number;
    /**
     * 
     * @type {Array<ExecutionFrame>}
     * @memberof KeywordBasedAction
     */
    'executionFrames'?: Array<ExecutionFrame>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface PendingJob
 */
export interface PendingJob {
    /**
     * 
     * @type {string}
     * @memberof PendingJob
     */
    'jobId': string;
    /**
     * 
     * @type {string}
     * @memberof PendingJob
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface PostCrawlingRequest
 */
export interface PostCrawlingRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof PostCrawlingRequest
     */
    'links': Array<string>;
}
/**
 * 
 * @export
 * @interface PostCrawlingResponse
 */
export interface PostCrawlingResponse {
    /**
     * Name of the chatbot
     * @type {string}
     * @memberof PostCrawlingResponse
     */
    'name': string;
    /**
     * ID of the crawling job
     * @type {string}
     * @memberof PostCrawlingResponse
     */
    'crawlingJobId': string;
}
/**
 * List of stored data, document along with id , link and createdAt timestamp
 * @export
 * @interface StoredLinks
 */
export interface StoredLinks {
    /**
     * URL of the stored data
     * @type {string}
     * @memberof StoredLinks
     */
    'link': string;
    /**
     * ID of the document
     * @type {string}
     * @memberof StoredLinks
     */
    'documentId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof StoredLinks
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StoredLinks
     */
    'fileName'?: string | null;
}
/**
 * 
 * @export
 * @interface TrainingStatusResponse
 */
export interface TrainingStatusResponse {
    /**
     * Status of training
     * @type {string}
     * @memberof TrainingStatusResponse
     */
    'status': TrainingStatusResponseStatusEnum;
    /**
     * Progress of training
     * @type {number}
     * @memberof TrainingStatusResponse
     */
    'progress': number;
}

export const TrainingStatusResponseStatusEnum = {
    Idle: 'idle',
    InProgress: 'inProgress',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type TrainingStatusResponseStatusEnum = typeof TrainingStatusResponseStatusEnum[keyof typeof TrainingStatusResponseStatusEnum];

/**
 * 
 * @export
 * @interface TranscribePost200Response
 */
export interface TranscribePost200Response {
    /**
     * The transcription of the audio
     * @type {string}
     * @memberof TranscribePost200Response
     */
    'transcription': string;
}
/**
 * 
 * @export
 * @interface TranscribePostRequest
 */
export interface TranscribePostRequest {
    /**
     * The URL of the audio to transcribe
     * @type {string}
     * @memberof TranscribePostRequest
     */
    'audioUrl': string;
}
/**
 * Type of trigger
 * @export
 * @enum {string}
 */

export const TriggerType = {
    Contains: 'contains',
    ContainsPhrase: 'containsPhrase',
    StartsWith: 'startsWith',
    KeywordIs: 'keywordIs',
    DefaultReply: 'defaultReply'
} as const;

export type TriggerType = typeof TriggerType[keyof typeof TriggerType];


/**
 * 
 * @export
 * @interface UpdateChatbotRequest
 */
export interface UpdateChatbotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'id': string;
    /**
     * Name of the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<StoredLinks>}
     * @memberof UpdateChatbotRequest
     */
    'storedLinks'?: Array<StoredLinks>;
    /**
     * Fallback message of the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'fallbackMessage'?: string;
    /**
     * Prompt message of the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'prompt'?: string;
    /**
     * Name of the member to assign to the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'assignedMember'?: string;
    /**
     * Name of the channel to deploy to the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'deployedAccount'?: string;
}

/**
 * AudioTranscriptionApi - axios parameter creator
 * @export
 */
export const AudioTranscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accepts an audio URL and converts it to text using AWS Transcribe. Supports both streaming and batch processing.
         * @summary Convert audio URL to text
         * @param {TranscribePostRequest} transcribePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribePost: async (transcribePostRequest: TranscribePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transcribePostRequest' is not null or undefined
            assertParamExists('transcribePost', 'transcribePostRequest', transcribePostRequest)
            const localVarPath = `/transcribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transcribePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioTranscriptionApi - functional programming interface
 * @export
 */
export const AudioTranscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudioTranscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Accepts an audio URL and converts it to text using AWS Transcribe. Supports both streaming and batch processing.
         * @summary Convert audio URL to text
         * @param {TranscribePostRequest} transcribePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcribePost(transcribePostRequest: TranscribePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscribePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcribePost(transcribePostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AudioTranscriptionApi - factory interface
 * @export
 */
export const AudioTranscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudioTranscriptionApiFp(configuration)
    return {
        /**
         * Accepts an audio URL and converts it to text using AWS Transcribe. Supports both streaming and batch processing.
         * @summary Convert audio URL to text
         * @param {TranscribePostRequest} transcribePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribePost(transcribePostRequest: TranscribePostRequest, options?: any): AxiosPromise<TranscribePost200Response> {
            return localVarFp.transcribePost(transcribePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for transcribePost operation in AudioTranscriptionApi.
 * @export
 * @interface AudioTranscriptionApiTranscribePostRequest
 */
export interface AudioTranscriptionApiTranscribePostRequest {
    /**
     * 
     * @type {TranscribePostRequest}
     * @memberof AudioTranscriptionApiTranscribePost
     */
    readonly transcribePostRequest: TranscribePostRequest
}

/**
 * AudioTranscriptionApi - object-oriented interface
 * @export
 * @class AudioTranscriptionApi
 * @extends {BaseAPI}
 */
export class AudioTranscriptionApi extends BaseAPI {
    /**
     * Accepts an audio URL and converts it to text using AWS Transcribe. Supports both streaming and batch processing.
     * @summary Convert audio URL to text
     * @param {AudioTranscriptionApiTranscribePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioTranscriptionApi
     */
    public transcribePost(requestParameters: AudioTranscriptionApiTranscribePostRequest, options?: AxiosRequestConfig) {
        return AudioTranscriptionApiFp(this.configuration).transcribePost(requestParameters.transcribePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutocompleteApi - axios parameter creator
 * @export
 */
export const AutocompleteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteInbox: async (accountId: string, chatId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('autocompleteInbox', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('autocompleteInbox', 'chatId', chatId)
            const localVarPath = `/autocomplete/inbox/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteModify: async (modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modifier' is not null or undefined
            assertParamExists('autocompleteModify', 'modifier', modifier)
            // verify required parameter 'autocompleteModifyRequest' is not null or undefined
            assertParamExists('autocompleteModify', 'autocompleteModifyRequest', autocompleteModifyRequest)
            const localVarPath = `/autocomplete/modify/{modifier}`
                .replace(`{${"modifier"}}`, encodeURIComponent(String(modifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autocompleteModifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutocompleteApi - functional programming interface
 * @export
 */
export const AutocompleteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutocompleteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteInbox(accountId: string, chatId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutocompleteInbox200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteInbox(accountId, chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteModify(modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutocompleteModify200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteModify(modifier, autocompleteModifyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutocompleteApi - factory interface
 * @export
 */
export const AutocompleteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutocompleteApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteInbox(accountId: string, chatId: string, options?: any): AxiosPromise<AutocompleteInbox200Response> {
            return localVarFp.autocompleteInbox(accountId, chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteModify(modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options?: any): AxiosPromise<AutocompleteModify200Response> {
            return localVarFp.autocompleteModify(modifier, autocompleteModifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autocompleteInbox operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiAutocompleteInboxRequest
 */
export interface AutocompleteApiAutocompleteInboxRequest {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiAutocompleteInbox
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiAutocompleteInbox
     */
    readonly chatId: string
}

/**
 * Request parameters for autocompleteModify operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiAutocompleteModifyRequest
 */
export interface AutocompleteApiAutocompleteModifyRequest {
    /**
     * 
     * @type {AutocompleteModifier}
     * @memberof AutocompleteApiAutocompleteModify
     */
    readonly modifier: AutocompleteModifier

    /**
     * 
     * @type {AutocompleteModifyRequest}
     * @memberof AutocompleteApiAutocompleteModify
     */
    readonly autocompleteModifyRequest: AutocompleteModifyRequest
}

/**
 * AutocompleteApi - object-oriented interface
 * @export
 * @class AutocompleteApi
 * @extends {BaseAPI}
 */
export class AutocompleteApi extends BaseAPI {
    /**
     * 
     * @summary Returns autocomplete suggestions for a chat
     * @param {AutocompleteApiAutocompleteInboxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public autocompleteInbox(requestParameters: AutocompleteApiAutocompleteInboxRequest, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).autocompleteInbox(requestParameters.accountId, requestParameters.chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply some modification to the given text
     * @param {AutocompleteApiAutocompleteModifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public autocompleteModify(requestParameters: AutocompleteApiAutocompleteModifyRequest, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).autocompleteModify(requestParameters.modifier, requestParameters.autocompleteModifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChatbotApi - axios parameter creator
 * @export
 */
export const ChatbotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Extract links from a website
         * @param {string} id ID of the chatbot
         * @param {PostCrawlingRequest} [postCrawlingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlLinks: async (id: string, postCrawlingRequest?: PostCrawlingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crawlLinks', 'id', id)
            const localVarPath = `/chatbot/{id}/crawling`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCrawlingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To know the status of crawling
         * @param {string} crawlingJobId ID of the crawling job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlStatus: async (crawlingJobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'crawlingJobId' is not null or undefined
            assertParamExists('crawlStatus', 'crawlingJobId', crawlingJobId)
            const localVarPath = `/chatbot/crawling/status/{crawlingJobId}`
                .replace(`{${"crawlingJobId"}}`, encodeURIComponent(String(crawlingJobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a chatbot
         * @param {CreateChatbotRequest} [createChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot: async (createChatbotRequest?: CreateChatbotRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chatbots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChatbotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a chatbot
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBot', 'id', id)
            const localVarPath = `/chatbots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s chatbots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chatbots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary To get the carwled links
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawledLinks: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCrawledLinks', 'id', id)
            const localVarPath = `/chatbot/{id}/crawledLinks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send message to the chatbot
         * @param {string} id ID of the chatbot
         * @param {ChatbotMessageRequest} [chatbotMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageBot: async (id: string, chatbotMessageRequest?: ChatbotMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messageBot', 'id', id)
            const localVarPath = `/chatbot/{id}/message`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatbotMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check the status of training
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTrainStatus: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refreshTrainStatus', 'id', id)
            const localVarPath = `/chatbot/{id}/train`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post links to train
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLinks: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainLinks', 'id', id)
            const localVarPath = `/chatbot/{id}/train`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update chatbot\'s preferences
         * @param {string} id ID of the chatbot
         * @param {UpdateChatbotRequest} [updateChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotPreferences: async (id: string, updateChatbotRequest?: UpdateChatbotRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBotPreferences', 'id', id)
            const localVarPath = `/chatbots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChatbotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatbotApi - functional programming interface
 * @export
 */
export const ChatbotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatbotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Extract links from a website
         * @param {string} id ID of the chatbot
         * @param {PostCrawlingRequest} [postCrawlingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlLinks(id: string, postCrawlingRequest?: PostCrawlingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCrawlingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlLinks(id, postCrawlingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To know the status of crawling
         * @param {string} crawlingJobId ID of the crawling job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crawlStatus(crawlingJobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCrawlingStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crawlStatus(crawlingJobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a chatbot
         * @param {CreateChatbotRequest} [createChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBot(createChatbotRequest?: CreateChatbotRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateChatbotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBot(createChatbotRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete a chatbot
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBot(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBot(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user\'s chatbots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBots(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatbotsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBots(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary To get the carwled links
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrawledLinks(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrawledLinksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrawledLinks(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send message to the chatbot
         * @param {string} id ID of the chatbot
         * @param {ChatbotMessageRequest} [chatbotMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageBot(id: string, chatbotMessageRequest?: ChatbotMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatbotMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageBot(id, chatbotMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check the status of training
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshTrainStatus(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainingStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshTrainStatus(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post links to train
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLinks(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLinks(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update chatbot\'s preferences
         * @param {string} id ID of the chatbot
         * @param {UpdateChatbotRequest} [updateChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBotPreferences(id: string, updateChatbotRequest?: UpdateChatbotRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBotPreferences(id, updateChatbotRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatbotApi - factory interface
 * @export
 */
export const ChatbotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatbotApiFp(configuration)
    return {
        /**
         * 
         * @summary Extract links from a website
         * @param {string} id ID of the chatbot
         * @param {PostCrawlingRequest} [postCrawlingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlLinks(id: string, postCrawlingRequest?: PostCrawlingRequest, options?: any): AxiosPromise<PostCrawlingResponse> {
            return localVarFp.crawlLinks(id, postCrawlingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To know the status of crawling
         * @param {string} crawlingJobId ID of the crawling job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crawlStatus(crawlingJobId: string, options?: any): AxiosPromise<GetCrawlingStatusResponse> {
            return localVarFp.crawlStatus(crawlingJobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a chatbot
         * @param {CreateChatbotRequest} [createChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot(createChatbotRequest?: CreateChatbotRequest, options?: any): AxiosPromise<CreateChatbotResponse> {
            return localVarFp.createBot(createChatbotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete a chatbot
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s chatbots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(options?: any): AxiosPromise<GetChatbotsResponse> {
            return localVarFp.getBots(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary To get the carwled links
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrawledLinks(id: string, options?: any): AxiosPromise<CrawledLinksResponse> {
            return localVarFp.getCrawledLinks(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send message to the chatbot
         * @param {string} id ID of the chatbot
         * @param {ChatbotMessageRequest} [chatbotMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageBot(id: string, chatbotMessageRequest?: ChatbotMessageRequest, options?: any): AxiosPromise<ChatbotMessageResponse> {
            return localVarFp.messageBot(id, chatbotMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check the status of training
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTrainStatus(id: string, options?: any): AxiosPromise<TrainingStatusResponse> {
            return localVarFp.refreshTrainStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post links to train
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLinks(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.trainLinks(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update chatbot\'s preferences
         * @param {string} id ID of the chatbot
         * @param {UpdateChatbotRequest} [updateChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotPreferences(id: string, updateChatbotRequest?: UpdateChatbotRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateBotPreferences(id, updateChatbotRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for crawlLinks operation in ChatbotApi.
 * @export
 * @interface ChatbotApiCrawlLinksRequest
 */
export interface ChatbotApiCrawlLinksRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiCrawlLinks
     */
    readonly id: string

    /**
     * 
     * @type {PostCrawlingRequest}
     * @memberof ChatbotApiCrawlLinks
     */
    readonly postCrawlingRequest?: PostCrawlingRequest
}

/**
 * Request parameters for crawlStatus operation in ChatbotApi.
 * @export
 * @interface ChatbotApiCrawlStatusRequest
 */
export interface ChatbotApiCrawlStatusRequest {
    /**
     * ID of the crawling job
     * @type {string}
     * @memberof ChatbotApiCrawlStatus
     */
    readonly crawlingJobId: string
}

/**
 * Request parameters for createBot operation in ChatbotApi.
 * @export
 * @interface ChatbotApiCreateBotRequest
 */
export interface ChatbotApiCreateBotRequest {
    /**
     * 
     * @type {CreateChatbotRequest}
     * @memberof ChatbotApiCreateBot
     */
    readonly createChatbotRequest?: CreateChatbotRequest
}

/**
 * Request parameters for deleteBot operation in ChatbotApi.
 * @export
 * @interface ChatbotApiDeleteBotRequest
 */
export interface ChatbotApiDeleteBotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiDeleteBot
     */
    readonly id: string
}

/**
 * Request parameters for getCrawledLinks operation in ChatbotApi.
 * @export
 * @interface ChatbotApiGetCrawledLinksRequest
 */
export interface ChatbotApiGetCrawledLinksRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiGetCrawledLinks
     */
    readonly id: string
}

/**
 * Request parameters for messageBot operation in ChatbotApi.
 * @export
 * @interface ChatbotApiMessageBotRequest
 */
export interface ChatbotApiMessageBotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiMessageBot
     */
    readonly id: string

    /**
     * 
     * @type {ChatbotMessageRequest}
     * @memberof ChatbotApiMessageBot
     */
    readonly chatbotMessageRequest?: ChatbotMessageRequest
}

/**
 * Request parameters for refreshTrainStatus operation in ChatbotApi.
 * @export
 * @interface ChatbotApiRefreshTrainStatusRequest
 */
export interface ChatbotApiRefreshTrainStatusRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiRefreshTrainStatus
     */
    readonly id: string
}

/**
 * Request parameters for trainLinks operation in ChatbotApi.
 * @export
 * @interface ChatbotApiTrainLinksRequest
 */
export interface ChatbotApiTrainLinksRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiTrainLinks
     */
    readonly id: string
}

/**
 * Request parameters for updateBotPreferences operation in ChatbotApi.
 * @export
 * @interface ChatbotApiUpdateBotPreferencesRequest
 */
export interface ChatbotApiUpdateBotPreferencesRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiUpdateBotPreferences
     */
    readonly id: string

    /**
     * 
     * @type {UpdateChatbotRequest}
     * @memberof ChatbotApiUpdateBotPreferences
     */
    readonly updateChatbotRequest?: UpdateChatbotRequest
}

/**
 * ChatbotApi - object-oriented interface
 * @export
 * @class ChatbotApi
 * @extends {BaseAPI}
 */
export class ChatbotApi extends BaseAPI {
    /**
     * 
     * @summary Extract links from a website
     * @param {ChatbotApiCrawlLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public crawlLinks(requestParameters: ChatbotApiCrawlLinksRequest, options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).crawlLinks(requestParameters.id, requestParameters.postCrawlingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To know the status of crawling
     * @param {ChatbotApiCrawlStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public crawlStatus(requestParameters: ChatbotApiCrawlStatusRequest, options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).crawlStatus(requestParameters.crawlingJobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a chatbot
     * @param {ChatbotApiCreateBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public createBot(requestParameters: ChatbotApiCreateBotRequest = {}, options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).createBot(requestParameters.createChatbotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete a chatbot
     * @param {ChatbotApiDeleteBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public deleteBot(requestParameters: ChatbotApiDeleteBotRequest, options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).deleteBot(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s chatbots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public getBots(options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).getBots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary To get the carwled links
     * @param {ChatbotApiGetCrawledLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public getCrawledLinks(requestParameters: ChatbotApiGetCrawledLinksRequest, options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).getCrawledLinks(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send message to the chatbot
     * @param {ChatbotApiMessageBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public messageBot(requestParameters: ChatbotApiMessageBotRequest, options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).messageBot(requestParameters.id, requestParameters.chatbotMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check the status of training
     * @param {ChatbotApiRefreshTrainStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public refreshTrainStatus(requestParameters: ChatbotApiRefreshTrainStatusRequest, options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).refreshTrainStatus(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post links to train
     * @param {ChatbotApiTrainLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public trainLinks(requestParameters: ChatbotApiTrainLinksRequest, options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).trainLinks(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update chatbot\'s preferences
     * @param {ChatbotApiUpdateBotPreferencesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public updateBotPreferences(requestParameters: ChatbotApiUpdateBotPreferencesRequest, options?: AxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).updateBotPreferences(requestParameters.id, requestParameters.updateChatbotRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KeywordsApi - axios parameter creator
 * @export
 */
export const KeywordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Keyword Based Action
         * @param {Array<KeywordActionCreateRequestObj>} keywordActionCreateRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrigger: async (keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keywordActionCreateRequestObj' is not null or undefined
            assertParamExists('createTrigger', 'keywordActionCreateRequestObj', keywordActionCreateRequestObj)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordActionCreateRequestObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Keyword Based Action
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggers: async (ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteTriggers', 'ids', ids)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_DELETE"], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit Keyword Based Action
         * @param {Array<KeywordActionEditRequestObj>} keywordActionEditRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTrigger: async (keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keywordActionEditRequestObj' is not null or undefined
            assertParamExists('editTrigger', 'keywordActionEditRequestObj', keywordActionEditRequestObj)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordActionEditRequestObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the trigger log of the keyword reply.
         * @param {string} id 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalTriggered] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRecord: async (id: string, count?: number, cursor?: string, returnTotalTriggered?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExecutionRecord', 'id', id)
            const localVarPath = `/log/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (returnTotalTriggered !== undefined) {
                localVarQueryParameter['returnTotalTriggered'] = returnTotalTriggered;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query for user\'s Keyword Actions
         * @param {string} [q] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {TriggerType} [triggerType] Query keywords with the specific trigger type
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggers: async (q?: string, count?: number, id?: Array<string>, triggerType?: TriggerType, cursor?: string, returnTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['triggerType'] = triggerType;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeywordsApi - functional programming interface
 * @export
 */
export const KeywordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeywordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Keyword Based Action
         * @param {Array<KeywordActionCreateRequestObj>} keywordActionCreateRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrigger(keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KeywordBasedAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrigger(keywordActionCreateRequestObj, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Keyword Based Action
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTriggers(ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteTriggers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTriggers(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit Keyword Based Action
         * @param {Array<KeywordActionEditRequestObj>} keywordActionEditRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTrigger(keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KeywordBasedAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTrigger(keywordActionEditRequestObj, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the trigger log of the keyword reply.
         * @param {string} id 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalTriggered] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutionRecord(id: string, count?: number, cursor?: string, returnTotalTriggered?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExecutionRecord200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecutionRecord(id, count, cursor, returnTotalTriggered, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query for user\'s Keyword Actions
         * @param {string} [q] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {TriggerType} [triggerType] Query keywords with the specific trigger type
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggers(q?: string, count?: number, id?: Array<string>, triggerType?: TriggerType, cursor?: string, returnTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTriggers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggers(q, count, id, triggerType, cursor, returnTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KeywordsApi - factory interface
 * @export
 */
export const KeywordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeywordsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Keyword Based Action
         * @param {Array<KeywordActionCreateRequestObj>} keywordActionCreateRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrigger(keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>, options?: any): AxiosPromise<Array<KeywordBasedAction>> {
            return localVarFp.createTrigger(keywordActionCreateRequestObj, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Keyword Based Action
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggers(ids: Array<string>, options?: any): AxiosPromise<DeleteTriggers200Response> {
            return localVarFp.deleteTriggers(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit Keyword Based Action
         * @param {Array<KeywordActionEditRequestObj>} keywordActionEditRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTrigger(keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>, options?: any): AxiosPromise<Array<KeywordBasedAction>> {
            return localVarFp.editTrigger(keywordActionEditRequestObj, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the trigger log of the keyword reply.
         * @param {string} id 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalTriggered] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRecord(id: string, count?: number, cursor?: string, returnTotalTriggered?: boolean, options?: any): AxiosPromise<GetExecutionRecord200Response> {
            return localVarFp.getExecutionRecord(id, count, cursor, returnTotalTriggered, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query for user\'s Keyword Actions
         * @param {string} [q] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {TriggerType} [triggerType] Query keywords with the specific trigger type
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggers(q?: string, count?: number, id?: Array<string>, triggerType?: TriggerType, cursor?: string, returnTotalCount?: boolean, options?: any): AxiosPromise<GetTriggers200Response> {
            return localVarFp.getTriggers(q, count, id, triggerType, cursor, returnTotalCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTrigger operation in KeywordsApi.
 * @export
 * @interface KeywordsApiCreateTriggerRequest
 */
export interface KeywordsApiCreateTriggerRequest {
    /**
     * 
     * @type {Array<KeywordActionCreateRequestObj>}
     * @memberof KeywordsApiCreateTrigger
     */
    readonly keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>
}

/**
 * Request parameters for deleteTriggers operation in KeywordsApi.
 * @export
 * @interface KeywordsApiDeleteTriggersRequest
 */
export interface KeywordsApiDeleteTriggersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordsApiDeleteTriggers
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for editTrigger operation in KeywordsApi.
 * @export
 * @interface KeywordsApiEditTriggerRequest
 */
export interface KeywordsApiEditTriggerRequest {
    /**
     * 
     * @type {Array<KeywordActionEditRequestObj>}
     * @memberof KeywordsApiEditTrigger
     */
    readonly keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>
}

/**
 * Request parameters for getExecutionRecord operation in KeywordsApi.
 * @export
 * @interface KeywordsApiGetExecutionRecordRequest
 */
export interface KeywordsApiGetExecutionRecordRequest {
    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly id: string

    /**
     * 
     * @type {number}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly cursor?: string

    /**
     * 
     * @type {boolean}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly returnTotalTriggered?: boolean
}

/**
 * Request parameters for getTriggers operation in KeywordsApi.
 * @export
 * @interface KeywordsApiGetTriggersRequest
 */
export interface KeywordsApiGetTriggersRequest {
    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetTriggers
     */
    readonly q?: string

    /**
     * 
     * @type {number}
     * @memberof KeywordsApiGetTriggers
     */
    readonly count?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordsApiGetTriggers
     */
    readonly id?: Array<string>

    /**
     * Query keywords with the specific trigger type
     * @type {TriggerType}
     * @memberof KeywordsApiGetTriggers
     */
    readonly triggerType?: TriggerType

    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetTriggers
     */
    readonly cursor?: string

    /**
     * 
     * @type {boolean}
     * @memberof KeywordsApiGetTriggers
     */
    readonly returnTotalCount?: boolean
}

/**
 * KeywordsApi - object-oriented interface
 * @export
 * @class KeywordsApi
 * @extends {BaseAPI}
 */
export class KeywordsApi extends BaseAPI {
    /**
     * 
     * @summary Create new Keyword Based Action
     * @param {KeywordsApiCreateTriggerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public createTrigger(requestParameters: KeywordsApiCreateTriggerRequest, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).createTrigger(requestParameters.keywordActionCreateRequestObj, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Keyword Based Action
     * @param {KeywordsApiDeleteTriggersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public deleteTriggers(requestParameters: KeywordsApiDeleteTriggersRequest, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).deleteTriggers(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit Keyword Based Action
     * @param {KeywordsApiEditTriggerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public editTrigger(requestParameters: KeywordsApiEditTriggerRequest, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).editTrigger(requestParameters.keywordActionEditRequestObj, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the trigger log of the keyword reply.
     * @param {KeywordsApiGetExecutionRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public getExecutionRecord(requestParameters: KeywordsApiGetExecutionRecordRequest, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).getExecutionRecord(requestParameters.id, requestParameters.count, requestParameters.cursor, requestParameters.returnTotalTriggered, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query for user\'s Keyword Actions
     * @param {KeywordsApiGetTriggersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public getTriggers(requestParameters: KeywordsApiGetTriggersRequest = {}, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).getTriggers(requestParameters.q, requestParameters.count, requestParameters.id, requestParameters.triggerType, requestParameters.cursor, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }
}


