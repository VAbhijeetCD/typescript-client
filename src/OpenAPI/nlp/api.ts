const BASE_PATH = "https://api-keywordreply.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Keyword Reply Service
 * Manage Whatsapp automated replies.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface AutocompleteInbox200Response
 */
export interface AutocompleteInbox200Response {
    /**
     * 
     * @type {Array<AutocompleteSuggestion>}
     * @memberof AutocompleteInbox200Response
     */
    'suggestions': Array<AutocompleteSuggestion>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AutocompleteModifier = {
    Longer: 'longer',
    Shorter: 'shorter',
    Formal: 'formal',
    Friendlier: 'friendlier',
    Apologetic: 'apologetic',
    Assertive: 'assertive',
    Clearer: 'clearer',
    Ask: 'ask'
} as const;

export type AutocompleteModifier = typeof AutocompleteModifier[keyof typeof AutocompleteModifier];


/**
 * 
 * @export
 * @interface AutocompleteModify200Response
 */
export interface AutocompleteModify200Response {
    /**
     * Modified text
     * @type {string}
     * @memberof AutocompleteModify200Response
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface AutocompleteModifyRequest
 */
export interface AutocompleteModifyRequest {
    /**
     * 
     * @type {AutocompleteModifyRequestChat}
     * @memberof AutocompleteModifyRequest
     */
    'chat'?: AutocompleteModifyRequestChat;
    /**
     * Text to be modified
     * @type {string}
     * @memberof AutocompleteModifyRequest
     */
    'text': string;
}
/**
 * Provide chat as context for the modifier
 * @export
 * @interface AutocompleteModifyRequestChat
 */
export interface AutocompleteModifyRequestChat {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteModifyRequestChat
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteModifyRequestChat
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AutocompleteSuggestion
 */
export interface AutocompleteSuggestion {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteSuggestion
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface Chatbot
 */
export interface Chatbot {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'id': string;
    /**
     * Name of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'name': string;
    /**
     * List of stored data, such as PDF or website links, associated with the chatbot
     * @type {Array<ChatbotStoredLinksInner>}
     * @memberof Chatbot
     */
    'storedLinks': Array<ChatbotStoredLinksInner>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chatbot
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chatbot
     */
    'updatedAt': string;
    /**
     * Current training status of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'trainingStatus': ChatbotTrainingStatusEnum;
    /**
     * Name of the member to assign to the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'assignedMember': string;
    /**
     * Name of the channel to deploy to the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'deployedChannel': string;
}

export const ChatbotTrainingStatusEnum = {
    Idle: 'idle',
    InProgress: 'inProgress',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type ChatbotTrainingStatusEnum = typeof ChatbotTrainingStatusEnum[keyof typeof ChatbotTrainingStatusEnum];

/**
 * 
 * @export
 * @interface ChatbotMessageRequest
 */
export interface ChatbotMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotMessageRequest
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ChatbotMessageResponse
 */
export interface ChatbotMessageResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotMessageResponse
     */
    'message': Array<string>;
}
/**
 * 
 * @export
 * @interface ChatbotStoredLinksInner
 */
export interface ChatbotStoredLinksInner {
    /**
     * URL of the stored data
     * @type {string}
     * @memberof ChatbotStoredLinksInner
     */
    'link': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ChatbotStoredLinksInner
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface CreateChatbotRequest
 */
export interface CreateChatbotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof CreateChatbotRequest
     */
    'id': string;
    /**
     * Name of the chatbot
     * @type {string}
     * @memberof CreateChatbotRequest
     */
    'name': string;
    /**
     * 
     * @type {Chatbot}
     * @memberof CreateChatbotRequest
     */
    'chatbot': Chatbot;
}
/**
 * 
 * @export
 * @interface DeleteTriggers200Response
 */
export interface DeleteTriggers200Response {
    /**
     * 
     * @type {number}
     * @memberof DeleteTriggers200Response
     */
    'affected'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof DeleteTriggers200Response
     */
    'raw'?: Array<object>;
}
/**
 * 
 * @export
 * @interface DeleteWebScrapingRequest
 */
export interface DeleteWebScrapingRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteWebScrapingRequest
     */
    'links': Array<string>;
}
/**
 * 
 * @export
 * @interface ExecutionFrame
 */
export interface ExecutionFrame {
    /**
     * 
     * @type {string}
     * @memberof ExecutionFrame
     */
    'day'?: ExecutionFrameDayEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionFrame
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionFrame
     */
    'endTime': string;
}

export const ExecutionFrameDayEnum = {
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday',
    Sunday: 'Sunday'
} as const;

export type ExecutionFrameDayEnum = typeof ExecutionFrameDayEnum[keyof typeof ExecutionFrameDayEnum];

/**
 * 
 * @export
 * @interface GetChatbotsResponse
 */
export interface GetChatbotsResponse {
    /**
     * 
     * @type {Array<Chatbot>}
     * @memberof GetChatbotsResponse
     */
    'chatbots': Array<Chatbot>;
}
/**
 * 
 * @export
 * @interface GetExecutionRecord200Response
 */
export interface GetExecutionRecord200Response {
    /**
     * 
     * @type {Array<KeywordActionExecutionRecord>}
     * @memberof GetExecutionRecord200Response
     */
    'logs'?: Array<KeywordActionExecutionRecord>;
    /**
     * 
     * @type {number}
     * @memberof GetExecutionRecord200Response
     */
    'nextPageCursor'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetExecutionRecord200Response
     */
    'totalTriggered'?: number;
}
/**
 * 
 * @export
 * @interface GetTriggers200Response
 */
export interface GetTriggers200Response {
    /**
     * 
     * @type {Array<KeywordBasedAction>}
     * @memberof GetTriggers200Response
     */
    'triggers'?: Array<KeywordBasedAction>;
    /**
     * 
     * @type {number}
     * @memberof GetTriggers200Response
     */
    'nextPageCursor'?: number;
    /**
     * total keywords present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof GetTriggers200Response
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    'text'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Keyword
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface KeywordActionCreateRequestObj
 */
export interface KeywordActionCreateRequestObj {
    /**
     * Status of reply service
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'enabled'?: boolean;
    /**
     * Accounts the keywords will trigger for
     * @type {Array<string>}
     * @memberof KeywordActionCreateRequestObj
     */
    'accountIds'?: Array<string>;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Toggles whether the keyword reply will trigger for group chats
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'enableOnGroupChats'?: boolean;
    /**
     * Only on the first message in a chat
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'onlyOnFirstMessage'?: boolean;
    /**
     * 
     * @type {TriggerType}
     * @memberof KeywordActionCreateRequestObj
     */
    'triggerType': TriggerType;
    /**
     * Unique triggering keywords
     * @type {Array<Keyword>}
     * @memberof KeywordActionCreateRequestObj
     */
    'keywords': Array<Keyword>;
    /**
     * Flow ids to be triggered
     * @type {Array<string>}
     * @memberof KeywordActionCreateRequestObj
     */
    'flowIds': Array<string>;
    /**
     * Timespan before the keyword can be triggered again, measured in seconds
     * @type {number}
     * @memberof KeywordActionCreateRequestObj
     */
    'delay'?: number;
    /**
     * 
     * @type {Array<ExecutionFrame>}
     * @memberof KeywordActionCreateRequestObj
     */
    'executionFrames'?: Array<ExecutionFrame>;
}
/**
 * 
 * @export
 * @interface KeywordActionEditRequestObj
 */
export interface KeywordActionEditRequestObj {
    /**
     * Keyword Id (auto incrementing)
     * @type {number}
     * @memberof KeywordActionEditRequestObj
     */
    'id': number;
    /**
     * Accounts the keywords will trigger for
     * @type {Array<string>}
     * @memberof KeywordActionEditRequestObj
     */
    'accountIds'?: Array<string>;
    /**
     * Status of reply service
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'enabled'?: boolean;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Only on the first message in a chat
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'onlyOnFirstMessage'?: boolean;
    /**
     * Toggles whether the keyword reply will trigger for group chats
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'enableOnGroupChats'?: boolean;
    /**
     * 
     * @type {TriggerType}
     * @memberof KeywordActionEditRequestObj
     */
    'triggerType'?: TriggerType;
    /**
     * Unique triggering keywords
     * @type {Array<Keyword>}
     * @memberof KeywordActionEditRequestObj
     */
    'keywords'?: Array<Keyword>;
    /**
     * Flow ids to be triggered
     * @type {Array<string>}
     * @memberof KeywordActionEditRequestObj
     */
    'flowIds'?: Array<string>;
    /**
     * Timespan before the keyword can be triggered again, measured in seconds
     * @type {number}
     * @memberof KeywordActionEditRequestObj
     */
    'delay'?: number;
    /**
     * 
     * @type {Array<ExecutionFrame>}
     * @memberof KeywordActionEditRequestObj
     */
    'executionFrames'?: Array<ExecutionFrame>;
}
/**
 * 
 * @export
 * @interface KeywordActionExecutionRecord
 */
export interface KeywordActionExecutionRecord {
    /**
     * Keyword Id (auto incrementing)
     * @type {number}
     * @memberof KeywordActionExecutionRecord
     */
    'id': number;
    /**
     * Triggering chatId (jid)
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'chatId': string;
    /**
     * Triggering message ID
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'messageId'?: string;
    /**
     * Incoming message body
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'text': string;
    /**
     * FlowId to be triggered
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'flowId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface KeywordBasedAction
 */
export interface KeywordBasedAction {
    /**
     * Keyword Id (auto incrementing)
     * @type {number}
     * @memberof KeywordBasedAction
     */
    'id': number;
    /**
     * Team the keyword belongs to
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'teamId': string;
    /**
     * Accounts the keywords will trigger for
     * @type {Array<string>}
     * @memberof KeywordBasedAction
     */
    'accountIds'?: Array<string>;
    /**
     * Status of reply service
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'enabled': boolean;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Toggles whether the keyword reply will trigger for group chats
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'enableOnGroupChats'?: boolean;
    /**
     * Only on the first message in a chat
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'onlyOnFirstMessage'?: boolean;
    /**
     * 
     * @type {TriggerType}
     * @memberof KeywordBasedAction
     */
    'triggerType': TriggerType;
    /**
     * Unique triggering keywords
     * @type {Array<Keyword>}
     * @memberof KeywordBasedAction
     */
    'keywords': Array<Keyword>;
    /**
     * Flow ids to be triggered
     * @type {Array<string>}
     * @memberof KeywordBasedAction
     */
    'flowIds'?: Array<string>;
    /**
     * Timespan before the keyword can be triggered again, measured in seconds
     * @type {number}
     * @memberof KeywordBasedAction
     */
    'delay'?: number;
    /**
     * 
     * @type {Array<ExecutionFrame>}
     * @memberof KeywordBasedAction
     */
    'executionFrames'?: Array<ExecutionFrame>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface TranscribePost200Response
 */
export interface TranscribePost200Response {
    /**
     * The transcription of the audio
     * @type {string}
     * @memberof TranscribePost200Response
     */
    'transcription': string;
}
/**
 * 
 * @export
 * @interface TranscribePostRequest
 */
export interface TranscribePostRequest {
    /**
     * The URL of the audio to transcribe
     * @type {string}
     * @memberof TranscribePostRequest
     */
    'audioUrl': string;
}
/**
 * Type of trigger
 * @export
 * @enum {string}
 */

export const TriggerType = {
    Contains: 'contains',
    ContainsPhrase: 'containsPhrase',
    StartsWith: 'startsWith',
    KeywordIs: 'keywordIs',
    DefaultReply: 'defaultReply'
} as const;

export type TriggerType = typeof TriggerType[keyof typeof TriggerType];


/**
 * 
 * @export
 * @interface UpdateChatbotRequest
 */
export interface UpdateChatbotRequest {
    /**
     * 
     * @type {Chatbot}
     * @memberof UpdateChatbotRequest
     */
    'chatbot': Chatbot;
    /**
     * List of links to add to the chatbot
     * @type {Array<string>}
     * @memberof UpdateChatbotRequest
     */
    'linksToAdd'?: Array<string>;
    /**
     * List of links to remove from the chatbot
     * @type {Array<string>}
     * @memberof UpdateChatbotRequest
     */
    'linksToRemove'?: Array<string>;
    /**
     * Name of the member to assign to the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'assignedMember': string;
    /**
     * Name of the channel to deploy to the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'deployedChannel': string;
}
/**
 * 
 * @export
 * @interface WebScrapingRequest
 */
export interface WebScrapingRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebScrapingRequest
     */
    'links': Array<string>;
}
/**
 * 
 * @export
 * @interface WebScrapingResponse
 */
export interface WebScrapingResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebScrapingResponse
     */
    'links': Array<string>;
}

/**
 * AudioTranscriptionApi - axios parameter creator
 * @export
 */
export const AudioTranscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accepts an audio URL and converts it to text using AWS Transcribe. Supports both streaming and batch processing.
         * @summary Convert audio URL to text
         * @param {TranscribePostRequest} transcribePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribePost: async (transcribePostRequest: TranscribePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transcribePostRequest' is not null or undefined
            assertParamExists('transcribePost', 'transcribePostRequest', transcribePostRequest)
            const localVarPath = `/transcribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transcribePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioTranscriptionApi - functional programming interface
 * @export
 */
export const AudioTranscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudioTranscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Accepts an audio URL and converts it to text using AWS Transcribe. Supports both streaming and batch processing.
         * @summary Convert audio URL to text
         * @param {TranscribePostRequest} transcribePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcribePost(transcribePostRequest: TranscribePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscribePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcribePost(transcribePostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AudioTranscriptionApi - factory interface
 * @export
 */
export const AudioTranscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudioTranscriptionApiFp(configuration)
    return {
        /**
         * Accepts an audio URL and converts it to text using AWS Transcribe. Supports both streaming and batch processing.
         * @summary Convert audio URL to text
         * @param {TranscribePostRequest} transcribePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribePost(transcribePostRequest: TranscribePostRequest, options?: any): AxiosPromise<TranscribePost200Response> {
            return localVarFp.transcribePost(transcribePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for transcribePost operation in AudioTranscriptionApi.
 * @export
 * @interface AudioTranscriptionApiTranscribePostRequest
 */
export interface AudioTranscriptionApiTranscribePostRequest {
    /**
     * 
     * @type {TranscribePostRequest}
     * @memberof AudioTranscriptionApiTranscribePost
     */
    readonly transcribePostRequest: TranscribePostRequest
}

/**
 * AudioTranscriptionApi - object-oriented interface
 * @export
 * @class AudioTranscriptionApi
 * @extends {BaseAPI}
 */
export class AudioTranscriptionApi extends BaseAPI {
    /**
     * Accepts an audio URL and converts it to text using AWS Transcribe. Supports both streaming and batch processing.
     * @summary Convert audio URL to text
     * @param {AudioTranscriptionApiTranscribePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioTranscriptionApi
     */
    public transcribePost(requestParameters: AudioTranscriptionApiTranscribePostRequest, options?: AxiosRequestConfig) {
        return AudioTranscriptionApiFp(this.configuration).transcribePost(requestParameters.transcribePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutocompleteApi - axios parameter creator
 * @export
 */
export const AutocompleteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteInbox: async (accountId: string, chatId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('autocompleteInbox', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('autocompleteInbox', 'chatId', chatId)
            const localVarPath = `/autocomplete/inbox/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteModify: async (modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modifier' is not null or undefined
            assertParamExists('autocompleteModify', 'modifier', modifier)
            // verify required parameter 'autocompleteModifyRequest' is not null or undefined
            assertParamExists('autocompleteModify', 'autocompleteModifyRequest', autocompleteModifyRequest)
            const localVarPath = `/autocomplete/modify/{modifier}`
                .replace(`{${"modifier"}}`, encodeURIComponent(String(modifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autocompleteModifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutocompleteApi - functional programming interface
 * @export
 */
export const AutocompleteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutocompleteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteInbox(accountId: string, chatId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutocompleteInbox200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteInbox(accountId, chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteModify(modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutocompleteModify200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteModify(modifier, autocompleteModifyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutocompleteApi - factory interface
 * @export
 */
export const AutocompleteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutocompleteApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteInbox(accountId: string, chatId: string, options?: any): AxiosPromise<AutocompleteInbox200Response> {
            return localVarFp.autocompleteInbox(accountId, chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteModify(modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options?: any): AxiosPromise<AutocompleteModify200Response> {
            return localVarFp.autocompleteModify(modifier, autocompleteModifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autocompleteInbox operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiAutocompleteInboxRequest
 */
export interface AutocompleteApiAutocompleteInboxRequest {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiAutocompleteInbox
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiAutocompleteInbox
     */
    readonly chatId: string
}

/**
 * Request parameters for autocompleteModify operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiAutocompleteModifyRequest
 */
export interface AutocompleteApiAutocompleteModifyRequest {
    /**
     * 
     * @type {AutocompleteModifier}
     * @memberof AutocompleteApiAutocompleteModify
     */
    readonly modifier: AutocompleteModifier

    /**
     * 
     * @type {AutocompleteModifyRequest}
     * @memberof AutocompleteApiAutocompleteModify
     */
    readonly autocompleteModifyRequest: AutocompleteModifyRequest
}

/**
 * AutocompleteApi - object-oriented interface
 * @export
 * @class AutocompleteApi
 * @extends {BaseAPI}
 */
export class AutocompleteApi extends BaseAPI {
    /**
     * 
     * @summary Returns autocomplete suggestions for a chat
     * @param {AutocompleteApiAutocompleteInboxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public autocompleteInbox(requestParameters: AutocompleteApiAutocompleteInboxRequest, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).autocompleteInbox(requestParameters.accountId, requestParameters.chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply some modification to the given text
     * @param {AutocompleteApiAutocompleteModifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public autocompleteModify(requestParameters: AutocompleteApiAutocompleteModifyRequest, options?: AxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).autocompleteModify(requestParameters.modifier, requestParameters.autocompleteModifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check document ingestion status
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDocumentIngestionStatus: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkDocumentIngestionStatus', 'id', id)
            const localVarPath = `/chatbot/{id}/documents/ingest`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a chatbot
         * @param {CreateChatbotRequest} [createChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot: async (createChatbotRequest?: CreateChatbotRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chatbots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChatbotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete links from a website
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLink: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLink', 'id', id)
            const localVarPath = `/chatbot/{id}/web-scraping`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extract links from a website
         * @param {string} id ID of the chatbot
         * @param {WebScrapingRequest} [webScrapingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractLinks: async (id: string, webScrapingRequest?: WebScrapingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extractLinks', 'id', id)
            const localVarPath = `/chatbot/{id}/web-scraping`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webScrapingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s chatbots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chatbots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send message to the chatbot
         * @param {string} id ID of the chatbot
         * @param {ChatbotMessageRequest} [chatbotMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageBot: async (id: string, chatbotMessageRequest?: ChatbotMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messageBot', 'id', id)
            const localVarPath = `/chatbot/{id}/message`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatbotMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check the status of training
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainBot: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainBot', 'id', id)
            const localVarPath = `/chatbot/{id}/train`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update chatbot\'s preferences
         * @param {string} id ID of the chatbot
         * @param {UpdateChatbotRequest} [updateChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotPreferences: async (id: string, updateChatbotRequest?: UpdateChatbotRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBotPreferences', 'id', id)
            const localVarPath = `/chatbots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChatbotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check document ingestion status
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDocumentIngestionStatus(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDocumentIngestionStatus(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a chatbot
         * @param {CreateChatbotRequest} [createChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBot(createChatbotRequest?: CreateChatbotRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBot(createChatbotRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete links from a website
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLink(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Extract links from a website
         * @param {string} id ID of the chatbot
         * @param {WebScrapingRequest} [webScrapingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extractLinks(id: string, webScrapingRequest?: WebScrapingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebScrapingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extractLinks(id, webScrapingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user\'s chatbots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBots(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatbotsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBots(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send message to the chatbot
         * @param {string} id ID of the chatbot
         * @param {ChatbotMessageRequest} [chatbotMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageBot(id: string, chatbotMessageRequest?: ChatbotMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatbotMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageBot(id, chatbotMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check the status of training
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainBot(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainBot(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update chatbot\'s preferences
         * @param {string} id ID of the chatbot
         * @param {UpdateChatbotRequest} [updateChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBotPreferences(id: string, updateChatbotRequest?: UpdateChatbotRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBotPreferences(id, updateChatbotRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Check document ingestion status
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDocumentIngestionStatus(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.checkDocumentIngestionStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a chatbot
         * @param {CreateChatbotRequest} [createChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot(createChatbotRequest?: CreateChatbotRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createBot(createChatbotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete links from a website
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLink(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Extract links from a website
         * @param {string} id ID of the chatbot
         * @param {WebScrapingRequest} [webScrapingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractLinks(id: string, webScrapingRequest?: WebScrapingRequest, options?: any): AxiosPromise<WebScrapingResponse> {
            return localVarFp.extractLinks(id, webScrapingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s chatbots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(options?: any): AxiosPromise<GetChatbotsResponse> {
            return localVarFp.getBots(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send message to the chatbot
         * @param {string} id ID of the chatbot
         * @param {ChatbotMessageRequest} [chatbotMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageBot(id: string, chatbotMessageRequest?: ChatbotMessageRequest, options?: any): AxiosPromise<ChatbotMessageResponse> {
            return localVarFp.messageBot(id, chatbotMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check the status of training
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainBot(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.trainBot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update chatbot\'s preferences
         * @param {string} id ID of the chatbot
         * @param {UpdateChatbotRequest} [updateChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotPreferences(id: string, updateChatbotRequest?: UpdateChatbotRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateBotPreferences(id, updateChatbotRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for checkDocumentIngestionStatus operation in DefaultApi.
 * @export
 * @interface DefaultApiCheckDocumentIngestionStatusRequest
 */
export interface DefaultApiCheckDocumentIngestionStatusRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof DefaultApiCheckDocumentIngestionStatus
     */
    readonly id: string
}

/**
 * Request parameters for createBot operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateBotRequest
 */
export interface DefaultApiCreateBotRequest {
    /**
     * 
     * @type {CreateChatbotRequest}
     * @memberof DefaultApiCreateBot
     */
    readonly createChatbotRequest?: CreateChatbotRequest
}

/**
 * Request parameters for deleteLink operation in DefaultApi.
 * @export
 * @interface DefaultApiDeleteLinkRequest
 */
export interface DefaultApiDeleteLinkRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof DefaultApiDeleteLink
     */
    readonly id: string
}

/**
 * Request parameters for extractLinks operation in DefaultApi.
 * @export
 * @interface DefaultApiExtractLinksRequest
 */
export interface DefaultApiExtractLinksRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof DefaultApiExtractLinks
     */
    readonly id: string

    /**
     * 
     * @type {WebScrapingRequest}
     * @memberof DefaultApiExtractLinks
     */
    readonly webScrapingRequest?: WebScrapingRequest
}

/**
 * Request parameters for messageBot operation in DefaultApi.
 * @export
 * @interface DefaultApiMessageBotRequest
 */
export interface DefaultApiMessageBotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof DefaultApiMessageBot
     */
    readonly id: string

    /**
     * 
     * @type {ChatbotMessageRequest}
     * @memberof DefaultApiMessageBot
     */
    readonly chatbotMessageRequest?: ChatbotMessageRequest
}

/**
 * Request parameters for trainBot operation in DefaultApi.
 * @export
 * @interface DefaultApiTrainBotRequest
 */
export interface DefaultApiTrainBotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof DefaultApiTrainBot
     */
    readonly id: string
}

/**
 * Request parameters for updateBotPreferences operation in DefaultApi.
 * @export
 * @interface DefaultApiUpdateBotPreferencesRequest
 */
export interface DefaultApiUpdateBotPreferencesRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof DefaultApiUpdateBotPreferences
     */
    readonly id: string

    /**
     * 
     * @type {UpdateChatbotRequest}
     * @memberof DefaultApiUpdateBotPreferences
     */
    readonly updateChatbotRequest?: UpdateChatbotRequest
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Check document ingestion status
     * @param {DefaultApiCheckDocumentIngestionStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public checkDocumentIngestionStatus(requestParameters: DefaultApiCheckDocumentIngestionStatusRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).checkDocumentIngestionStatus(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a chatbot
     * @param {DefaultApiCreateBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createBot(requestParameters: DefaultApiCreateBotRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createBot(requestParameters.createChatbotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete links from a website
     * @param {DefaultApiDeleteLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteLink(requestParameters: DefaultApiDeleteLinkRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteLink(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Extract links from a website
     * @param {DefaultApiExtractLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extractLinks(requestParameters: DefaultApiExtractLinksRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).extractLinks(requestParameters.id, requestParameters.webScrapingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s chatbots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBots(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send message to the chatbot
     * @param {DefaultApiMessageBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public messageBot(requestParameters: DefaultApiMessageBotRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).messageBot(requestParameters.id, requestParameters.chatbotMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check the status of training
     * @param {DefaultApiTrainBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public trainBot(requestParameters: DefaultApiTrainBotRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).trainBot(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update chatbot\'s preferences
     * @param {DefaultApiUpdateBotPreferencesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateBotPreferences(requestParameters: DefaultApiUpdateBotPreferencesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateBotPreferences(requestParameters.id, requestParameters.updateChatbotRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KeywordsApi - axios parameter creator
 * @export
 */
export const KeywordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Keyword Based Action
         * @param {Array<KeywordActionCreateRequestObj>} keywordActionCreateRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrigger: async (keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keywordActionCreateRequestObj' is not null or undefined
            assertParamExists('createTrigger', 'keywordActionCreateRequestObj', keywordActionCreateRequestObj)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordActionCreateRequestObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Keyword Based Action
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggers: async (ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteTriggers', 'ids', ids)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_DELETE"], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit Keyword Based Action
         * @param {Array<KeywordActionEditRequestObj>} keywordActionEditRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTrigger: async (keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keywordActionEditRequestObj' is not null or undefined
            assertParamExists('editTrigger', 'keywordActionEditRequestObj', keywordActionEditRequestObj)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordActionEditRequestObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the trigger log of the keyword reply.
         * @param {string} id 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalTriggered] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRecord: async (id: string, count?: number, cursor?: string, returnTotalTriggered?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExecutionRecord', 'id', id)
            const localVarPath = `/log/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (returnTotalTriggered !== undefined) {
                localVarQueryParameter['returnTotalTriggered'] = returnTotalTriggered;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query for user\'s Keyword Actions
         * @param {string} [q] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {TriggerType} [triggerType] Query keywords with the specific trigger type
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggers: async (q?: string, count?: number, id?: Array<string>, triggerType?: TriggerType, cursor?: string, returnTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['triggerType'] = triggerType;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeywordsApi - functional programming interface
 * @export
 */
export const KeywordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeywordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Keyword Based Action
         * @param {Array<KeywordActionCreateRequestObj>} keywordActionCreateRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrigger(keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KeywordBasedAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrigger(keywordActionCreateRequestObj, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Keyword Based Action
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTriggers(ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteTriggers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTriggers(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit Keyword Based Action
         * @param {Array<KeywordActionEditRequestObj>} keywordActionEditRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTrigger(keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KeywordBasedAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTrigger(keywordActionEditRequestObj, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the trigger log of the keyword reply.
         * @param {string} id 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalTriggered] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutionRecord(id: string, count?: number, cursor?: string, returnTotalTriggered?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExecutionRecord200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecutionRecord(id, count, cursor, returnTotalTriggered, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query for user\'s Keyword Actions
         * @param {string} [q] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {TriggerType} [triggerType] Query keywords with the specific trigger type
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggers(q?: string, count?: number, id?: Array<string>, triggerType?: TriggerType, cursor?: string, returnTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTriggers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggers(q, count, id, triggerType, cursor, returnTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KeywordsApi - factory interface
 * @export
 */
export const KeywordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeywordsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Keyword Based Action
         * @param {Array<KeywordActionCreateRequestObj>} keywordActionCreateRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrigger(keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>, options?: any): AxiosPromise<Array<KeywordBasedAction>> {
            return localVarFp.createTrigger(keywordActionCreateRequestObj, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Keyword Based Action
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggers(ids: Array<string>, options?: any): AxiosPromise<DeleteTriggers200Response> {
            return localVarFp.deleteTriggers(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit Keyword Based Action
         * @param {Array<KeywordActionEditRequestObj>} keywordActionEditRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTrigger(keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>, options?: any): AxiosPromise<Array<KeywordBasedAction>> {
            return localVarFp.editTrigger(keywordActionEditRequestObj, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the trigger log of the keyword reply.
         * @param {string} id 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalTriggered] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRecord(id: string, count?: number, cursor?: string, returnTotalTriggered?: boolean, options?: any): AxiosPromise<GetExecutionRecord200Response> {
            return localVarFp.getExecutionRecord(id, count, cursor, returnTotalTriggered, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query for user\'s Keyword Actions
         * @param {string} [q] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {TriggerType} [triggerType] Query keywords with the specific trigger type
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggers(q?: string, count?: number, id?: Array<string>, triggerType?: TriggerType, cursor?: string, returnTotalCount?: boolean, options?: any): AxiosPromise<GetTriggers200Response> {
            return localVarFp.getTriggers(q, count, id, triggerType, cursor, returnTotalCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTrigger operation in KeywordsApi.
 * @export
 * @interface KeywordsApiCreateTriggerRequest
 */
export interface KeywordsApiCreateTriggerRequest {
    /**
     * 
     * @type {Array<KeywordActionCreateRequestObj>}
     * @memberof KeywordsApiCreateTrigger
     */
    readonly keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>
}

/**
 * Request parameters for deleteTriggers operation in KeywordsApi.
 * @export
 * @interface KeywordsApiDeleteTriggersRequest
 */
export interface KeywordsApiDeleteTriggersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordsApiDeleteTriggers
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for editTrigger operation in KeywordsApi.
 * @export
 * @interface KeywordsApiEditTriggerRequest
 */
export interface KeywordsApiEditTriggerRequest {
    /**
     * 
     * @type {Array<KeywordActionEditRequestObj>}
     * @memberof KeywordsApiEditTrigger
     */
    readonly keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>
}

/**
 * Request parameters for getExecutionRecord operation in KeywordsApi.
 * @export
 * @interface KeywordsApiGetExecutionRecordRequest
 */
export interface KeywordsApiGetExecutionRecordRequest {
    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly id: string

    /**
     * 
     * @type {number}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly cursor?: string

    /**
     * 
     * @type {boolean}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly returnTotalTriggered?: boolean
}

/**
 * Request parameters for getTriggers operation in KeywordsApi.
 * @export
 * @interface KeywordsApiGetTriggersRequest
 */
export interface KeywordsApiGetTriggersRequest {
    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetTriggers
     */
    readonly q?: string

    /**
     * 
     * @type {number}
     * @memberof KeywordsApiGetTriggers
     */
    readonly count?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordsApiGetTriggers
     */
    readonly id?: Array<string>

    /**
     * Query keywords with the specific trigger type
     * @type {TriggerType}
     * @memberof KeywordsApiGetTriggers
     */
    readonly triggerType?: TriggerType

    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetTriggers
     */
    readonly cursor?: string

    /**
     * 
     * @type {boolean}
     * @memberof KeywordsApiGetTriggers
     */
    readonly returnTotalCount?: boolean
}

/**
 * KeywordsApi - object-oriented interface
 * @export
 * @class KeywordsApi
 * @extends {BaseAPI}
 */
export class KeywordsApi extends BaseAPI {
    /**
     * 
     * @summary Create new Keyword Based Action
     * @param {KeywordsApiCreateTriggerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public createTrigger(requestParameters: KeywordsApiCreateTriggerRequest, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).createTrigger(requestParameters.keywordActionCreateRequestObj, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Keyword Based Action
     * @param {KeywordsApiDeleteTriggersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public deleteTriggers(requestParameters: KeywordsApiDeleteTriggersRequest, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).deleteTriggers(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit Keyword Based Action
     * @param {KeywordsApiEditTriggerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public editTrigger(requestParameters: KeywordsApiEditTriggerRequest, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).editTrigger(requestParameters.keywordActionEditRequestObj, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the trigger log of the keyword reply.
     * @param {KeywordsApiGetExecutionRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public getExecutionRecord(requestParameters: KeywordsApiGetExecutionRecordRequest, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).getExecutionRecord(requestParameters.id, requestParameters.count, requestParameters.cursor, requestParameters.returnTotalTriggered, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query for user\'s Keyword Actions
     * @param {KeywordsApiGetTriggersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public getTriggers(requestParameters: KeywordsApiGetTriggersRequest = {}, options?: AxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).getTriggers(requestParameters.q, requestParameters.count, requestParameters.id, requestParameters.triggerType, requestParameters.cursor, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }
}


