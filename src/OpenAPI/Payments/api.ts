const BASE_PATH = "https://api-payments.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Payments Service
 * Manage ChatDaddy payments
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface AccountPurchase
 */
export interface AccountPurchase {
    /**
     * 
     * @type {string}
     * @memberof AccountPurchase
     */
    'id': string;
    /**
     * The ID of the subscription
     * @type {string}
     * @memberof AccountPurchase
     */
    'subscriptionId': string | null;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof AccountPurchase
     */
    'status': PurchaseStatus;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof AccountPurchase
     */
    'createdAt': string;
    /**
     * 
     * @type {MessagesModel}
     * @memberof AccountPurchase
     */
    'messages': MessagesModel;
}
/**
 * 
 * @export
 * @interface ActiveModel
 */
export interface ActiveModel {
    /**
     * Stripe publishable key
     * @type {string}
     * @memberof ActiveModel
     */
    'publishableKey': string;
    /**
     * 
     * @type {Array<Feature>}
     * @memberof ActiveModel
     */
    'features': Array<Feature>;
    /**
     * 
     * @type {ActiveModelLimits}
     * @memberof ActiveModel
     */
    'limits': ActiveModelLimits;
    /**
     * 
     * @type {boolean}
     * @memberof ActiveModel
     */
    'isActivePaidUser': boolean;
}
/**
 * 
 * @export
 * @interface ActiveModelLimits
 */
export interface ActiveModelLimits {
    /**
     * 
     * @type {MessagesModel}
     * @memberof ActiveModelLimits
     */
    'messages': MessagesModel;
    /**
     * 
     * @type {boolean}
     * @memberof ActiveModelLimits
     * @deprecated
     */
    'unlimitedMessages': boolean;
    /**
     * 
     * @type {number}
     * @memberof ActiveModelLimits
     */
    'seats': number;
    /**
     * 
     * @type {number}
     * @memberof ActiveModelLimits
     */
    'accounts'?: number;
    /**
     * By default, all buttons have \"Powered By ChatDaddy\".  If this value is true, the user can set no marketing message or their own
     * @type {boolean}
     * @memberof ActiveModelLimits
     */
    'allowCustomMarketingMessage': boolean;
}
/**
 * Purchase/upgrade/downgrade an account. The \"id\" parameter will be used to upgrade/downgrade the account if already purchased
 * @export
 * @interface AutoChargeAccountRequest
 */
export interface AutoChargeAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof AutoChargeAccountRequest
     */
    'type': AutoChargeAccountRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AutoChargeAccountRequest
     */
    'id': string;
    /**
     * 
     * @type {IMAccountTier}
     * @memberof AutoChargeAccountRequest
     */
    'tier': IMAccountTier;
}

export const AutoChargeAccountRequestTypeEnum = {
    Account: 'account'
} as const;

export type AutoChargeAccountRequestTypeEnum = typeof AutoChargeAccountRequestTypeEnum[keyof typeof AutoChargeAccountRequestTypeEnum];

/**
 * 
 * @export
 * @interface AutoChargeMessagesRequest
 */
export interface AutoChargeMessagesRequest {
    /**
     * 
     * @type {string}
     * @memberof AutoChargeMessagesRequest
     */
    'type': AutoChargeMessagesRequestTypeEnum;
}

export const AutoChargeMessagesRequestTypeEnum = {
    Messages: 'messages'
} as const;

export type AutoChargeMessagesRequestTypeEnum = typeof AutoChargeMessagesRequestTypeEnum[keyof typeof AutoChargeMessagesRequestTypeEnum];

/**
 * @type AutoChargeRequest
 * @export
 */
export type AutoChargeRequest = AutoChargeAccountRequest | AutoChargeMessagesRequest;

/**
 * 
 * @export
 * @interface BillingSessionPost200Response
 */
export interface BillingSessionPost200Response {
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CouponCodeCreateOptions
 */
export interface CouponCodeCreateOptions {
    /**
     * 
     * @type {string}
     * @memberof CouponCodeCreateOptions
     */
    'category': string;
    /**
     * limit coupon code to products
     * @type {Array<string>}
     * @memberof CouponCodeCreateOptions
     */
    'products'?: Array<string>;
    /**
     * set free trial. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'freeTrialDays'?: number;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'discountPercentageOff': number;
}
/**
 * @type EligibleModel
 * @export
 */
export type EligibleModel = EligibleModelOneOf | boolean;

/**
 * 
 * @export
 * @interface EligibleModelOneOf
 */
export interface EligibleModelOneOf {
    /**
     * 
     * @type {string}
     * @memberof EligibleModelOneOf
     */
    'reason'?: string;
}
/**
 * List of features
 * @export
 * @enum {string}
 */

export const Feature = {
    TeamInbox: 'team-inbox',
    Audience: 'audience',
    Notifications: 'notifications',
    KeywordReply: 'keyword-reply',
    Broadcast: 'broadcast',
    MessageFlows: 'message-flows'
} as const;

export type Feature = typeof Feature[keyof typeof Feature];


/**
 * 
 * @export
 * @interface GetPartner200Response
 */
export interface GetPartner200Response {
    /**
     * 
     * @type {string}
     * @memberof GetPartner200Response
     */
    'partnerAdmin'?: string;
}
/**
 * Describes the tier of the account, and which features it\'ll have
 * @export
 * @enum {string}
 */

export const IMAccountTier = {
    LimitedMsgNoChatHistory: 'limited_msg_no_chat_history',
    UnlimitedMsgChatHistory: 'unlimited_msg_chat_history'
} as const;

export type IMAccountTier = typeof IMAccountTier[keyof typeof IMAccountTier];


/**
 * 
 * @export
 * @interface LimitsModel
 */
export interface LimitsModel {
    /**
     * 
     * @type {LimitsModelMessages}
     * @memberof LimitsModel
     */
    'messages'?: LimitsModelMessages;
    /**
     * 
     * @type {LimitsModelSeats}
     * @memberof LimitsModel
     */
    'seats'?: LimitsModelSeats;
    /**
     * 
     * @type {boolean}
     * @memberof LimitsModel
     */
    'allowCustomMarketingMessage'?: boolean;
    /**
     * 
     * @type {LimitsModelAccounts}
     * @memberof LimitsModel
     */
    'accounts'?: LimitsModelAccounts;
}
/**
 * the number of max IM accounts this user can have
 * @export
 * @interface LimitsModelAccounts
 */
export interface LimitsModelAccounts {
    /**
     * 
     * @type {number}
     * @memberof LimitsModelAccounts
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface LimitsModelMessages
 */
export interface LimitsModelMessages {
    /**
     * -1 means unlimited messages
     * @type {number}
     * @memberof LimitsModelMessages
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof LimitsModelMessages
     */
    'type': LimitsModelMessagesTypeEnum;
    /**
     * is message history sync allowed
     * @type {boolean}
     * @memberof LimitsModelMessages
     */
    'historySyncAllowed'?: boolean;
}

export const LimitsModelMessagesTypeEnum = {
    OneTime: 'one-time',
    Monthly: 'monthly'
} as const;

export type LimitsModelMessagesTypeEnum = typeof LimitsModelMessagesTypeEnum[keyof typeof LimitsModelMessagesTypeEnum];

/**
 * 
 * @export
 * @interface LimitsModelSeats
 */
export interface LimitsModelSeats {
    /**
     * 
     * @type {number}
     * @memberof LimitsModelSeats
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof LimitsModelSeats
     */
    'type': LimitsModelSeatsTypeEnum;
}

export const LimitsModelSeatsTypeEnum = {
    Total: 'total',
    Additional: 'additional'
} as const;

export type LimitsModelSeatsTypeEnum = typeof LimitsModelSeatsTypeEnum[keyof typeof LimitsModelSeatsTypeEnum];

/**
 * 
 * @export
 * @interface MainPatchRequest
 */
export interface MainPatchRequest {
    /**
     * The new product ID to update to
     * @type {string}
     * @memberof MainPatchRequest
     */
    'newId': string;
}
/**
 * 
 * @export
 * @interface MainPost200Response
 */
export interface MainPost200Response {
    /**
     * 
     * @type {Array<PurchaseDetails>}
     * @memberof MainPost200Response
     */
    'purchases': Array<PurchaseDetails>;
}
/**
 * 
 * @export
 * @interface MainPostRequest
 */
export interface MainPostRequest {
    /**
     * 
     * @type {string}
     * @memberof MainPostRequest
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof MainPostRequest
     */
    'quantity'?: number;
    /**
     * the unique ID of the purchase
     * @type {string}
     * @memberof MainPostRequest
     */
    'purchaseId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MainPostRequest
     */
    'freeTrial'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MainPostRequest
     */
    'expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof MainPostRequest
     */
    'status'?: MainPostRequestStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof MainPostRequest
     */
    'consistent'?: boolean;
}

export const MainPostRequestStatusEnum = {
    Paid: 'paid',
    PendingPayment: 'pending-payment'
} as const;

export type MainPostRequestStatusEnum = typeof MainPostRequestStatusEnum[keyof typeof MainPostRequestStatusEnum];

/**
 * 
 * @export
 * @interface MainRefresh200Response
 */
export interface MainRefresh200Response {
    /**
     * 
     * @type {boolean}
     * @memberof MainRefresh200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface MessagesModel
 */
export interface MessagesModel {
    /**
     * 
     * @type {boolean}
     * @memberof MessagesModel
     */
    'unlimited': boolean;
    /**
     * maximum messages that can be sent in the current period
     * @type {number}
     * @memberof MessagesModel
     */
    'limit': number;
    /**
     * messages sent in the period
     * @type {number}
     * @memberof MessagesModel
     */
    'sent': number;
    /**
     * is chat/message history allowed in the purchased plan
     * @type {boolean}
     * @memberof MessagesModel
     */
    'historySyncAllowed'?: boolean;
}
/**
 * options to generate partnerReferral
 * @export
 * @interface PartnerReferralCreateOptions
 */
export interface PartnerReferralCreateOptions {
    /**
     * ID of the product purchased
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'productId': string;
    /**
     * time the product can be used for in days
     * @type {number}
     * @memberof PartnerReferralCreateOptions
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'referralCodeExpiry'?: string;
    /**
     * a string to be appended to the generated referral code
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'includeInReferralCode'?: string;
}
/**
 * 
 * @export
 * @interface PartnerReferralsGet200Response
 */
export interface PartnerReferralsGet200Response {
    /**
     * 
     * @type {Array<ReferralCodeDetails>}
     * @memberof PartnerReferralsGet200Response
     */
    'referralCodes': Array<ReferralCodeDetails>;
    /**
     * 
     * @type {number}
     * @memberof PartnerReferralsGet200Response
     */
    'nextPage'?: number;
}
/**
 * 
 * @export
 * @interface PartnerReferralsPost200Response
 */
export interface PartnerReferralsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof PartnerReferralsPost200Response
     */
    'referralCode': string;
}
/**
 * 
 * @export
 * @interface PriceDetails
 */
export interface PriceDetails {
    /**
     * 
     * @type {number}
     * @memberof PriceDetails
     */
    'value': number;
    /**
     * ISO code of currency
     * @type {string}
     * @memberof PriceDetails
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * The category it belongs to (stripe product really)
     * @type {string}
     * @memberof Product
     */
    'categoryId': string;
    /**
     * 
     * @type {PriceDetails}
     * @memberof Product
     */
    'price': PriceDetails;
    /**
     * Whether this product can be actively purchases
     * @type {boolean}
     * @memberof Product
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'priceType': ProductPriceTypeEnum;
    /**
     * 
     * @type {EligibleModel}
     * @memberof Product
     */
    'eligible': EligibleModel;
    /**
     * 
     * @type {Array<PurchaseDetails>}
     * @memberof Product
     */
    'purchases': Array<PurchaseDetails>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {LimitsModel}
     * @memberof Product
     */
    'limits': LimitsModel;
    /**
     * 
     * @type {ProductFeatures}
     * @memberof Product
     */
    'features': ProductFeatures;
    /**
     * 
     * @type {ProductUpdateFreeTrial}
     * @memberof Product
     */
    'freeTrial'?: ProductUpdateFreeTrial | null;
    /**
     * Maximum number of times this product can be bought
     * @type {number}
     * @memberof Product
     */
    'maxLifetimePurchases'?: number | null;
    /**
     * Maximum active purchases of this product
     * @type {number}
     * @memberof Product
     */
    'maxActivePurchases'?: number | null;
}

export const ProductPriceTypeEnum = {
    Yearly: 'yearly',
    Monthly: 'monthly',
    OneTime: 'one-time'
} as const;

export type ProductPriceTypeEnum = typeof ProductPriceTypeEnum[keyof typeof ProductPriceTypeEnum];

/**
 * @type ProductFeatures
 * @export
 */
export type ProductFeatures = Array<Feature> | string;

/**
 * 
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProductUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {LimitsModel}
     * @memberof ProductUpdate
     */
    'limits'?: LimitsModel;
    /**
     * 
     * @type {ProductUpdateFeatures}
     * @memberof ProductUpdate
     */
    'features'?: ProductUpdateFeatures;
    /**
     * 
     * @type {ProductUpdateFreeTrial}
     * @memberof ProductUpdate
     */
    'freeTrial'?: ProductUpdateFreeTrial | null;
    /**
     * Whether this product can be actively purchases
     * @type {boolean}
     * @memberof ProductUpdate
     */
    'active'?: boolean;
    /**
     * Maximum number of times this product can be bought
     * @type {number}
     * @memberof ProductUpdate
     */
    'maxLifetimePurchases'?: number | null;
    /**
     * Maximum active purchases of this product
     * @type {number}
     * @memberof ProductUpdate
     */
    'maxActivePurchases'?: number | null;
}
/**
 * @type ProductUpdateFeatures
 * @export
 */
export type ProductUpdateFeatures = Array<Feature> | string;

/**
 * 
 * @export
 * @interface ProductUpdateFreeTrial
 */
export interface ProductUpdateFreeTrial {
    /**
     * 
     * @type {number}
     * @memberof ProductUpdateFreeTrial
     */
    'days': number;
    /**
     * 
     * @type {EligibleModel}
     * @memberof ProductUpdateFreeTrial
     */
    'eligible'?: EligibleModel;
}
/**
 * 
 * @export
 * @interface ProductsGet200Response
 */
export interface ProductsGet200Response {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductsGet200Response
     */
    'products': Array<Product>;
}
/**
 * Info about the purchase if applicable
 * @export
 * @interface PurchaseDetails
 */
export interface PurchaseDetails {
    /**
     * ID of the purchase
     * @type {string}
     * @memberof PurchaseDetails
     */
    'id': string;
    /**
     * ID of the product purchased
     * @type {string}
     * @memberof PurchaseDetails
     */
    'productId': string;
    /**
     * The team who purchased it
     * @type {string}
     * @memberof PurchaseDetails
     */
    'teamId': string;
    /**
     * ID of the user who purchased it
     * @type {string}
     * @memberof PurchaseDetails
     */
    'userId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PurchaseDetails
     */
    'date': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PurchaseDetails
     */
    'expiry'?: string;
    /**
     * 
     * @type {PriceDetails}
     * @memberof PurchaseDetails
     */
    'price': PriceDetails;
    /**
     * 
     * @type {PurchaseDetailsTrial}
     * @memberof PurchaseDetails
     */
    'trial'?: PurchaseDetailsTrial | null;
    /**
     * 
     * @type {PurchaseStatus}
     * @memberof PurchaseDetails
     */
    'status'?: PurchaseStatus;
    /**
     * 
     * @type {PurchaseDetailsStripe}
     * @memberof PurchaseDetails
     */
    'stripe'?: PurchaseDetailsStripe | null;
}
/**
 * 
 * @export
 * @interface PurchaseDetailsStripe
 */
export interface PurchaseDetailsStripe {
    /**
     * 
     * @type {string}
     * @memberof PurchaseDetailsStripe
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseDetailsStripe
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseDetailsStripe
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseDetailsStripe
     */
    'subscriptionItemId'?: string;
}
/**
 * 
 * @export
 * @interface PurchaseDetailsTrial
 */
export interface PurchaseDetailsTrial {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PurchaseDetailsTrial
     */
    'expiry'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PurchaseStatus = {
    Paid: 'paid',
    Cancelled: 'cancelled',
    PendingPayment: 'pending-payment',
    Voided: 'voided'
} as const;

export type PurchaseStatus = typeof PurchaseStatus[keyof typeof PurchaseStatus];


/**
 * 
 * @export
 * @interface PurchasedAccountsGet200Response
 */
export interface PurchasedAccountsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof PurchasedAccountsGet200Response
     */
    'allowCustomMarketingMessage': boolean;
    /**
     * 
     * @type {Array<AccountPurchase>}
     * @memberof PurchasedAccountsGet200Response
     */
    'accounts': Array<AccountPurchase>;
}
/**
 * 
 * @export
 * @interface ReferralCodeData
 */
export interface ReferralCodeData {
    /**
     * 
     * @type {string}
     * @memberof ReferralCodeData
     */
    'code': string;
    /**
     * 
     * @type {PriceDetails}
     * @memberof ReferralCodeData
     */
    'credit': PriceDetails;
}
/**
 * Object which stores referral code details
 * @export
 * @interface ReferralCodeDetails
 */
export interface ReferralCodeDetails {
    /**
     * referralCode string
     * @type {string}
     * @memberof ReferralCodeDetails
     */
    'referralCode': string;
    /**
     * ID of the product purchased
     * @type {string}
     * @memberof ReferralCodeDetails
     */
    'productId': string;
    /**
     * teamId of partnerAdmin associated with the referralCode
     * @type {string}
     * @memberof ReferralCodeDetails
     */
    'partnerAdminTeam': string;
    /**
     * partnerAdmin of team associated with the referralCode
     * @type {string}
     * @memberof ReferralCodeDetails
     */
    'partnerAdmin': string;
    /**
     * time the product can be used for in days
     * @type {number}
     * @memberof ReferralCodeDetails
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ReferralCodeDetails
     */
    'referralCodeExpiry'?: string;
    /**
     * userId of creator of the code
     * @type {string}
     * @memberof ReferralCodeDetails
     */
    'createdBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ReferralCodeDetails
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface ReferralsPost200Response
 */
export interface ReferralsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ReferralsPost200Response
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface SessionCreateOptions
 */
export interface SessionCreateOptions {
    /**
     * 
     * @type {string}
     * @memberof SessionCreateOptions
     */
    'coupon'?: string;
    /**
     * 
     * @type {Array<SessionCreateOptionsProductsInner>}
     * @memberof SessionCreateOptions
     */
    'products': Array<SessionCreateOptionsProductsInner>;
    /**
     * set free trial. Can only set using admin access
     * @type {number}
     * @memberof SessionCreateOptions
     */
    'freeTrialDays'?: number;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof SessionCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {SessionCreateOptionsCallbackUrls}
     * @memberof SessionCreateOptions
     */
    'callbackUrls': SessionCreateOptionsCallbackUrls;
}
/**
 * 
 * @export
 * @interface SessionCreateOptionsCallbackUrls
 */
export interface SessionCreateOptionsCallbackUrls {
    /**
     * 
     * @type {string}
     * @memberof SessionCreateOptionsCallbackUrls
     */
    'success': string;
    /**
     * 
     * @type {string}
     * @memberof SessionCreateOptionsCallbackUrls
     */
    'failure': string;
}
/**
 * 
 * @export
 * @interface SessionCreateOptionsProductsInner
 */
export interface SessionCreateOptionsProductsInner {
    /**
     * 
     * @type {string}
     * @memberof SessionCreateOptionsProductsInner
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof SessionCreateOptionsProductsInner
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface SessionPost200Response
 */
export interface SessionPost200Response {
    /**
     * 
     * @type {string}
     * @memberof SessionPost200Response
     */
    'sessionId': string;
}
/**
 * 
 * @export
 * @interface StripeHook200Response
 */
export interface StripeHook200Response {
    /**
     * 
     * @type {string}
     * @memberof StripeHook200Response
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof StripeHook200Response
     */
    'description': string;
}

/**
 * CouponCodesApi - axios parameter creator
 * @export
 */
export const CouponCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost: async (couponCodeCreateOptions?: CouponCodeCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponCodeCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponCodesApi - functional programming interface
 * @export
 */
export const CouponCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsPost(couponCodeCreateOptions?: CouponCodeCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsPost(couponCodeCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CouponCodesApi - factory interface
 * @export
 */
export const CouponCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponCodesApiFp(configuration)
    return {
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost(couponCodeCreateOptions?: CouponCodeCreateOptions, options?: any): AxiosPromise<ReferralsPost200Response> {
            return localVarFp.couponsPost(couponCodeCreateOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for couponsPost operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCouponsPostRequest
 */
export interface CouponCodesApiCouponsPostRequest {
    /**
     * 
     * @type {CouponCodeCreateOptions}
     * @memberof CouponCodesApiCouponsPost
     */
    readonly couponCodeCreateOptions?: CouponCodeCreateOptions
}

/**
 * CouponCodesApi - object-oriented interface
 * @export
 * @class CouponCodesApi
 * @extends {BaseAPI}
 */
export class CouponCodesApi extends BaseAPI {
    /**
     * Generate a coupon code
     * @param {CouponCodesApiCouponsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public couponsPost(requestParameters: CouponCodesApiCouponsPostRequest = {}, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).couponsPost(requestParameters.couponCodeCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Most properties can be updated from here. However, some properties require the Stripe dashboard, these properties are: - id - price - categoryId - active (if stripe produce is inactive, then the DB will reflect the same) 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch: async (id: string, productUpdate?: ProductUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsPatch', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync products with stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsSync: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Most properties can be updated from here. However, some properties require the Stripe dashboard, these properties are: - id - price - categoryId - active (if stripe produce is inactive, then the DB will reflect the same) 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPatch(id: string, productUpdate?: ProductUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPatch(id, productUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync products with stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsSync(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsSync(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(options?: any): AxiosPromise<ProductsGet200Response> {
            return localVarFp.productsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Most properties can be updated from here. However, some properties require the Stripe dashboard, these properties are: - id - price - categoryId - active (if stripe produce is inactive, then the DB will reflect the same) 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch(id: string, productUpdate?: ProductUpdate, options?: any): AxiosPromise<Product> {
            return localVarFp.productsPatch(id, productUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync products with stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsSync(options?: any): AxiosPromise<void> {
            return localVarFp.productsSync(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsPatch operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsPatchRequest
 */
export interface ProductsApiProductsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPatch
     */
    readonly id: string

    /**
     * 
     * @type {ProductUpdate}
     * @memberof ProductsApiProductsPatch
     */
    readonly productUpdate?: ProductUpdate
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Get all products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGet(options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Most properties can be updated from here. However, some properties require the Stripe dashboard, these properties are: - id - price - categoryId - active (if stripe produce is inactive, then the DB will reflect the same) 
     * @summary Update a product\'s properties
     * @param {ProductsApiProductsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPatch(requestParameters: ProductsApiProductsPatchRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPatch(requestParameters.id, requestParameters.productUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync products with stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsSync(options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsSync(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PurchasesApi - axios parameter creator
 * @export
 */
export const PurchasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of active features & limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel a subscription
         * @param {string} purchaseId The purchase id to update
         * @param {boolean} [voidPurchase] If true, the subscription is voided and the features are removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainDelete: async (purchaseId: string, voidPurchase?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseId' is not null or undefined
            assertParamExists('mainDelete', 'purchaseId', purchaseId)
            const localVarPath = `/purchases/{purchaseId}`
                .replace(`{${"purchaseId"}}`, encodeURIComponent(String(purchaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (voidPurchase !== undefined) {
                localVarQueryParameter['voidPurchase'] = voidPurchase;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of products, active subscriptions, and other metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ", "PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Method will update the underlying stripe subscription of the specified purchase ID
         * @summary Upgrade/Downgrade a Subscription
         * @param {string} purchaseId The purchase id to update
         * @param {MainPatchRequest} [mainPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainPatch: async (purchaseId: string, mainPatchRequest?: MainPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'purchaseId' is not null or undefined
            assertParamExists('mainPatch', 'purchaseId', purchaseId)
            const localVarPath = `/purchases/{purchaseId}`
                .replace(`{${"purchaseId"}}`, encodeURIComponent(String(purchaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mainPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase a product
         * @param {MainPostRequest} [mainPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainPost: async (mainPostRequest?: MainPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mainPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainRefresh: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of accounts purchased via the \"auto-charge\" API
         * @param {string} [id] 
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasedAccountsGet: async (id?: string, count?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all purchases
         * @param {boolean} [onlyValid] If true, only unexpired &amp; active purchases will be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasesGet: async (onlyValid?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchases/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ", "PAYMENTS_UPDATE"], configuration)

            if (onlyValid !== undefined) {
                localVarQueryParameter['onlyValid'] = onlyValid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PurchasesApi - functional programming interface
 * @export
 */
export const PurchasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PurchasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the list of active features & limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel a subscription
         * @param {string} purchaseId The purchase id to update
         * @param {boolean} [voidPurchase] If true, the subscription is voided and the features are removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainDelete(purchaseId: string, voidPurchase?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainDelete(purchaseId, voidPurchase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of products, active subscriptions, and other metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Method will update the underlying stripe subscription of the specified purchase ID
         * @summary Upgrade/Downgrade a Subscription
         * @param {string} purchaseId The purchase id to update
         * @param {MainPatchRequest} [mainPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainPatch(purchaseId: string, mainPatchRequest?: MainPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainPatch(purchaseId, mainPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purchase a product
         * @param {MainPostRequest} [mainPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainPost(mainPostRequest?: MainPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainPost(mainPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainRefresh(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainRefresh200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainRefresh(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of accounts purchased via the \"auto-charge\" API
         * @param {string} [id] 
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasedAccountsGet(id?: string, count?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchasedAccountsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchasedAccountsGet(id, count, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all purchases
         * @param {boolean} [onlyValid] If true, only unexpired &amp; active purchases will be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasesGet(onlyValid?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchasesGet(onlyValid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PurchasesApi - factory interface
 * @export
 */
export const PurchasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PurchasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the list of active features & limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeGet(options?: any): AxiosPromise<ActiveModel> {
            return localVarFp.activeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel a subscription
         * @param {string} purchaseId The purchase id to update
         * @param {boolean} [voidPurchase] If true, the subscription is voided and the features are removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainDelete(purchaseId: string, voidPurchase?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.mainDelete(purchaseId, voidPurchase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of products, active subscriptions, and other metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet(options?: any): AxiosPromise<ProductsGet200Response> {
            return localVarFp.mainGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Method will update the underlying stripe subscription of the specified purchase ID
         * @summary Upgrade/Downgrade a Subscription
         * @param {string} purchaseId The purchase id to update
         * @param {MainPatchRequest} [mainPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainPatch(purchaseId: string, mainPatchRequest?: MainPatchRequest, options?: any): AxiosPromise<void> {
            return localVarFp.mainPatch(purchaseId, mainPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchase a product
         * @param {MainPostRequest} [mainPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainPost(mainPostRequest?: MainPostRequest, options?: any): AxiosPromise<MainPost200Response> {
            return localVarFp.mainPost(mainPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainRefresh(options?: any): AxiosPromise<MainRefresh200Response> {
            return localVarFp.mainRefresh(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of accounts purchased via the \"auto-charge\" API
         * @param {string} [id] 
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasedAccountsGet(id?: string, count?: number, page?: number, options?: any): AxiosPromise<PurchasedAccountsGet200Response> {
            return localVarFp.purchasedAccountsGet(id, count, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all purchases
         * @param {boolean} [onlyValid] If true, only unexpired &amp; active purchases will be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasesGet(onlyValid?: boolean, options?: any): AxiosPromise<MainPost200Response> {
            return localVarFp.purchasesGet(onlyValid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for mainDelete operation in PurchasesApi.
 * @export
 * @interface PurchasesApiMainDeleteRequest
 */
export interface PurchasesApiMainDeleteRequest {
    /**
     * The purchase id to update
     * @type {string}
     * @memberof PurchasesApiMainDelete
     */
    readonly purchaseId: string

    /**
     * If true, the subscription is voided and the features are removed
     * @type {boolean}
     * @memberof PurchasesApiMainDelete
     */
    readonly voidPurchase?: boolean
}

/**
 * Request parameters for mainPatch operation in PurchasesApi.
 * @export
 * @interface PurchasesApiMainPatchRequest
 */
export interface PurchasesApiMainPatchRequest {
    /**
     * The purchase id to update
     * @type {string}
     * @memberof PurchasesApiMainPatch
     */
    readonly purchaseId: string

    /**
     * 
     * @type {MainPatchRequest}
     * @memberof PurchasesApiMainPatch
     */
    readonly mainPatchRequest?: MainPatchRequest
}

/**
 * Request parameters for mainPost operation in PurchasesApi.
 * @export
 * @interface PurchasesApiMainPostRequest
 */
export interface PurchasesApiMainPostRequest {
    /**
     * 
     * @type {MainPostRequest}
     * @memberof PurchasesApiMainPost
     */
    readonly mainPostRequest?: MainPostRequest
}

/**
 * Request parameters for purchasedAccountsGet operation in PurchasesApi.
 * @export
 * @interface PurchasesApiPurchasedAccountsGetRequest
 */
export interface PurchasesApiPurchasedAccountsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PurchasesApiPurchasedAccountsGet
     */
    readonly id?: string

    /**
     * 
     * @type {number}
     * @memberof PurchasesApiPurchasedAccountsGet
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof PurchasesApiPurchasedAccountsGet
     */
    readonly page?: number
}

/**
 * Request parameters for purchasesGet operation in PurchasesApi.
 * @export
 * @interface PurchasesApiPurchasesGetRequest
 */
export interface PurchasesApiPurchasesGetRequest {
    /**
     * If true, only unexpired &amp; active purchases will be sent
     * @type {boolean}
     * @memberof PurchasesApiPurchasesGet
     */
    readonly onlyValid?: boolean
}

/**
 * PurchasesApi - object-oriented interface
 * @export
 * @class PurchasesApi
 * @extends {BaseAPI}
 */
export class PurchasesApi extends BaseAPI {
    /**
     * 
     * @summary Get the list of active features & limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public activeGet(options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).activeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel a subscription
     * @param {PurchasesApiMainDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainDelete(requestParameters: PurchasesApiMainDeleteRequest, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainDelete(requestParameters.purchaseId, requestParameters.voidPurchase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of products, active subscriptions, and other metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainGet(options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Method will update the underlying stripe subscription of the specified purchase ID
     * @summary Upgrade/Downgrade a Subscription
     * @param {PurchasesApiMainPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainPatch(requestParameters: PurchasesApiMainPatchRequest, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainPatch(requestParameters.purchaseId, requestParameters.mainPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchase a product
     * @param {PurchasesApiMainPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainPost(requestParameters: PurchasesApiMainPostRequest = {}, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainPost(requestParameters.mainPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
     * @summary Refreshes the subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public mainRefresh(options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).mainRefresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of accounts purchased via the \"auto-charge\" API
     * @param {PurchasesApiPurchasedAccountsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public purchasedAccountsGet(requestParameters: PurchasesApiPurchasedAccountsGetRequest = {}, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).purchasedAccountsGet(requestParameters.id, requestParameters.count, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all purchases
     * @param {PurchasesApiPurchasesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchasesApi
     */
    public purchasesGet(requestParameters: PurchasesApiPurchasesGetRequest = {}, options?: AxiosRequestConfig) {
        return PurchasesApiFp(this.configuration).purchasesGet(requestParameters.onlyValid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferralsApi - axios parameter creator
 * @export
 */
export const ReferralsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner: async (referralCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('getPartner', 'referralCode', referralCode)
            const localVarPath = `/partner-referral/get-partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsDelete: async (referralCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('partnerReferralsDelete', 'referralCode', referralCode)
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsGet: async (page?: number, count?: number, id?: Array<string>, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsPost: async (partnerReferralCreateOptions?: PartnerReferralCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerReferralCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/referrals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/referrals/apply-credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["REFERRAL_APPLY_CREDIT"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralsApi - functional programming interface
 * @export
 */
export const ReferralsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartner(referralCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPartner200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartner(referralCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsDelete(referralCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsDelete(referralCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsGet(page?: number, count?: number, id?: Array<string>, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerReferralsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsGet(page, count, id, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsPost(partnerReferralCreateOptions?: PartnerReferralCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerReferralsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsPost(partnerReferralCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referralsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralCodeData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referralsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referralsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referralsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferralsApi - factory interface
 * @export
 */
export const ReferralsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner(referralCode: string, options?: any): AxiosPromise<GetPartner200Response> {
            return localVarFp.getPartner(referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsDelete(referralCode: string, options?: any): AxiosPromise<void> {
            return localVarFp.partnerReferralsDelete(referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsGet(page?: number, count?: number, id?: Array<string>, q?: string, options?: any): AxiosPromise<PartnerReferralsGet200Response> {
            return localVarFp.partnerReferralsGet(page, count, id, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsPost(partnerReferralCreateOptions?: PartnerReferralCreateOptions, options?: any): AxiosPromise<PartnerReferralsPost200Response> {
            return localVarFp.partnerReferralsPost(partnerReferralCreateOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralsGet(options?: any): AxiosPromise<ReferralCodeData> {
            return localVarFp.referralsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralsPost(options?: any): AxiosPromise<ReferralsPost200Response> {
            return localVarFp.referralsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPartner operation in ReferralsApi.
 * @export
 * @interface ReferralsApiGetPartnerRequest
 */
export interface ReferralsApiGetPartnerRequest {
    /**
     * 
     * @type {string}
     * @memberof ReferralsApiGetPartner
     */
    readonly referralCode: string
}

/**
 * Request parameters for partnerReferralsDelete operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsDeleteRequest
 */
export interface ReferralsApiPartnerReferralsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ReferralsApiPartnerReferralsDelete
     */
    readonly referralCode: string
}

/**
 * Request parameters for partnerReferralsGet operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsGetRequest
 */
export interface ReferralsApiPartnerReferralsGetRequest {
    /**
     * The page for the cursor
     * @type {number}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly page?: number

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly count?: number

    /**
     * The array of referralCodes to be fetched
     * @type {Array<string>}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly id?: Array<string>

    /**
     * Search by id, productId, etc
     * @type {string}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly q?: string
}

/**
 * Request parameters for partnerReferralsPost operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsPostRequest
 */
export interface ReferralsApiPartnerReferralsPostRequest {
    /**
     * 
     * @type {PartnerReferralCreateOptions}
     * @memberof ReferralsApiPartnerReferralsPost
     */
    readonly partnerReferralCreateOptions?: PartnerReferralCreateOptions
}

/**
 * ReferralsApi - object-oriented interface
 * @export
 * @class ReferralsApi
 * @extends {BaseAPI}
 */
export class ReferralsApi extends BaseAPI {
    /**
     * 
     * @param {ReferralsApiGetPartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public getPartner(requestParameters: ReferralsApiGetPartnerRequest, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).getPartner(requestParameters.referralCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsDelete(requestParameters: ReferralsApiPartnerReferralsDeleteRequest, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsDelete(requestParameters.referralCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsGet(requestParameters: ReferralsApiPartnerReferralsGetRequest = {}, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsGet(requestParameters.page, requestParameters.count, requestParameters.id, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsPost(requestParameters: ReferralsApiPartnerReferralsPostRequest = {}, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsPost(requestParameters.partnerReferralCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public referralsGet(options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).referralsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public referralsPost(options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).referralsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Payment method must be added to the Stripe portal for auto-charging to work
         * @summary Auto charge without a checkout session to get a standard product
         * @param {string} [coupon] 
         * @param {AutoChargeRequest} [autoChargeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoCharge: async (coupon?: string, autoChargeRequest?: AutoChargeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auto-charge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (coupon !== undefined) {
                localVarQueryParameter['coupon'] = coupon;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoChargeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only available for API account subscriptions
         * @summary Cancel an auto charged product
         * @param {string} id ID of the purchase to cancel
         * @param {'account'} type Type of the purchase to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeDelete: async (id: string, type: 'account', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('autoChargeDelete', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('autoChargeDelete', 'type', type)
            const localVarPath = `/auto-charge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost: async (returnUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'returnUrl' is not null or undefined
            assertParamExists('billingSessionPost', 'returnUrl', returnUrl)
            const localVarPath = `/billing-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new stripe session
         * @param {SessionCreateOptions} [sessionCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPost: async (sessionCreateOptions?: SessionCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook: async (requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-hook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication stripe required
            await setApiKeyToObject(localVarHeaderParameter, "stripe-signature", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * Payment method must be added to the Stripe portal for auto-charging to work
         * @summary Auto charge without a checkout session to get a standard product
         * @param {string} [coupon] 
         * @param {AutoChargeRequest} [autoChargeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoCharge(coupon?: string, autoChargeRequest?: AutoChargeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoCharge(coupon, autoChargeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only available for API account subscriptions
         * @summary Cancel an auto charged product
         * @param {string} id ID of the purchase to cancel
         * @param {'account'} type Type of the purchase to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeDelete(id: string, type: 'account', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeDelete(id, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingSessionPost(returnUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSessionPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingSessionPost(returnUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new stripe session
         * @param {SessionCreateOptions} [sessionCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionPost(sessionCreateOptions?: SessionCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionPost(sessionCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeHook(requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeHook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeHook(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * Payment method must be added to the Stripe portal for auto-charging to work
         * @summary Auto charge without a checkout session to get a standard product
         * @param {string} [coupon] 
         * @param {AutoChargeRequest} [autoChargeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoCharge(coupon?: string, autoChargeRequest?: AutoChargeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.autoCharge(coupon, autoChargeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Only available for API account subscriptions
         * @summary Cancel an auto charged product
         * @param {string} id ID of the purchase to cancel
         * @param {'account'} type Type of the purchase to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeDelete(id: string, type: 'account', options?: any): AxiosPromise<void> {
            return localVarFp.autoChargeDelete(id, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost(returnUrl: string, options?: any): AxiosPromise<BillingSessionPost200Response> {
            return localVarFp.billingSessionPost(returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new stripe session
         * @param {SessionCreateOptions} [sessionCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionPost(sessionCreateOptions?: SessionCreateOptions, options?: any): AxiosPromise<SessionPost200Response> {
            return localVarFp.sessionPost(sessionCreateOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook(requestBody?: { [key: string]: any; }, options?: any): AxiosPromise<StripeHook200Response> {
            return localVarFp.stripeHook(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autoCharge operation in StripeApi.
 * @export
 * @interface StripeApiAutoChargeRequest
 */
export interface StripeApiAutoChargeRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiAutoCharge
     */
    readonly coupon?: string

    /**
     * 
     * @type {AutoChargeRequest}
     * @memberof StripeApiAutoCharge
     */
    readonly autoChargeRequest?: AutoChargeRequest
}

/**
 * Request parameters for autoChargeDelete operation in StripeApi.
 * @export
 * @interface StripeApiAutoChargeDeleteRequest
 */
export interface StripeApiAutoChargeDeleteRequest {
    /**
     * ID of the purchase to cancel
     * @type {string}
     * @memberof StripeApiAutoChargeDelete
     */
    readonly id: string

    /**
     * Type of the purchase to cancel
     * @type {'account'}
     * @memberof StripeApiAutoChargeDelete
     */
    readonly type: 'account'
}

/**
 * Request parameters for billingSessionPost operation in StripeApi.
 * @export
 * @interface StripeApiBillingSessionPostRequest
 */
export interface StripeApiBillingSessionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiBillingSessionPost
     */
    readonly returnUrl: string
}

/**
 * Request parameters for sessionPost operation in StripeApi.
 * @export
 * @interface StripeApiSessionPostRequest
 */
export interface StripeApiSessionPostRequest {
    /**
     * 
     * @type {SessionCreateOptions}
     * @memberof StripeApiSessionPost
     */
    readonly sessionCreateOptions?: SessionCreateOptions
}

/**
 * Request parameters for stripeHook operation in StripeApi.
 * @export
 * @interface StripeApiStripeHookRequest
 */
export interface StripeApiStripeHookRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof StripeApiStripeHook
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * Payment method must be added to the Stripe portal for auto-charging to work
     * @summary Auto charge without a checkout session to get a standard product
     * @param {StripeApiAutoChargeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public autoCharge(requestParameters: StripeApiAutoChargeRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).autoCharge(requestParameters.coupon, requestParameters.autoChargeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only available for API account subscriptions
     * @summary Cancel an auto charged product
     * @param {StripeApiAutoChargeDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public autoChargeDelete(requestParameters: StripeApiAutoChargeDeleteRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).autoChargeDelete(requestParameters.id, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new billing portal session to manage payment details
     * @param {StripeApiBillingSessionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public billingSessionPost(requestParameters: StripeApiBillingSessionPostRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).billingSessionPost(requestParameters.returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new stripe session
     * @param {StripeApiSessionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public sessionPost(requestParameters: StripeApiSessionPostRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).sessionPost(requestParameters.sessionCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive stripe hook
     * @param {StripeApiStripeHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeHook(requestParameters: StripeApiStripeHookRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeHook(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


