const BASE_PATH = "https://api-bots.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Bots Service
 * Make, Get & Execute Bots
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Action
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Action
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'id': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Action
     */
    'botId'?: string;
    /**
     * Name of the template
     * @type {string}
     * @memberof Action
     */
    'name': string;
    /**
     * 
     * @type {MessageObj}
     * @memberof Action
     */
    'message'?: MessageObj | null;
    /**
     * set the assignee on the contact
     * @type {string}
     * @memberof Action
     */
    'assignee'?: string | null;
    /**
     * Tags to set on this contact.
     * @type {Array<ActionContentTagsInner>}
     * @memberof Action
     */
    'tags'?: Array<ActionContentTagsInner> | null;
    /**
     * Array of UserId
     * @type {Array<string>}
     * @memberof Action
     */
    'notifyUsers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Action
     */
    'webhooks'?: Array<string>;
    /**
     * 
     * @type {Position}
     * @memberof Action
     */
    'position'?: Position;
    /**
     * send in to remove the action
     * @type {boolean}
     * @memberof Action
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface ActionAllOf
 */
export interface ActionAllOf {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionAllOf
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionAllOf
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ActionContent
 */
export interface ActionContent {
    /**
     * 
     * @type {string}
     * @memberof ActionContent
     */
    'id'?: string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof ActionContent
     */
    'botId'?: string;
    /**
     * Name of the template
     * @type {string}
     * @memberof ActionContent
     */
    'name'?: string;
    /**
     * 
     * @type {MessageObj}
     * @memberof ActionContent
     */
    'message'?: MessageObj | null;
    /**
     * set the assignee on the contact
     * @type {string}
     * @memberof ActionContent
     */
    'assignee'?: string | null;
    /**
     * Tags to set on this contact.
     * @type {Array<ActionContentTagsInner>}
     * @memberof ActionContent
     */
    'tags'?: Array<ActionContentTagsInner> | null;
    /**
     * Array of UserId
     * @type {Array<string>}
     * @memberof ActionContent
     */
    'notifyUsers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ActionContent
     */
    'webhooks'?: Array<string>;
    /**
     * 
     * @type {Position}
     * @memberof ActionContent
     */
    'position'?: Position;
    /**
     * send in to remove the action
     * @type {boolean}
     * @memberof ActionContent
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface ActionContentTagsInner
 */
export interface ActionContentTagsInner {
    /**
     * 
     * @type {string}
     * @memberof ActionContentTagsInner
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ActionContentTagsInner
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface ActionFireRecord
 */
export interface ActionFireRecord {
    /**
     * 
     * @type {number}
     * @memberof ActionFireRecord
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'actionId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'instanceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'status'?: ActionFireRecordStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'contactId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'accountId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionFireRecord
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ActionFireRecord
     */
    'messages'?: Array<ServiceResponse>;
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ActionFireRecord
     */
    'webhooks'?: Array<ServiceResponse>;
    /**
     * 
     * @type {ServiceResponse}
     * @memberof ActionFireRecord
     */
    'contact'?: ServiceResponse;
    /**
     * 
     * @type {boolean}
     * @memberof ActionFireRecord
     */
    'isStart'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ActionFireRecord
     */
    'isFinal'?: boolean;
}

export const ActionFireRecordStatusEnum = {
    Pending: 'pending',
    Sent: 'sent',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;

export type ActionFireRecordStatusEnum = typeof ActionFireRecordStatusEnum[keyof typeof ActionFireRecordStatusEnum];

/**
 * 
 * @export
 * @interface ActionsGet200Response
 */
export interface ActionsGet200Response {
    /**
     * 
     * @type {Array<Action>}
     * @memberof ActionsGet200Response
     */
    'actions': Array<Action>;
    /**
     * Name of the last record fetched
     * @type {string}
     * @memberof ActionsGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ActionsGptGenerate200Response
 */
export interface ActionsGptGenerate200Response {
    /**
     * 
     * @type {Array<ActionContent>}
     * @memberof ActionsGptGenerate200Response
     */
    'actions': Array<ActionContent>;
}
/**
 * 
 * @export
 * @interface ActionsGptGenerateRequest
 */
export interface ActionsGptGenerateRequest {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'actionId': string;
    /**
     * 
     * @type {Array<ActionContent>}
     * @memberof ActionsGptGenerateRequest
     */
    'actions': Array<ActionContent>;
    /**
     * 
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'industry': string;
    /**
     * 
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'additionalContext'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionsGptGenerateRequest
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface Bot
 */
export interface Bot {
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'name': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Bot
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'startingActionId'?: string | null;
    /**
     * 
     * @type {Array<Action>}
     * @memberof Bot
     */
    'actions'?: Array<Action>;
    /**
     * 
     * @type {Array<BotTrigger>}
     * @memberof Bot
     */
    'startTriggers'?: Array<BotTrigger>;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'folderId'?: string | null;
    /**
     * 
     * @type {{ [key: string]: ExternalTemplateProvider; }}
     * @memberof Bot
     */
    'externalTemplate'?: { [key: string]: ExternalTemplateProvider; };
    /**
     * URL of the thumbnail image
     * @type {string}
     * @memberof Bot
     */
    'imageUrl'?: string;
    /**
     * Description of the bot
     * @type {string}
     * @memberof Bot
     */
    'description'?: string;
    /**
     * Industry of the bot
     * @type {string}
     * @memberof Bot
     */
    'industry'?: string;
    /**
     * Language of the bot
     * @type {string}
     * @memberof Bot
     */
    'language'?: string;
    /**
     * 
     * @type {Array<BotNote>}
     * @memberof Bot
     */
    'notes'?: Array<BotNote>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Bot
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Bot
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface BotCondition
 */
export interface BotCondition {
    /**
     * 
     * @type {string}
     * @memberof BotCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {BotConditionValues}
     * @memberof BotCondition
     */
    'values': BotConditionValues;
    /**
     * 
     * @type {string}
     * @memberof BotCondition
     */
    'operator': BotConditionOperatorEnum;
}

export const BotConditionOperatorEnum = {
    Equals: 'equals',
    NotEquals: 'notEquals',
    GreaterThan: 'greaterThan',
    LessThan: 'lessThan',
    GreaterThanOrEquals: 'greaterThanOrEquals',
    LessThanOrEquals: 'lessThanOrEquals',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    EndsWith: 'endsWith'
} as const;

export type BotConditionOperatorEnum = typeof BotConditionOperatorEnum[keyof typeof BotConditionOperatorEnum];

/**
 * @type BotConditionValues
 * @export
 */
export type BotConditionValues = Array<number> | Array<string>;

/**
 * 
 * @export
 * @interface BotMessageButton
 */
export interface BotMessageButton {
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'triggerActionId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'triggerBotId'?: string | null;
    /**
     * Make a button with a link
     * @type {string}
     * @memberof BotMessageButton
     */
    'url'?: string;
    /**
     * Make a button with a phone number
     * @type {string}
     * @memberof BotMessageButton
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {Position}
     * @memberof BotMessageButton
     */
    'position'?: Position;
}
/**
 * 
 * @export
 * @interface BotMessageDelay
 */
export interface BotMessageDelay {
    /**
     * Time delays on second
     * @type {number}
     * @memberof BotMessageDelay
     */
    'timeDelaySec': number;
    /**
     * 
     * @type {string}
     * @memberof BotMessageDelay
     */
    'triggerActionId': string;
    /**
     * 
     * @type {string}
     * @memberof BotMessageDelay
     */
    'triggerBotId'?: string | null;
    /**
     * Simulate typing
     * @type {boolean}
     * @memberof BotMessageDelay
     */
    'simulateTyping'?: boolean;
    /**
     * If true, the message will be cancelled if a reply is received
     * @type {boolean}
     * @memberof BotMessageDelay
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * 
     * @type {Position}
     * @memberof BotMessageDelay
     */
    'position'?: Position;
}
/**
 * 
 * @export
 * @interface BotNote
 */
export interface BotNote {
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'id'?: string;
    /**
     * 
     * @type {Array<IMMessageAttachment>}
     * @memberof BotNote
     */
    'attachments'?: Array<IMMessageAttachment>;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'title': string;
    /**
     * 
     * @type {Position}
     * @memberof BotNote
     */
    'position': Position;
    /**
     * send in to remove the note
     * @type {boolean}
     * @memberof BotNote
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface BotPatch
 */
export interface BotPatch {
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'startingActionId'?: string;
    /**
     * 
     * @type {Array<BotTrigger>}
     * @memberof BotPatch
     */
    'startTriggers'?: Array<BotTrigger>;
    /**
     * List of actions to edit/add. Do not specify the ID to add a new action
     * @type {Array<ActionContent>}
     * @memberof BotPatch
     */
    'actions'?: Array<ActionContent>;
    /**
     * 
     * @type {Array<BotNote>}
     * @memberof BotPatch
     */
    'notes'?: Array<BotNote>;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'industry'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'folderId'?: string;
}
/**
 * 
 * @export
 * @interface BotTrigger
 */
export interface BotTrigger {
    /**
     * 
     * @type {string}
     * @memberof BotTrigger
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BotTrigger
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BotTrigger
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof BotTrigger
     */
    'botId': string;
    /**
     * 
     * @type {boolean}
     * @memberof BotTrigger
     */
    'enabled': boolean;
    /**
     * Time interval between each message sent in seconds
     * @type {number}
     * @memberof BotTrigger
     */
    'sendInterval'?: number;
    /**
     * 
     * @type {Array<BotCondition>}
     * @memberof BotTrigger
     */
    'conditions'?: Array<BotCondition>;
    /**
     * Additional context for the triggering of the bot. 
     * @type {{ [key: string]: any; }}
     * @memberof BotTrigger
     */
    'context'?: { [key: string]: any; };
    /**
     * 
     * @type {BotTriggerMethod}
     * @memberof BotTrigger
     */
    'method': BotTriggerMethod;
    /**
     * 
     * @type {BotTriggerTarget}
     * @memberof BotTrigger
     */
    'target': BotTriggerTarget;
    /**
     * 
     * @type {BotTriggerSendOptions}
     * @memberof BotTrigger
     */
    'options'?: BotTriggerSendOptions;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTrigger
     */
    'lastTriggered'?: string;
    /**
     * 
     * @type {number}
     * @memberof BotTrigger
     */
    'triggered'?: number;
    /**
     * 
     * @type {Array<BotTriggerInstance>}
     * @memberof BotTrigger
     */
    'instances'?: Array<BotTriggerInstance>;
}
/**
 * 
 * @export
 * @interface BotTriggerContext
 */
export interface BotTriggerContext {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerContext
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface BotTriggerInstance
 */
export interface BotTriggerInstance {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggerInstance
     */
    'payload'?: { [key: string]: any; };
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'startedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'status'?: BotTriggerInstanceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'triggerId'?: string;
    /**
     * 
     * @type {Array<ActionFireRecord>}
     * @memberof BotTriggerInstance
     */
    'records'?: Array<ActionFireRecord>;
}

export const BotTriggerInstanceStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type BotTriggerInstanceStatusEnum = typeof BotTriggerInstanceStatusEnum[keyof typeof BotTriggerInstanceStatusEnum];

/**
 * 
 * @export
 * @interface BotTriggerInstancesGet200Response
 */
export interface BotTriggerInstancesGet200Response {
    /**
     * 
     * @type {Array<BotTriggerInstance>}
     * @memberof BotTriggerInstancesGet200Response
     */
    'instances': Array<BotTriggerInstance>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof BotTriggerInstancesGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface BotTriggerMethod
 */
export interface BotTriggerMethod {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerMethod
     */
    'type': BotTriggerMethodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BotTriggerMethod
     */
    'value'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerMethod
     */
    'nextExecutionDate'?: string;
}

export const BotTriggerMethodTypeEnum = {
    Webhook: 'webhook',
    Timestamp: 'timestamp',
    Event: 'event'
} as const;

export type BotTriggerMethodTypeEnum = typeof BotTriggerMethodTypeEnum[keyof typeof BotTriggerMethodTypeEnum];

/**
 * 
 * @export
 * @interface BotTriggerPayload
 */
export interface BotTriggerPayload {
    /**
     * 
     * @type {BotTriggerPayloadContact}
     * @memberof BotTriggerPayload
     */
    'contact': BotTriggerPayloadContact;
    /**
     * The data that is being sent to the bot. The data has the following properties
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggerPayload
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {BotTriggerContext}
     * @memberof BotTriggerPayload
     */
    'context': BotTriggerContext;
}
/**
 * The contact that the message is being sent to. The contact properties such as the following and more. check IM service for full contact object
 * @export
 * @interface BotTriggerPayloadContact
 */
export interface BotTriggerPayloadContact {
    [key: string]: any;

    /**
     * ID of the contact
     * @type {string}
     * @memberof BotTriggerPayloadContact
     */
    'id': string;
    /**
     * ID of the account
     * @type {string}
     * @memberof BotTriggerPayloadContact
     */
    'accountId': string;
    /**
     * Name of the contact
     * @type {string}
     * @memberof BotTriggerPayloadContact
     */
    'name'?: string;
    /**
     * Type of the contact
     * @type {string}
     * @memberof BotTriggerPayloadContact
     */
    'type'?: BotTriggerPayloadContactTypeEnum;
    /**
     * Tags on the contact
     * @type {Array<string>}
     * @memberof BotTriggerPayloadContact
     */
    'tags'?: Array<string>;
}

export const BotTriggerPayloadContactTypeEnum = {
    Individual: 'individual',
    Group: 'group'
} as const;

export type BotTriggerPayloadContactTypeEnum = typeof BotTriggerPayloadContactTypeEnum[keyof typeof BotTriggerPayloadContactTypeEnum];

/**
 * 
 * @export
 * @interface BotTriggerSendOptions
 */
export interface BotTriggerSendOptions {
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof BotTriggerSendOptions
     */
    'miscOptions'?: MessageSendOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggerSendOptions
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * @type BotTriggerTarget
 * @export
 */
export type BotTriggerTarget = BotTriggerTargetOneOf | BotTriggerTargetOneOf1;

/**
 * 
 * @export
 * @interface BotTriggerTargetOneOf
 */
export interface BotTriggerTargetOneOf {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerTargetOneOf
     */
    'type': BotTriggerTargetOneOfTypeEnum;
    /**
     * Path of the property to access in the payload. Payload has the following properties 1. \'contact.*\' to access a property of the contact being sent to. Find structure of contact here 2. \'data.*\' to access a property of the event data 3. \'context.*\' to access a property of the context (note: probably add context schema to openapi spec?)
     * @type {string}
     * @memberof BotTriggerTargetOneOf
     */
    'propertyPath': string;
    /**
     * 
     * @type {BotTriggerTargetOneOfAccountId}
     * @memberof BotTriggerTargetOneOf
     */
    'accountId': BotTriggerTargetOneOfAccountId;
}

export const BotTriggerTargetOneOfTypeEnum = {
    PropertyPath: 'propertyPath'
} as const;

export type BotTriggerTargetOneOfTypeEnum = typeof BotTriggerTargetOneOfTypeEnum[keyof typeof BotTriggerTargetOneOfTypeEnum];

/**
 * 
 * @export
 * @interface BotTriggerTargetOneOf1
 */
export interface BotTriggerTargetOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerTargetOneOf1
     */
    'type': BotTriggerTargetOneOf1TypeEnum;
    /**
     * 
     * @type {BotTriggerTargetQuery}
     * @memberof BotTriggerTargetOneOf1
     */
    'query': BotTriggerTargetQuery;
    /**
     * 
     * @type {BotTriggerTargetOneOf1AccountId}
     * @memberof BotTriggerTargetOneOf1
     */
    'accountId': BotTriggerTargetOneOf1AccountId;
}

export const BotTriggerTargetOneOf1TypeEnum = {
    Fetch: 'fetch'
} as const;

export type BotTriggerTargetOneOf1TypeEnum = typeof BotTriggerTargetOneOf1TypeEnum[keyof typeof BotTriggerTargetOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface BotTriggerTargetOneOf1AccountId
 */
export interface BotTriggerTargetOneOf1AccountId {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerTargetOneOf1AccountId
     */
    'type': BotTriggerTargetOneOf1AccountIdTypeEnum;
    /**
     * the property name to extract `accountId` from of the contact, or the exact ID of the account
     * @type {string}
     * @memberof BotTriggerTargetOneOf1AccountId
     */
    'value': string;
}

export const BotTriggerTargetOneOf1AccountIdTypeEnum = {
    PropertyPath: 'propertyPath',
    Exact: 'exact'
} as const;

export type BotTriggerTargetOneOf1AccountIdTypeEnum = typeof BotTriggerTargetOneOf1AccountIdTypeEnum[keyof typeof BotTriggerTargetOneOf1AccountIdTypeEnum];

/**
 * 
 * @export
 * @interface BotTriggerTargetOneOfAccountId
 */
export interface BotTriggerTargetOneOfAccountId {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerTargetOneOfAccountId
     */
    'type': BotTriggerTargetOneOfAccountIdTypeEnum;
    /**
     * the property name to extract `accountId` from, or the exact ID of the account
     * @type {string}
     * @memberof BotTriggerTargetOneOfAccountId
     */
    'value': string;
}

export const BotTriggerTargetOneOfAccountIdTypeEnum = {
    PropertyPath: 'propertyPath',
    Exact: 'exact'
} as const;

export type BotTriggerTargetOneOfAccountIdTypeEnum = typeof BotTriggerTargetOneOfAccountIdTypeEnum[keyof typeof BotTriggerTargetOneOfAccountIdTypeEnum];

/**
 * 
 * @export
 * @interface BotTriggerTargetQuery
 */
export interface BotTriggerTargetQuery {
    /**
     * 
     * @type {Array<string>}
     * @memberof BotTriggerTargetQuery
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotTriggerTargetQuery
     */
    'notTags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BotTriggerTargetQuery
     */
    'q'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BotTriggerTargetQuery
     */
    'minMessagesSent'?: number;
    /**
     * 
     * @type {number}
     * @memberof BotTriggerTargetQuery
     */
    'maxMessagesSent'?: number;
    /**
     * 
     * @type {number}
     * @memberof BotTriggerTargetQuery
     */
    'minMessagesRecv'?: number;
    /**
     * 
     * @type {number}
     * @memberof BotTriggerTargetQuery
     */
    'maxMessagesRecv'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotTriggerTargetQuery
     */
    'assignee'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotTriggerTargetQuery
     */
    'notAssignee'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BotTriggerTargetQuery
     */
    'type'?: BotTriggerTargetQueryTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotTriggerTargetQuery
     */
    'contacts'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotTriggerTargetQuery
     */
    'notContacts'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotTriggerTargetQuery
     */
    'accountId'?: Array<string>;
}

export const BotTriggerTargetQueryTypeEnum = {
    Individual: 'individual',
    Group: 'group'
} as const;

export type BotTriggerTargetQueryTypeEnum = typeof BotTriggerTargetQueryTypeEnum[keyof typeof BotTriggerTargetQueryTypeEnum];

/**
 * 
 * @export
 * @interface BotTriggerWebhookRequest
 */
export interface BotTriggerWebhookRequest {
    /**
     * Data to be sent to the webhook
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggerWebhookRequest
     */
    'data'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotTriggersPatchRequest
 */
export interface BotTriggersPatchRequest {
    /**
     * 
     * @type {Array<BotTrigger>}
     * @memberof BotTriggersPatchRequest
     */
    'botTriggers': Array<BotTrigger>;
}
/**
 * 
 * @export
 * @interface BotsCreateRequest
 */
export interface BotsCreateRequest {
    /**
     * Specify the ID of the bot to be created. Has to be globally unique
     * @type {string}
     * @memberof BotsCreateRequest
     */
    'id'?: string;
    /**
     * The name of the bot to be created
     * @type {string}
     * @memberof BotsCreateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BotsDataGet200Response
 */
export interface BotsDataGet200Response {
    /**
     * 
     * @type {Array<BotTrigger>}
     * @memberof BotsDataGet200Response
     */
    'triggers': Array<BotTrigger>;
    /**
     * 
     * @type {Array<Action>}
     * @memberof BotsDataGet200Response
     */
    'actions': Array<Action>;
    /**
     * 
     * @type {Array<BotNote>}
     * @memberof BotsDataGet200Response
     */
    'notes': Array<BotNote>;
}
/**
 * 
 * @export
 * @interface BotsExternalTemplateCommand200Response
 */
export interface BotsExternalTemplateCommand200Response {
    /**
     * 
     * @type {ExternalTemplateProvider}
     * @memberof BotsExternalTemplateCommand200Response
     */
    'config'?: ExternalTemplateProvider;
}
/**
 * 
 * @export
 * @interface BotsFireRequest
 */
export interface BotsFireRequest {
    /**
     * Which account to use
     * @type {string}
     * @memberof BotsFireRequest
     */
    'accountId'?: string;
    /**
     * Contact action is being fired to
     * @type {string}
     * @memberof BotsFireRequest
     */
    'toContact': string;
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof BotsFireRequest
     */
    'messageSendOptions'?: MessageSendOptions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotsFireRequest
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotsGetRecord200Response
 */
export interface BotsGetRecord200Response {
    /**
     * 
     * @type {Array<ActionFireRecord>}
     * @memberof BotsGetRecord200Response
     */
    'records': Array<ActionFireRecord>;
    /**
     * Name of the last record fetched
     * @type {string}
     * @memberof BotsGetRecord200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface BotsGets200Response
 */
export interface BotsGets200Response {
    /**
     * 
     * @type {Array<Bot>}
     * @memberof BotsGets200Response
     */
    'bots': Array<Bot>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof BotsGets200Response
     */
    'cursor'?: string;
    /**
     * total bots present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof BotsGets200Response
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface ExternalTemplateProvider
 */
export interface ExternalTemplateProvider {
    /**
     * ID of the template on the provider
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'category': string;
    /**
     * Language of the template
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'language'?: string;
    /**
     * Status of the template on the provider
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'status': ExternalTemplateProviderStatusEnum;
    /**
     * Details of the rejection, if rejected
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'rejectionDetails'?: string;
    /**
     * ID of the user who submitted the template
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'submittedBy': string;
}

export const ExternalTemplateProviderStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type ExternalTemplateProviderStatusEnum = typeof ExternalTemplateProviderStatusEnum[keyof typeof ExternalTemplateProviderStatusEnum];

/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'teamId': string;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'botCount': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Folder
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Folder
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface FolderCreateRequest
 */
export interface FolderCreateRequest {
    /**
     * Folder name
     * @type {string}
     * @memberof FolderCreateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FolderGet200Response
 */
export interface FolderGet200Response {
    /**
     * 
     * @type {Array<Folder>}
     * @memberof FolderGet200Response
     */
    'folders': Array<Folder>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof FolderGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface FolderUpdateRequest
 */
export interface FolderUpdateRequest {
    /**
     * Folder name
     * @type {string}
     * @memberof FolderUpdateRequest
     */
    'name'?: string;
    /**
     * Bot IDs to add to the folder
     * @type {Array<FolderUpdateRequestBotIdsInner>}
     * @memberof FolderUpdateRequest
     */
    'botIds'?: Array<FolderUpdateRequestBotIdsInner>;
}
/**
 * 
 * @export
 * @interface FolderUpdateRequestBotIdsInner
 */
export interface FolderUpdateRequestBotIdsInner {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FolderUpdateRequestBotIdsInner
     */
    'botId': string;
    /**
     * If true, remove the bot from the folder
     * @type {boolean}
     * @memberof FolderUpdateRequestBotIdsInner
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface IMMessageAttachment
 */
export interface IMMessageAttachment {
    /**
     * 
     * @type {IMMessageAttachmentType}
     * @memberof IMMessageAttachment
     */
    'type': IMMessageAttachmentType;
    /**
     * 
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'mimetype': string;
    /**
     * 1. can be publicly hosted url,  2. or can be base64 encoded buffer. But make sure it starts with `data:;base64,` Note: the `contact` type only supports base64 encoded data 
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'url': string;
    /**
     * thumbnail of sticker/video/image
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'jpegThumbnail'?: string | null;
    /**
     * duration of audio/video message
     * @type {number}
     * @memberof IMMessageAttachment
     */
    'seconds'?: number;
    /**
     * name of the doc message
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IMMessageAttachmentType = {
    Image: 'image',
    Video: 'video',
    Contact: 'contact',
    Sticker: 'sticker',
    Audio: 'audio',
    Document: 'document',
    Location: 'location'
} as const;

export type IMMessageAttachmentType = typeof IMMessageAttachmentType[keyof typeof IMMessageAttachmentType];


/**
 * 
 * @export
 * @interface IMMessageProduct
 */
export interface IMMessageProduct {
    /**
     * 
     * @type {string}
     * @memberof IMMessageProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IMMessageProduct
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface MessageObj
 */
export interface MessageObj {
    /**
     * the template message itself
     * @type {string}
     * @memberof MessageObj
     */
    'text': string | null;
    /**
     * array of attachments for the template
     * @type {Array<IMMessageAttachment>}
     * @memberof MessageObj
     */
    'attachments'?: Array<IMMessageAttachment>;
    /**
     * 
     * @type {Array<BotMessageButton>}
     * @memberof MessageObj
     */
    'buttons'?: Array<BotMessageButton>;
    /**
     * 
     * @type {Array<BotMessageDelay>}
     * @memberof MessageObj
     */
    'delays'?: Array<BotMessageDelay>;
    /**
     * 
     * @type {string}
     * @memberof MessageObj
     */
    'quoted'?: string;
    /**
     * 
     * @type {Array<IMMessageProduct>}
     * @memberof MessageObj
     */
    'products'?: Array<IMMessageProduct>;
}
/**
 * Optional parameters to send a message
 * @export
 * @interface MessageSendOptions
 */
export interface MessageSendOptions {
    /**
     * 
     * @type {string}
     * @memberof MessageSendOptions
     */
    'messageId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'simulateTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'requireOpenAccount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageSendOptions
     */
    'scheduleAt'?: string;
    /**
     * Forwards option to IM service
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'includeMarketingMessage'?: boolean;
    /**
     * 
     * @type {MessageSendOptionsQuoted}
     * @memberof MessageSendOptions
     */
    'quoted'?: MessageSendOptionsQuoted;
}
/**
 * 
 * @export
 * @interface MessageSendOptionsQuoted
 */
export interface MessageSendOptionsQuoted {
    /**
     * 
     * @type {string}
     * @memberof MessageSendOptionsQuoted
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageSendOptionsQuoted
     */
    'id': string;
}
/**
 * position in x-y coordinate space
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * 
     * @type {number}
     * @memberof ServiceResponse
     */
    'statusCode': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ServiceResponse
     */
    'body'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface StoreCreateRequest
 */
export interface StoreCreateRequest {
    /**
     * 
     * @type {StoreCreateRequestValues}
     * @memberof StoreCreateRequest
     */
    'values': StoreCreateRequestValues;
    /**
     * yaml file of boat
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'botFileUrl': string;
    /**
     * User Name for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'userName': string;
    /**
     * Language for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'language': string;
    /**
     * Image Url for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'imageUrl': string;
}
/**
 * 
 * @export
 * @interface StoreCreateRequestValues
 */
export interface StoreCreateRequestValues {
    /**
     * Name of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'templateName': string;
    /**
     * Category of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'templateCategory': string;
    /**
     * Name of Bot Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'botTemplate': string;
    /**
     * Image of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'image': string;
    /**
     * Description of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface StoreGet200Response
 */
export interface StoreGet200Response {
    /**
     * 
     * @type {Array<TemplateItem>}
     * @memberof StoreGet200Response
     */
    'templates': Array<TemplateItem>;
    /**
     * Cursor to fetch the next page
     * @type {string}
     * @memberof StoreGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TemplateCommand = {
    SubmitForReview: 'submit-for-review',
    Link: 'link',
    Unlink: 'unlink'
} as const;

export type TemplateCommand = typeof TemplateCommand[keyof typeof TemplateCommand];


/**
 * 
 * @export
 * @interface TemplateItem
 */
export interface TemplateItem {
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'yamlFileUrl': string;
}
/**
 * 
 * @export
 * @interface TemplateStatusUpdateRequest
 */
export interface TemplateStatusUpdateRequest {
    /**
     * 
     * @type {Array<TemplateStatusUpdateRequestTemplatesInner>}
     * @memberof TemplateStatusUpdateRequest
     */
    'templates': Array<TemplateStatusUpdateRequestTemplatesInner>;
}
/**
 * 
 * @export
 * @interface TemplateStatusUpdateRequestTemplatesInner
 */
export interface TemplateStatusUpdateRequestTemplatesInner {
    /**
     * ID of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestTemplatesInner
     */
    'id': string;
    /**
     * Status of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestTemplatesInner
     */
    'status': TemplateStatusUpdateRequestTemplatesInnerStatusEnum;
    /**
     * Reason for rejection of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestTemplatesInner
     */
    'rejectionReason': string;
}

export const TemplateStatusUpdateRequestTemplatesInnerStatusEnum = {
    Fail: 'fail',
    Pass: 'pass'
} as const;

export type TemplateStatusUpdateRequestTemplatesInnerStatusEnum = typeof TemplateStatusUpdateRequestTemplatesInnerStatusEnum[keyof typeof TemplateStatusUpdateRequestTemplatesInnerStatusEnum];


/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGet: async (count?: number, before?: string, q?: string, botId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Actions using GPT
         * @param {ActionsGptGenerateRequest} [actionsGptGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGptGenerate: async (actionsGptGenerateRequest?: ActionsGptGenerateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actions/gpt-generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionsGptGenerateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionsGet(count?: number, before?: string, q?: string, botId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionsGet(count, before, q, botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate Actions using GPT
         * @param {ActionsGptGenerateRequest} [actionsGptGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionsGptGenerate(actionsGptGenerateRequest?: ActionsGptGenerateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionsGptGenerate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionsGptGenerate(actionsGptGenerateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGet(count?: number, before?: string, q?: string, botId?: string, options?: any): AxiosPromise<ActionsGet200Response> {
            return localVarFp.actionsGet(count, before, q, botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Actions using GPT
         * @param {ActionsGptGenerateRequest} [actionsGptGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGptGenerate(actionsGptGenerateRequest?: ActionsGptGenerateRequest, options?: any): AxiosPromise<ActionsGptGenerate200Response> {
            return localVarFp.actionsGptGenerate(actionsGptGenerateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for actionsGet operation in ActionsApi.
 * @export
 * @interface ActionsApiActionsGetRequest
 */
export interface ActionsApiActionsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ActionsApiActionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly botId?: string
}

/**
 * Request parameters for actionsGptGenerate operation in ActionsApi.
 * @export
 * @interface ActionsApiActionsGptGenerateRequest
 */
export interface ActionsApiActionsGptGenerateRequest {
    /**
     * 
     * @type {ActionsGptGenerateRequest}
     * @memberof ActionsApiActionsGptGenerate
     */
    readonly actionsGptGenerateRequest?: ActionsGptGenerateRequest
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * 
     * @summary Gets all actions related to account/team
     * @param {ActionsApiActionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public actionsGet(requestParameters: ActionsApiActionsGetRequest = {}, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).actionsGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Actions using GPT
     * @param {ActionsApiActionsGptGenerateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public actionsGptGenerate(requestParameters: ActionsApiActionsGptGenerateRequest = {}, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).actionsGptGenerate(requestParameters.actionsGptGenerateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotTriggersApi - axios parameter creator
 * @export
 */
export const BotTriggersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a bot trigger instance
         * @param {string} triggerId 
         * @param {string} botId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggerCancelInstance: async (triggerId: string, botId: string, instanceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('botTriggerCancelInstance', 'triggerId', triggerId)
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botTriggerCancelInstance', 'botId', botId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('botTriggerCancelInstance', 'instanceId', instanceId)
            const localVarPath = `/bot-triggers/cancel-instance/{botId}/{triggerId}/{instanceId}`
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)))
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all instances of a bot trigger
         * @param {string} triggerId 
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggerInstancesGet: async (triggerId: string, count?: number, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('botTriggerInstancesGet', 'triggerId', triggerId)
            const localVarPath = `/bot-trigger-instances/{triggerId}`
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a bot trigger instance
         * @param {string} triggerId 
         * @param {string} botId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggerStartInstance: async (triggerId: string, botId: string, instanceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('botTriggerStartInstance', 'triggerId', triggerId)
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botTriggerStartInstance', 'botId', botId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('botTriggerStartInstance', 'instanceId', instanceId)
            const localVarPath = `/bot-triggers/start-instance/{botId}/{triggerId}/{instanceId}`
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)))
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fire a bot trigger via webhook
         * @param {string} triggerId 
         * @param {string} botId 
         * @param {BotTriggerWebhookRequest} [botTriggerWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggerWebhook: async (triggerId: string, botId: string, botTriggerWebhookRequest?: BotTriggerWebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('botTriggerWebhook', 'triggerId', triggerId)
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botTriggerWebhook', 'botId', botId)
            const localVarPath = `/bot-triggers/webhook/{botId}/{triggerId}`
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)))
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botTriggerWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bot trigger
         * @param {BotTriggersPatchRequest} [botTriggersPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggersPatch: async (botTriggersPatchRequest?: BotTriggersPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bot-triggers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botTriggersPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotTriggersApi - functional programming interface
 * @export
 */
export const BotTriggersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotTriggersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel a bot trigger instance
         * @param {string} triggerId 
         * @param {string} botId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botTriggerCancelInstance(triggerId: string, botId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botTriggerCancelInstance(triggerId, botId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all instances of a bot trigger
         * @param {string} triggerId 
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botTriggerInstancesGet(triggerId: string, count?: number, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotTriggerInstancesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botTriggerInstancesGet(triggerId, count, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a bot trigger instance
         * @param {string} triggerId 
         * @param {string} botId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botTriggerStartInstance(triggerId: string, botId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botTriggerStartInstance(triggerId, botId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fire a bot trigger via webhook
         * @param {string} triggerId 
         * @param {string} botId 
         * @param {BotTriggerWebhookRequest} [botTriggerWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botTriggerWebhook(triggerId: string, botId: string, botTriggerWebhookRequest?: BotTriggerWebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botTriggerWebhook(triggerId, botId, botTriggerWebhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a bot trigger
         * @param {BotTriggersPatchRequest} [botTriggersPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botTriggersPatch(botTriggersPatchRequest?: BotTriggersPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botTriggersPatch(botTriggersPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotTriggersApi - factory interface
 * @export
 */
export const BotTriggersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotTriggersApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel a bot trigger instance
         * @param {string} triggerId 
         * @param {string} botId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggerCancelInstance(triggerId: string, botId: string, instanceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.botTriggerCancelInstance(triggerId, botId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all instances of a bot trigger
         * @param {string} triggerId 
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggerInstancesGet(triggerId: string, count?: number, before?: string, options?: any): AxiosPromise<BotTriggerInstancesGet200Response> {
            return localVarFp.botTriggerInstancesGet(triggerId, count, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a bot trigger instance
         * @param {string} triggerId 
         * @param {string} botId 
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggerStartInstance(triggerId: string, botId: string, instanceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.botTriggerStartInstance(triggerId, botId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fire a bot trigger via webhook
         * @param {string} triggerId 
         * @param {string} botId 
         * @param {BotTriggerWebhookRequest} [botTriggerWebhookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggerWebhook(triggerId: string, botId: string, botTriggerWebhookRequest?: BotTriggerWebhookRequest, options?: any): AxiosPromise<void> {
            return localVarFp.botTriggerWebhook(triggerId, botId, botTriggerWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a bot trigger
         * @param {BotTriggersPatchRequest} [botTriggersPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botTriggersPatch(botTriggersPatchRequest?: BotTriggersPatchRequest, options?: any): AxiosPromise<void> {
            return localVarFp.botTriggersPatch(botTriggersPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botTriggerCancelInstance operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiBotTriggerCancelInstanceRequest
 */
export interface BotTriggersApiBotTriggerCancelInstanceRequest {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerCancelInstance
     */
    readonly triggerId: string

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerCancelInstance
     */
    readonly botId: string

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerCancelInstance
     */
    readonly instanceId: string
}

/**
 * Request parameters for botTriggerInstancesGet operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiBotTriggerInstancesGetRequest
 */
export interface BotTriggersApiBotTriggerInstancesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerInstancesGet
     */
    readonly triggerId: string

    /**
     * 
     * @type {number}
     * @memberof BotTriggersApiBotTriggerInstancesGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerInstancesGet
     */
    readonly before?: string
}

/**
 * Request parameters for botTriggerStartInstance operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiBotTriggerStartInstanceRequest
 */
export interface BotTriggersApiBotTriggerStartInstanceRequest {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerStartInstance
     */
    readonly triggerId: string

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerStartInstance
     */
    readonly botId: string

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerStartInstance
     */
    readonly instanceId: string
}

/**
 * Request parameters for botTriggerWebhook operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiBotTriggerWebhookRequest
 */
export interface BotTriggersApiBotTriggerWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerWebhook
     */
    readonly triggerId: string

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiBotTriggerWebhook
     */
    readonly botId: string

    /**
     * 
     * @type {BotTriggerWebhookRequest}
     * @memberof BotTriggersApiBotTriggerWebhook
     */
    readonly botTriggerWebhookRequest?: BotTriggerWebhookRequest
}

/**
 * Request parameters for botTriggersPatch operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiBotTriggersPatchRequest
 */
export interface BotTriggersApiBotTriggersPatchRequest {
    /**
     * 
     * @type {BotTriggersPatchRequest}
     * @memberof BotTriggersApiBotTriggersPatch
     */
    readonly botTriggersPatchRequest?: BotTriggersPatchRequest
}

/**
 * BotTriggersApi - object-oriented interface
 * @export
 * @class BotTriggersApi
 * @extends {BaseAPI}
 */
export class BotTriggersApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a bot trigger instance
     * @param {BotTriggersApiBotTriggerCancelInstanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public botTriggerCancelInstance(requestParameters: BotTriggersApiBotTriggerCancelInstanceRequest, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).botTriggerCancelInstance(requestParameters.triggerId, requestParameters.botId, requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all instances of a bot trigger
     * @param {BotTriggersApiBotTriggerInstancesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public botTriggerInstancesGet(requestParameters: BotTriggersApiBotTriggerInstancesGetRequest, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).botTriggerInstancesGet(requestParameters.triggerId, requestParameters.count, requestParameters.before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a bot trigger instance
     * @param {BotTriggersApiBotTriggerStartInstanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public botTriggerStartInstance(requestParameters: BotTriggersApiBotTriggerStartInstanceRequest, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).botTriggerStartInstance(requestParameters.triggerId, requestParameters.botId, requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fire a bot trigger via webhook
     * @param {BotTriggersApiBotTriggerWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public botTriggerWebhook(requestParameters: BotTriggersApiBotTriggerWebhookRequest, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).botTriggerWebhook(requestParameters.triggerId, requestParameters.botId, requestParameters.botTriggerWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a bot trigger
     * @param {BotTriggersApiBotTriggersPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public botTriggersPatch(requestParameters: BotTriggersApiBotTriggersPatchRequest = {}, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).botTriggersPatch(requestParameters.botTriggersPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotsApi - axios parameter creator
 * @export
 */
export const BotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsCreate: async (botsCreateRequest?: BotsCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches bot data based on provided botId parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsDataGet', 'botId', botId)
            const localVarPath = `/bots/{botId}/data`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDeletes: async (bots: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bots' is not null or undefined
            assertParamExists('botsDeletes', 'bots', bots)
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (bots) {
                localVarQueryParameter['bots'] = bots;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsExternalTemplateCommand: async (id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'id', id)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'accountId', accountId)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'command', command)
            const localVarPath = `/bots/{id}/external-template/{accountId}/{command}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsFire: async (id: string, botsFireRequest?: BotsFireRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsFire', 'id', id)
            const localVarPath = `/bots/{id}/fire`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsFireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of execution records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGetRecord: async (count?: number, beforeId?: number, botId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (beforeId !== undefined) {
                localVarQueryParameter['beforeId'] = beforeId;
            }

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {string} [language] 
         * @param {string} [industry] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGets: async (q?: string, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, language?: string, industry?: string, returnTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (industry !== undefined) {
                localVarQueryParameter['industry'] = industry;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPatch: async (id: string, botPatch?: BotPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsPatch', 'id', id)
            const localVarPath = `/bots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update status of some templates
         * @param {TemplateStatusUpdateRequest} [templateStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTemplateStatusUpdate: async (templateStatusUpdateRequest?: TemplateStatusUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-template-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateStatusUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotsApi - functional programming interface
 * @export
 */
export const BotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsCreate(botsCreateRequest?: BotsCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsCreate(botsCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint fetches bot data based on provided botId parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsDataGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsDataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsDataGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsDeletes(bots: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsDeletes(bots, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsExternalTemplateCommand(id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsExternalTemplateCommand200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsExternalTemplateCommand(id, accountId, command, language, category, templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsFire(id: string, botsFireRequest?: BotsFireRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionFireRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsFire(id, botsFireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns list of execution records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsGetRecord(count?: number, beforeId?: number, botId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsGetRecord200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsGetRecord(count, beforeId, botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {string} [language] 
         * @param {string} [industry] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsGets(q?: string, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, language?: string, industry?: string, returnTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsGets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsGets(q, before, count, id, sortBy, order, folderId, language, industry, returnTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsPatch(id: string, botPatch?: BotPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsPatch(id, botPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update status of some templates
         * @param {TemplateStatusUpdateRequest} [templateStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalTemplateStatusUpdate(templateStatusUpdateRequest?: TemplateStatusUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalTemplateStatusUpdate(templateStatusUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotsApi - factory interface
 * @export
 */
export const BotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsCreate(botsCreateRequest?: BotsCreateRequest, options?: any): AxiosPromise<Bot> {
            return localVarFp.botsCreate(botsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches bot data based on provided botId parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGet(botId: string, options?: any): AxiosPromise<BotsDataGet200Response> {
            return localVarFp.botsDataGet(botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDeletes(bots: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.botsDeletes(bots, options).then((request) => request(axios, basePath));
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsExternalTemplateCommand(id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options?: any): AxiosPromise<BotsExternalTemplateCommand200Response> {
            return localVarFp.botsExternalTemplateCommand(id, accountId, command, language, category, templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsFire(id: string, botsFireRequest?: BotsFireRequest, options?: any): AxiosPromise<ActionFireRecord> {
            return localVarFp.botsFire(id, botsFireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of execution records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGetRecord(count?: number, beforeId?: number, botId?: string, options?: any): AxiosPromise<BotsGetRecord200Response> {
            return localVarFp.botsGetRecord(count, beforeId, botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {string} [language] 
         * @param {string} [industry] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGets(q?: string, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, language?: string, industry?: string, returnTotalCount?: boolean, options?: any): AxiosPromise<BotsGets200Response> {
            return localVarFp.botsGets(q, before, count, id, sortBy, order, folderId, language, industry, returnTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPatch(id: string, botPatch?: BotPatch, options?: any): AxiosPromise<void> {
            return localVarFp.botsPatch(id, botPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update status of some templates
         * @param {TemplateStatusUpdateRequest} [templateStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTemplateStatusUpdate(templateStatusUpdateRequest?: TemplateStatusUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.externalTemplateStatusUpdate(templateStatusUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botsCreate operation in BotsApi.
 * @export
 * @interface BotsApiBotsCreateRequest
 */
export interface BotsApiBotsCreateRequest {
    /**
     * 
     * @type {BotsCreateRequest}
     * @memberof BotsApiBotsCreate
     */
    readonly botsCreateRequest?: BotsCreateRequest
}

/**
 * Request parameters for botsDataGet operation in BotsApi.
 * @export
 * @interface BotsApiBotsDataGetRequest
 */
export interface BotsApiBotsDataGetRequest {
    /**
     * The ID of the bot
     * @type {string}
     * @memberof BotsApiBotsDataGet
     */
    readonly botId: string
}

/**
 * Request parameters for botsDeletes operation in BotsApi.
 * @export
 * @interface BotsApiBotsDeletesRequest
 */
export interface BotsApiBotsDeletesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof BotsApiBotsDeletes
     */
    readonly bots: Array<string>
}

/**
 * Request parameters for botsExternalTemplateCommand operation in BotsApi.
 * @export
 * @interface BotsApiBotsExternalTemplateCommandRequest
 */
export interface BotsApiBotsExternalTemplateCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly accountId: string

    /**
     * 
     * @type {TemplateCommand}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly command: TemplateCommand

    /**
     * ISO code of the language, required for WA business templates
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly language?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly category?: string

    /**
     * The external ID of the template to link with, only valid for the \&quot;link\&quot; command
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly templateId?: string
}

/**
 * Request parameters for botsFire operation in BotsApi.
 * @export
 * @interface BotsApiBotsFireRequest
 */
export interface BotsApiBotsFireRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsFire
     */
    readonly id: string

    /**
     * 
     * @type {BotsFireRequest}
     * @memberof BotsApiBotsFire
     */
    readonly botsFireRequest?: BotsFireRequest
}

/**
 * Request parameters for botsGetRecord operation in BotsApi.
 * @export
 * @interface BotsApiBotsGetRecordRequest
 */
export interface BotsApiBotsGetRecordRequest {
    /**
     * 
     * @type {number}
     * @memberof BotsApiBotsGetRecord
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof BotsApiBotsGetRecord
     */
    readonly beforeId?: number

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGetRecord
     */
    readonly botId?: string
}

/**
 * Request parameters for botsGets operation in BotsApi.
 * @export
 * @interface BotsApiBotsGetsRequest
 */
export interface BotsApiBotsGetsRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly before?: string

    /**
     * 
     * @type {number}
     * @memberof BotsApiBotsGets
     */
    readonly count?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof BotsApiBotsGets
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {'name' | 'updatedAt'}
     * @memberof BotsApiBotsGets
     */
    readonly sortBy?: 'name' | 'updatedAt'

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof BotsApiBotsGets
     */
    readonly order?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly folderId?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly language?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly industry?: string

    /**
     * 
     * @type {boolean}
     * @memberof BotsApiBotsGets
     */
    readonly returnTotalCount?: boolean
}

/**
 * Request parameters for botsPatch operation in BotsApi.
 * @export
 * @interface BotsApiBotsPatchRequest
 */
export interface BotsApiBotsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsPatch
     */
    readonly id: string

    /**
     * 
     * @type {BotPatch}
     * @memberof BotsApiBotsPatch
     */
    readonly botPatch?: BotPatch
}

/**
 * Request parameters for externalTemplateStatusUpdate operation in BotsApi.
 * @export
 * @interface BotsApiExternalTemplateStatusUpdateRequest
 */
export interface BotsApiExternalTemplateStatusUpdateRequest {
    /**
     * 
     * @type {TemplateStatusUpdateRequest}
     * @memberof BotsApiExternalTemplateStatusUpdate
     */
    readonly templateStatusUpdateRequest?: TemplateStatusUpdateRequest
}

/**
 * BotsApi - object-oriented interface
 * @export
 * @class BotsApi
 * @extends {BaseAPI}
 */
export class BotsApi extends BaseAPI {
    /**
     * 
     * @summary Creates new bot
     * @param {BotsApiBotsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsCreate(requestParameters: BotsApiBotsCreateRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsCreate(requestParameters.botsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches bot data based on provided botId parameters
     * @summary Retrieves bot data including triggers, notes and actions
     * @param {BotsApiBotsDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsDataGet(requestParameters: BotsApiBotsDataGetRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsDataGet(requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of bots
     * @param {BotsApiBotsDeletesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsDeletes(requestParameters: BotsApiBotsDeletesRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsDeletes(requestParameters.bots, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Either submit for review, unlink from the external template provider or link with an existing template ID
     * @summary Execute a command to update the status for the external template
     * @param {BotsApiBotsExternalTemplateCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsExternalTemplateCommand(requestParameters: BotsApiBotsExternalTemplateCommandRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsExternalTemplateCommand(requestParameters.id, requestParameters.accountId, requestParameters.command, requestParameters.language, requestParameters.category, requestParameters.templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Will throw a 400 if there is no starting action ID
     * @summary Initiates a bot sequence. Fires the starting action ID
     * @param {BotsApiBotsFireRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsFire(requestParameters: BotsApiBotsFireRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsFire(requestParameters.id, requestParameters.botsFireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of execution records
     * @param {BotsApiBotsGetRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsGetRecord(requestParameters: BotsApiBotsGetRecordRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsGetRecord(requestParameters.count, requestParameters.beforeId, requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of bots
     * @param {BotsApiBotsGetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsGets(requestParameters: BotsApiBotsGetsRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsGets(requestParameters.q, requestParameters.before, requestParameters.count, requestParameters.id, requestParameters.sortBy, requestParameters.order, requestParameters.folderId, requestParameters.language, requestParameters.industry, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an action
     * @param {BotsApiBotsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsPatch(requestParameters: BotsApiBotsPatchRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsPatch(requestParameters.id, requestParameters.botPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update status of some templates
     * @param {BotsApiExternalTemplateStatusUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public externalTemplateStatusUpdate(requestParameters: BotsApiExternalTemplateStatusUpdateRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).externalTemplateStatusUpdate(requestParameters.templateStatusUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderCreate: async (folderCreateRequest?: FolderCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderDelete: async (folders: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folders' is not null or undefined
            assertParamExists('folderDelete', 'folders', folders)
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (folders) {
                localVarQueryParameter['folders'] = folders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderGet: async (count?: number, before?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderUpdate: async (folderId: string, folderUpdateRequest?: FolderUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('folderUpdate', 'folderId', folderId)
            const localVarPath = `/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderCreate(folderCreateRequest?: FolderCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderCreate(folderCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderDelete(folders: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderDelete(folders, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderGet(count?: number, before?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderGet(count, before, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderUpdate(folderId: string, folderUpdateRequest?: FolderUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderUpdate(folderId, folderUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderCreate(folderCreateRequest?: FolderCreateRequest, options?: any): AxiosPromise<Folder> {
            return localVarFp.folderCreate(folderCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderDelete(folders: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.folderDelete(folders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderGet(count?: number, before?: string, q?: string, options?: any): AxiosPromise<FolderGet200Response> {
            return localVarFp.folderGet(count, before, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderUpdate(folderId: string, folderUpdateRequest?: FolderUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.folderUpdate(folderId, folderUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for folderCreate operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderCreateRequest
 */
export interface FoldersApiFolderCreateRequest {
    /**
     * 
     * @type {FolderCreateRequest}
     * @memberof FoldersApiFolderCreate
     */
    readonly folderCreateRequest?: FolderCreateRequest
}

/**
 * Request parameters for folderDelete operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderDeleteRequest
 */
export interface FoldersApiFolderDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof FoldersApiFolderDelete
     */
    readonly folders: Array<string>
}

/**
 * Request parameters for folderGet operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderGetRequest
 */
export interface FoldersApiFolderGetRequest {
    /**
     * 
     * @type {number}
     * @memberof FoldersApiFolderGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderGet
     */
    readonly q?: string
}

/**
 * Request parameters for folderUpdate operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderUpdateRequest
 */
export interface FoldersApiFolderUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderUpdate
     */
    readonly folderId: string

    /**
     * 
     * @type {FolderUpdateRequest}
     * @memberof FoldersApiFolderUpdate
     */
    readonly folderUpdateRequest?: FolderUpdateRequest
}

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * 
     * @summary Create folder
     * @param {FoldersApiFolderCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderCreate(requestParameters: FoldersApiFolderCreateRequest = {}, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderCreate(requestParameters.folderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of folders
     * @param {FoldersApiFolderDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderDelete(requestParameters: FoldersApiFolderDeleteRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderDelete(requestParameters.folders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all folders related to account/team
     * @param {FoldersApiFolderGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderGet(requestParameters: FoldersApiFolderGetRequest = {}, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderGet(requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update folder
     * @param {FoldersApiFolderUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderUpdate(requestParameters: FoldersApiFolderUpdateRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderUpdate(requestParameters.folderId, requestParameters.folderUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCreate: async (storeCreateRequest?: StoreCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGet: async (count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (categoryKeyValue) {
                localVarQueryParameter['categoryKeyValue'] = categoryKeyValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeCreate(storeCreateRequest?: StoreCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeCreate(storeCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeGet(count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeGet(count, before, q, language, categoryKeyValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCreate(storeCreateRequest?: StoreCreateRequest, options?: any): AxiosPromise<TemplateItem> {
            return localVarFp.storeCreate(storeCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGet(count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options?: any): AxiosPromise<StoreGet200Response> {
            return localVarFp.storeGet(count, before, q, language, categoryKeyValue, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for storeCreate operation in StoreApi.
 * @export
 * @interface StoreApiStoreCreateRequest
 */
export interface StoreApiStoreCreateRequest {
    /**
     * 
     * @type {StoreCreateRequest}
     * @memberof StoreApiStoreCreate
     */
    readonly storeCreateRequest?: StoreCreateRequest
}

/**
 * Request parameters for storeGet operation in StoreApi.
 * @export
 * @interface StoreApiStoreGetRequest
 */
export interface StoreApiStoreGetRequest {
    /**
     * 
     * @type {number}
     * @memberof StoreApiStoreGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly language?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof StoreApiStoreGet
     */
    readonly categoryKeyValue?: Array<string>
}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * 
     * @summary Create options in the store
     * @param {StoreApiStoreCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeCreate(requestParameters: StoreApiStoreCreateRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeCreate(requestParameters.storeCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get options in the store
     * @param {StoreApiStoreGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeGet(requestParameters: StoreApiStoreGetRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.language, requestParameters.categoryKeyValue, options).then((request) => request(this.axios, this.basePath));
    }
}


