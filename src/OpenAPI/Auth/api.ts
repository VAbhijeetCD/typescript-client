const BASE_PATH = "https://api-teams.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Auth & Teams Service
 * Manage Users & Teams
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * @type AuthRequest
 * @export
 */
export type AuthRequest = PasswordAuthRequest | RefreshTokenLoginRequest;

/**
 * Login with Boutir
 * @export
 * @interface BoutirTokenRequest
 */
export interface BoutirTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'type': BoutirTokenRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'password': string;
}

export const BoutirTokenRequestTypeEnum = {
    Boutir: 'boutir'
} as const;

export type BoutirTokenRequestTypeEnum = typeof BoutirTokenRequestTypeEnum[keyof typeof BoutirTokenRequestTypeEnum];

/**
 * 
 * @export
 * @interface ExternalTokenPostResponse
 */
export interface ExternalTokenPostResponse {
    /**
     * Was the user just created
     * @type {boolean}
     * @memberof ExternalTokenPostResponse
     */
    'created'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'refresh_token_expiry'?: string;
}
/**
 * 
 * @export
 * @interface ExternalTokenPostResponseAllOf
 */
export interface ExternalTokenPostResponseAllOf {
    /**
     * Was the user just created
     * @type {boolean}
     * @memberof ExternalTokenPostResponseAllOf
     */
    'created'?: boolean;
}
/**
 * @type ExternalTokenRequest
 * @export
 */
export type ExternalTokenRequest = BoutirTokenRequest | FirebaseTokenRequest;

/**
 * Login with Firebase
 * @export
 * @interface FirebaseTokenRequest
 */
export interface FirebaseTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'type': FirebaseTokenRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'idToken': string;
}

export const FirebaseTokenRequestTypeEnum = {
    Firebase: 'firebase'
} as const;

export type FirebaseTokenRequestTypeEnum = typeof FirebaseTokenRequestTypeEnum[keyof typeof FirebaseTokenRequestTypeEnum];

/**
 * 
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'id': string;
    /**
     * Unique identifier for a team
     * @type {string}
     * @memberof InviteLink
     */
    'teamId': string;
    /**
     * User ID of the person who created the link
     * @type {string}
     * @memberof InviteLink
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'expiresAt': string;
    /**
     * The scopes allowed for the invite link
     * @type {Array<Scope>}
     * @memberof InviteLink
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface InviteLinksPostRequest
 */
export interface InviteLinksPostRequest {
    /**
     * 
     * @type {Array<Scope>}
     * @memberof InviteLinksPostRequest
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface JWT
 */
export interface JWT {
    /**
     * Binary representation of the scope array
     * @type {string}
     * @memberof JWT
     */
    'scope': string;
    /**
     * 
     * @type {number}
     * @memberof JWT
     */
    'exp': number;
    /**
     * 
     * @type {number}
     * @memberof JWT
     */
    'iat': number;
    /**
     * 
     * @type {JWTUser}
     * @memberof JWT
     */
    'user': JWTUser;
}
/**
 * 
 * @export
 * @interface JWTUser
 */
export interface JWTUser {
    /**
     * Unique identifier for a user
     * @type {string}
     * @memberof JWTUser
     */
    'id': string;
    /**
     * Unique identifier for a team
     * @type {string}
     * @memberof JWTUser
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'fullName'?: string;
    /**
     * 
     * @type {number}
     * @memberof JWTUser
     */
    'phoneNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'emailAddress'?: string;
}
/**
 * @type NotificationResult
 * @export
 */
export type NotificationResult = boolean | string;

/**
 * 
 * @export
 * @interface Notify200Response
 */
export interface Notify200Response {
    /**
     * 
     * @type {NotificationResult}
     * @memberof Notify200Response
     */
    'whatsapp': NotificationResult;
    /**
     * 
     * @type {NotificationResult}
     * @memberof Notify200Response
     */
    'email': NotificationResult;
    /**
     * 
     * @type {NotificationResult}
     * @memberof Notify200Response
     */
    'desktop'?: NotificationResult;
}
/**
 * 
 * @export
 * @interface NotifyModel
 */
export interface NotifyModel {
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'whatsapp'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'email'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'desktop'?: boolean;
}
/**
 * 
 * @export
 * @interface NotifyRequest
 */
export interface NotifyRequest {
    /**
     * 
     * @type {string}
     * @memberof NotifyRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof NotifyRequest
     */
    'content': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NotifyRequest
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OAuthRequest
 */
export interface OAuthRequest {
    /**
     * The phone number
     * @type {string}
     * @memberof OAuthRequest
     */
    'username': string;
    /**
     * Plaintext password
     * @type {string}
     * @memberof OAuthRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof OAuthRequest
     */
    'grant_type'?: OAuthRequestGrantTypeEnum;
    /**
     * Space separated scopes
     * @type {string}
     * @memberof OAuthRequest
     */
    'scope'?: string;
}

export const OAuthRequestGrantTypeEnum = {
    Password: 'password'
} as const;

export type OAuthRequestGrantTypeEnum = typeof OAuthRequestGrantTypeEnum[keyof typeof OAuthRequestGrantTypeEnum];

/**
 * 
 * @export
 * @interface OTP
 */
export interface OTP {
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'phoneNumber': number;
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'otp'?: number;
    /**
     * 
     * @type {string}
     * @memberof OTP
     */
    'expiresAt': string;
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'resendsLeft': number;
}
/**
 * 
 * @export
 * @interface OtpPostRequest
 */
export interface OtpPostRequest {
    /**
     * 
     * @type {string}
     * @memberof OtpPostRequest
     */
    'phoneNumber': string;
}
/**
 * 
 * @export
 * @interface PartnerTeamPatchRequest
 */
export interface PartnerTeamPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerTeamPatchRequest
     */
    'partnerAdmin': string | null;
}
/**
 * 
 * @export
 * @interface PasswordAuthRequest
 */
export interface PasswordAuthRequest {
    /**
     * 
     * @type {number}
     * @memberof PasswordAuthRequest
     */
    'phoneNumber': number;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'returnRefreshToken'?: boolean;
    /**
     * This will be the base64 encoded SHA256 of the plaintext password
     * @type {string}
     * @memberof PasswordAuthRequest
     */
    'password': string;
    /**
     * The team ID to generate the token for, lastUsedTeam will be used otherwise
     * @type {string}
     * @memberof PasswordAuthRequest
     */
    'teamId'?: string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof PasswordAuthRequest
     */
    'scopes'?: Array<Scope>;
    /**
     * Should logging in with this team ID update the lastUsedTeam for login
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'updateLastUsedTeam'?: boolean;
    /**
     * Force the generation of an access token
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'force'?: boolean;
}
/**
 * A refresh token allows you to generate access tokens to access & update things on ChatDaddy services. A refresh token will expire and become invalidated after 14 days of no activity. 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenLoginRequest
 */
export interface RefreshTokenLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenLoginRequest
     */
    'refreshToken': string;
    /**
     * The team ID to generate the token for, lastUsedTeam will be used otherwise
     * @type {string}
     * @memberof RefreshTokenLoginRequest
     */
    'teamId': string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof RefreshTokenLoginRequest
     */
    'scopes'?: Array<Scope>;
    /**
     * Should fetching the token of a new team update the lastUsedTeam for login
     * @type {boolean}
     * @memberof RefreshTokenLoginRequest
     */
    'updateLastUsedTeam'?: boolean;
    /**
     * Force the generation of an access token
     * @type {boolean}
     * @memberof RefreshTokenLoginRequest
     */
    'force'?: boolean;
}
/**
 * 
 * @export
 * @interface ResetPassword
 */
export interface ResetPassword {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Scope = {
    WaState: 'WA_STATE',
    ContactsReadAssigned: 'CONTACTS_READ_ASSIGNED',
    ContactsReadAll: 'CONTACTS_READ_ALL',
    ContactsExportButton: 'CONTACTS_EXPORT_BUTTON',
    ContactsCreate: 'CONTACTS_CREATE',
    ContactsDelete: 'CONTACTS_DELETE',
    ContactsUpdate: 'CONTACTS_UPDATE',
    CampaignsRead: 'CAMPAIGNS_READ',
    CampaignsCreate: 'CAMPAIGNS_CREATE',
    CampaignsDelete: 'CAMPAIGNS_DELETE',
    CampaignsUpdate: 'CAMPAIGNS_UPDATE',
    KeywordRead: 'KEYWORD_READ',
    KeywordCreate: 'KEYWORD_CREATE',
    KeywordDelete: 'KEYWORD_DELETE',
    KeywordUpdate: 'KEYWORD_UPDATE',
    TemplatesRead: 'TEMPLATES_READ',
    TemplatesCreate: 'TEMPLATES_CREATE',
    TemplatesDelete: 'TEMPLATES_DELETE',
    TemplatesUpdate: 'TEMPLATES_UPDATE',
    TagsRead: 'TAGS_READ',
    TagsCreate: 'TAGS_CREATE',
    TagsDelete: 'TAGS_DELETE',
    TokensRead: 'TOKENS_READ',
    TokensDelete: 'TOKENS_DELETE',
    UsersPatch: 'USERS_PATCH',
    ReferralApplyCredit: 'REFERRAL_APPLY_CREDIT',
    TeamUpdate: 'TEAM_UPDATE',
    AccountCreate: 'ACCOUNT_CREATE',
    AccountRead: 'ACCOUNT_READ',
    AccountDelete: 'ACCOUNT_DELETE',
    AccountPatch: 'ACCOUNT_PATCH',
    TeamlinkCreate: 'TEAMLINK_CREATE',
    TeamlinkRead: 'TEAMLINK_READ',
    TeammembersUpdate: 'TEAMMEMBERS_UPDATE',
    TeammembersRead: 'TEAMMEMBERS_READ',
    TeamNotify: 'TEAM_NOTIFY',
    ChatsAccessAll: 'CHATS_ACCESS_ALL',
    ChatsAccessAssigned: 'CHATS_ACCESS_ASSIGNED',
    ChatsDelete: 'CHATS_DELETE',
    MessagesSendToAssigned: 'MESSAGES_SEND_TO_ASSIGNED',
    MessagesSendToAll: 'MESSAGES_SEND_TO_ALL',
    MessagesSchedule: 'MESSAGES_SCHEDULE',
    MessagesDelete: 'MESSAGES_DELETE',
    GroupsCreate: 'GROUPS_CREATE',
    GroupsUpdate: 'GROUPS_UPDATE',
    Notes: 'NOTES',
    NotificationRead: 'NOTIFICATION_READ',
    NotificationCreate: 'NOTIFICATION_CREATE',
    NotificationUpdate: 'NOTIFICATION_UPDATE',
    NotificationDelete: 'NOTIFICATION_DELETE',
    IntegrationsUpdate: 'INTEGRATIONS_UPDATE',
    AdminPanelAccess: 'ADMIN_PANEL_ACCESS',
    PaymentsRead: 'PAYMENTS_READ',
    PaymentsUpdate: 'PAYMENTS_UPDATE',
    WaLiveEvents: 'WA_LIVE_EVENTS',
    ChatdaddyHook: 'CHATDADDY_HOOK',
    PartnerAdminPanelAccess: 'PARTNER_ADMIN_PANEL_ACCESS',
    ProductsGet: 'PRODUCTS_GET',
    ProductsCreate: 'PRODUCTS_CREATE',
    ProductsUpdate: 'PRODUCTS_UPDATE',
    ProductsDelete: 'PRODUCTS_DELETE'
} as const;

export type Scope = typeof Scope[keyof typeof Scope];


/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'updatedAt': string;
    /**
     * Who created the team
     * @type {string}
     * @memberof Team
     */
    'createdBy'?: string;
    /**
     * 
     * @type {User}
     * @memberof Team
     */
    'creator'?: User;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name': string;
    /**
     * Is an admin team
     * @type {boolean}
     * @memberof Team
     */
    'isAdmin'?: boolean;
    /**
     * The max scopes allowed
     * @type {Array<Scope>}
     * @memberof Team
     */
    'scopes': Array<Scope>;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof Team
     */
    'metadata': TeamMetadata;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof Team
     */
    'members'?: Array<TeamMember>;
    /**
     * 
     * @type {Array<InviteLink>}
     * @memberof Team
     */
    'inviteLinks'?: Array<InviteLink>;
    /**
     * The team will be the admin team of a Chatdaddy partner if this property is not null.
     * @type {string}
     * @memberof Team
     */
    'partnerAdmin'?: string | null;
}
/**
 * 
 * @export
 * @interface TeamMember
 */
export interface TeamMember {
    /**
     * 
     * @type {Team}
     * @memberof TeamMember
     */
    'team'?: Team;
    /**
     * 
     * @type {User}
     * @memberof TeamMember
     */
    'user'?: User;
    /**
     * Unique identifier for a user
     * @type {string}
     * @memberof TeamMember
     */
    'userId': string;
    /**
     * Unique identifier for a team
     * @type {string}
     * @memberof TeamMember
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'addedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'addedBy'?: string | null;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof TeamMember
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface TeamMetadata
 */
export interface TeamMetadata {
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyEmailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyWebsite'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'industry'?: string;
}
/**
 * 
 * @export
 * @interface TeamPatchRequest
 */
export interface TeamPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof TeamPatchRequest
     */
    'metadata'?: TeamMetadata;
    /**
     * 
     * @type {Array<TeamPatchRequestMembersInner>}
     * @memberof TeamPatchRequest
     */
    'members'?: Array<TeamPatchRequestMembersInner>;
    /**
     * 
     * @type {Array<TeamPatchRequestInviteLinksInner>}
     * @memberof TeamPatchRequest
     */
    'inviteLinks'?: Array<TeamPatchRequestInviteLinksInner>;
}
/**
 * 
 * @export
 * @interface TeamPatchRequestInviteLinksInner
 */
export interface TeamPatchRequestInviteLinksInner {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequestInviteLinksInner
     */
    'id': string;
    /**
     * If set to true, will delete the invite link
     * @type {boolean}
     * @memberof TeamPatchRequestInviteLinksInner
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface TeamPatchRequestMembersInner
 */
export interface TeamPatchRequestMembersInner {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequestMembersInner
     */
    'id': string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof TeamPatchRequestMembersInner
     */
    'scopes'?: Array<Scope>;
    /**
     * If set to true, will delete the team member
     * @type {boolean}
     * @memberof TeamPatchRequestMembersInner
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface TeamsGet200Response
 */
export interface TeamsGet200Response {
    /**
     * 
     * @type {number}
     * @memberof TeamsGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Team>}
     * @memberof TeamsGet200Response
     */
    'teams': Array<Team>;
}
/**
 * 
 * @export
 * @interface TeamsPatch200Response
 */
export interface TeamsPatch200Response {
    /**
     * 
     * @type {boolean}
     * @memberof TeamsPatch200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface TokenGet400Response
 */
export interface TokenGet400Response {
    /**
     * 
     * @type {number}
     * @memberof TokenGet400Response
     */
    'statusCode'?: number;
    /**
     * Specific description of the error
     * @type {string}
     * @memberof TokenGet400Response
     */
    'error'?: string;
    /**
     * What the error was
     * @type {string}
     * @memberof TokenGet400Response
     */
    'message'?: string;
    /**
     * Some extra information about the error
     * @type {object}
     * @memberof TokenGet400Response
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface TokenPost200Response
 */
export interface TokenPost200Response {
    /**
     * 
     * @type {string}
     * @memberof TokenPost200Response
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPost200Response
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenPost200Response
     */
    'refresh_token_expiry'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenPost200Response
     */
    'was_forced'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenPostResponse
 */
export interface TokenPostResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'refresh_token_expiry'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'disabledAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName': string;
    /**
     * The last used team ID, your refresh token when logging in is generated for this team
     * @type {string}
     * @memberof User
     */
    'lastUsedTeamId'?: string;
    /**
     * Will only contain numbers, no + sign, brackets etc.
     * @type {number}
     * @memberof User
     */
    'phoneNumber': number | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {UserCreateMethod}
     * @memberof User
     */
    'createdByMethod'?: UserCreateMethod;
    /**
     * 
     * @type {NotifyModel}
     * @memberof User
     */
    'notify': NotifyModel;
    /**
     * The referral code used for sign-up
     * @type {string}
     * @memberof User
     */
    'referralCode'?: string | null;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof User
     */
    'memberships'?: Array<TeamMember>;
    /**
     * 
     * @type {Array<WebPushSubscription>}
     * @memberof User
     */
    'webPushSubscriptions'?: Array<WebPushSubscription>;
    /**
     * The partnership the user has signed in with
     * @type {string}
     * @memberof User
     */
    'partnership'?: string | null;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'fullName': string;
    /**
     * Will only contain numbers, no + sign, brackets etc.
     * @type {number}
     * @memberof UserCreate
     */
    'phoneNumber': number;
    /**
     * SHA256 of the plaintext password pls
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof UserCreate
     */
    'metadata'?: TeamMetadata;
    /**
     * 
     * @type {NotifyModel}
     * @memberof UserCreate
     */
    'notify'?: NotifyModel;
    /**
     * Sign up with a referral code
     * @type {string}
     * @memberof UserCreate
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserCreateMethod = {
    AdminPanel: 'admin-panel',
    Otp: 'otp',
    Boutir: 'boutir',
    InstantReg: 'instant-reg',
    Firebase: 'firebase'
} as const;

export type UserCreateMethod = typeof UserCreateMethod[keyof typeof UserCreateMethod];


/**
 * 
 * @export
 * @interface UserPatch
 */
export interface UserPatch {
    /**
     * 
     * @type {string}
     * @memberof UserPatch
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPatch
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {NotifyModel}
     * @memberof UserPatch
     */
    'notify'?: NotifyModel;
    /**
     * Phone number. Only admin access can modify or specify OTP
     * @type {number}
     * @memberof UserPatch
     */
    'phoneNumber'?: number;
    /**
     * OTP to change password/phone number
     * @type {number}
     * @memberof UserPatch
     */
    'otp'?: number;
    /**
     * new password. Only admin access can modify
     * @type {string}
     * @memberof UserPatch
     */
    'password'?: string;
    /**
     * 
     * @type {Array<WebPushSubscription>}
     * @memberof UserPatch
     */
    'webPushSubscriptions'?: Array<WebPushSubscription>;
}
/**
 * 
 * @export
 * @interface UsersGet200Response
 */
export interface UsersGet200Response {
    /**
     * 
     * @type {number}
     * @memberof UsersGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersGet200Response
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface WebPushSubscription
 */
export interface WebPushSubscription {
    /**
     * 
     * @type {string}
     * @memberof WebPushSubscription
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof WebPushSubscription
     */
    'authKey': string;
    /**
     * 
     * @type {string}
     * @memberof WebPushSubscription
     */
    'p256dhKey': string;
}

/**
 * InviteLinksApi - axios parameter creator
 * @export
 */
export const InviteLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('inviteLinksGet', 'id', id)
            const localVarPath = `/invite-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InviteLinksPostRequest} [inviteLinksPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksPost: async (inviteLinksPostRequest?: InviteLinksPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invite-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAMLINK_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLinksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteLinksApi - functional programming interface
 * @export
 */
export const InviteLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InviteLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteLinksGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteLinksGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InviteLinksPostRequest} [inviteLinksPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteLinksPost(inviteLinksPostRequest?: InviteLinksPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteLinksPost(inviteLinksPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InviteLinksApi - factory interface
 * @export
 */
export const InviteLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InviteLinksApiFp(configuration)
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksGet(id: string, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.inviteLinksGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InviteLinksPostRequest} [inviteLinksPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksPost(inviteLinksPostRequest?: InviteLinksPostRequest, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.inviteLinksPost(inviteLinksPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for inviteLinksGet operation in InviteLinksApi.
 * @export
 * @interface InviteLinksApiInviteLinksGetRequest
 */
export interface InviteLinksApiInviteLinksGetRequest {
    /**
     * the invite link ID
     * @type {string}
     * @memberof InviteLinksApiInviteLinksGet
     */
    readonly id: string
}

/**
 * Request parameters for inviteLinksPost operation in InviteLinksApi.
 * @export
 * @interface InviteLinksApiInviteLinksPostRequest
 */
export interface InviteLinksApiInviteLinksPostRequest {
    /**
     * 
     * @type {InviteLinksPostRequest}
     * @memberof InviteLinksApiInviteLinksPost
     */
    readonly inviteLinksPostRequest?: InviteLinksPostRequest
}

/**
 * InviteLinksApi - object-oriented interface
 * @export
 * @class InviteLinksApi
 * @extends {BaseAPI}
 */
export class InviteLinksApi extends BaseAPI {
    /**
     * 
     * @summary Get info about an invite link
     * @param {InviteLinksApiInviteLinksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteLinksApi
     */
    public inviteLinksGet(requestParameters: InviteLinksApiInviteLinksGetRequest, options?: AxiosRequestConfig) {
        return InviteLinksApiFp(this.configuration).inviteLinksGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
     * @summary Create an invite link for the team
     * @param {InviteLinksApiInviteLinksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteLinksApi
     */
    public inviteLinksPost(requestParameters: InviteLinksApiInviteLinksPostRequest = {}, options?: AxiosRequestConfig) {
        return InviteLinksApiFp(this.configuration).inviteLinksPost(requestParameters.inviteLinksPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Notify a team member
         * @param {string} userId 
         * @param {string} [teamId] 
         * @param {boolean} [notifyWhatsApp] Override notify on WhatsApp
         * @param {boolean} [notifyEmail] Override notify on Email
         * @param {boolean} [notifyDesktop] Override notify on Desktop
         * @param {NotifyRequest} [notifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notify: async (userId: string, teamId?: string, notifyWhatsApp?: boolean, notifyEmail?: boolean, notifyDesktop?: boolean, notifyRequest?: NotifyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('notify', 'userId', userId)
            const localVarPath = `/notify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAM_NOTIFY"], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (notifyWhatsApp !== undefined) {
                localVarQueryParameter['notifyWhatsApp'] = notifyWhatsApp;
            }

            if (notifyEmail !== undefined) {
                localVarQueryParameter['notifyEmail'] = notifyEmail;
            }

            if (notifyDesktop !== undefined) {
                localVarQueryParameter['notifyDesktop'] = notifyDesktop;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Notify a team member
         * @param {string} userId 
         * @param {string} [teamId] 
         * @param {boolean} [notifyWhatsApp] Override notify on WhatsApp
         * @param {boolean} [notifyEmail] Override notify on Email
         * @param {boolean} [notifyDesktop] Override notify on Desktop
         * @param {NotifyRequest} [notifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notify(userId: string, teamId?: string, notifyWhatsApp?: boolean, notifyEmail?: boolean, notifyDesktop?: boolean, notifyRequest?: NotifyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notify200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notify(userId, teamId, notifyWhatsApp, notifyEmail, notifyDesktop, notifyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Notify a team member
         * @param {string} userId 
         * @param {string} [teamId] 
         * @param {boolean} [notifyWhatsApp] Override notify on WhatsApp
         * @param {boolean} [notifyEmail] Override notify on Email
         * @param {boolean} [notifyDesktop] Override notify on Desktop
         * @param {NotifyRequest} [notifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notify(userId: string, teamId?: string, notifyWhatsApp?: boolean, notifyEmail?: boolean, notifyDesktop?: boolean, notifyRequest?: NotifyRequest, options?: any): AxiosPromise<Notify200Response> {
            return localVarFp.notify(userId, teamId, notifyWhatsApp, notifyEmail, notifyDesktop, notifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for notify operation in NotificationsApi.
 * @export
 * @interface NotificationsApiNotifyRequest
 */
export interface NotificationsApiNotifyRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiNotify
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof NotificationsApiNotify
     */
    readonly teamId?: string

    /**
     * Override notify on WhatsApp
     * @type {boolean}
     * @memberof NotificationsApiNotify
     */
    readonly notifyWhatsApp?: boolean

    /**
     * Override notify on Email
     * @type {boolean}
     * @memberof NotificationsApiNotify
     */
    readonly notifyEmail?: boolean

    /**
     * Override notify on Desktop
     * @type {boolean}
     * @memberof NotificationsApiNotify
     */
    readonly notifyDesktop?: boolean

    /**
     * 
     * @type {NotifyRequest}
     * @memberof NotificationsApiNotify
     */
    readonly notifyRequest?: NotifyRequest
}

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Notify a team member
     * @param {NotificationsApiNotifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notify(requestParameters: NotificationsApiNotifyRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notify(requestParameters.userId, requestParameters.teamId, requestParameters.notifyWhatsApp, requestParameters.notifyEmail, requestParameters.notifyDesktop, requestParameters.notifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete: async (token?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TOKENS_DELETE"], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TOKENS_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login to ChatDaddy
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: async (authRequest?: AuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {ExternalTokenRequest} [externalTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPostExternal: async (externalTokenRequest?: ExternalTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token/external`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenDelete(token?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDelete(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefreshToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login to ChatDaddy
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPost(authRequest?: AuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(authRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {ExternalTokenRequest} [externalTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPostExternal(externalTokenRequest?: ExternalTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalTokenPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPostExternal(externalTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete(token?: string, options?: any): AxiosPromise<void> {
            return localVarFp.tokenDelete(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGet(options?: any): AxiosPromise<Array<RefreshToken>> {
            return localVarFp.tokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login to ChatDaddy
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(authRequest?: AuthRequest, options?: any): AxiosPromise<TokenPost200Response> {
            return localVarFp.tokenPost(authRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {ExternalTokenRequest} [externalTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPostExternal(externalTokenRequest?: ExternalTokenRequest, options?: any): AxiosPromise<ExternalTokenPostResponse> {
            return localVarFp.tokenPostExternal(externalTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tokenDelete operation in OAuthApi.
 * @export
 * @interface OAuthApiTokenDeleteRequest
 */
export interface OAuthApiTokenDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof OAuthApiTokenDelete
     */
    readonly token?: string
}

/**
 * Request parameters for tokenPost operation in OAuthApi.
 * @export
 * @interface OAuthApiTokenPostRequest
 */
export interface OAuthApiTokenPostRequest {
    /**
     * 
     * @type {AuthRequest}
     * @memberof OAuthApiTokenPost
     */
    readonly authRequest?: AuthRequest
}

/**
 * Request parameters for tokenPostExternal operation in OAuthApi.
 * @export
 * @interface OAuthApiTokenPostExternalRequest
 */
export interface OAuthApiTokenPostExternalRequest {
    /**
     * 
     * @type {ExternalTokenRequest}
     * @memberof OAuthApiTokenPostExternal
     */
    readonly externalTokenRequest?: ExternalTokenRequest
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * If the token is not specified, all tokens of the user are revoked
     * @summary Revoke refresh tokens
     * @param {OAuthApiTokenDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenDelete(requestParameters: OAuthApiTokenDeleteRequest = {}, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenDelete(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns in descending order of most recently used
     * @summary Fetch list of tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenGet(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login to ChatDaddy
     * @param {OAuthApiTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenPost(requestParameters: OAuthApiTokenPostRequest = {}, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenPost(requestParameters.authRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login via an external partner
     * @param {OAuthApiTokenPostExternalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenPostExternal(requestParameters: OAuthApiTokenPostExternalRequest = {}, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenPostExternal(requestParameters.externalTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OTPApi - axios parameter creator
 * @export
 */
export const OTPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate an OTP
         * @param {OtpPostRequest} [otpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpPost: async (otpPostRequest?: OtpPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(otpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OTPApi - functional programming interface
 * @export
 */
export const OTPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OTPApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate an OTP
         * @param {OtpPostRequest} [otpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async otpPost(otpPostRequest?: OtpPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OTP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.otpPost(otpPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OTPApi - factory interface
 * @export
 */
export const OTPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OTPApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate an OTP
         * @param {OtpPostRequest} [otpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpPost(otpPostRequest?: OtpPostRequest, options?: any): AxiosPromise<OTP> {
            return localVarFp.otpPost(otpPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for otpPost operation in OTPApi.
 * @export
 * @interface OTPApiOtpPostRequest
 */
export interface OTPApiOtpPostRequest {
    /**
     * 
     * @type {OtpPostRequest}
     * @memberof OTPApiOtpPost
     */
    readonly otpPostRequest?: OtpPostRequest
}

/**
 * OTPApi - object-oriented interface
 * @export
 * @class OTPApi
 * @extends {BaseAPI}
 */
export class OTPApi extends BaseAPI {
    /**
     * 
     * @summary Generate an OTP
     * @param {OTPApiOtpPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public otpPost(requestParameters: OTPApiOtpPostRequest = {}, options?: AxiosRequestConfig) {
        return OTPApiFp(this.configuration).otpPost(requestParameters.otpPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
         * @param {string} teamId the teamId of the team to be upgraded/downgraded
         * @param {PartnerTeamPatchRequest} [partnerTeamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTeamPatch: async (teamId: string, partnerTeamPatchRequest?: PartnerTeamPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('partnerTeamPatch', 'teamId', teamId)
            const localVarPath = `/teams/partner-team-status/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerTeamPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {string} [partner] string to identify user with a partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet: async (q?: string, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, partner?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includeTeamMembers !== undefined) {
                localVarQueryParameter['includeTeamMembers'] = includeTeamMembers;
            }

            if (includeInviteLinks !== undefined) {
                localVarQueryParameter['includeInviteLinks'] = includeInviteLinks;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['includeTotal'] = includeTotal;
            }

            if (includeCreator !== undefined) {
                localVarQueryParameter['includeCreator'] = includeCreator;
            }

            if (partner !== undefined) {
                localVarQueryParameter['partner'] = partner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsJoinInvite: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamsJoinInvite', 'id', id)
            const localVarPath = `/teams/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPatch: async (teamPatchRequest?: TeamPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAM_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
         * @param {string} teamId the teamId of the team to be upgraded/downgraded
         * @param {PartnerTeamPatchRequest} [partnerTeamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTeamPatch(teamId: string, partnerTeamPatchRequest?: PartnerTeamPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTeamPatch(teamId, partnerTeamPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {string} [partner] string to identify user with a partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsGet(q?: string, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, partner?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsGet(q, id, userId, count, page, includeTeamMembers, includeInviteLinks, includeTotal, includeCreator, partner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsJoinInvite(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsJoinInvite(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsPatch(teamPatchRequest?: TeamPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsPatch(teamPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * 
         * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
         * @param {string} teamId the teamId of the team to be upgraded/downgraded
         * @param {PartnerTeamPatchRequest} [partnerTeamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTeamPatch(teamId: string, partnerTeamPatchRequest?: PartnerTeamPatchRequest, options?: any): AxiosPromise<TeamsPatch200Response> {
            return localVarFp.partnerTeamPatch(teamId, partnerTeamPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {string} [partner] string to identify user with a partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet(q?: string, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, partner?: string, options?: any): AxiosPromise<TeamsGet200Response> {
            return localVarFp.teamsGet(q, id, userId, count, page, includeTeamMembers, includeInviteLinks, includeTotal, includeCreator, partner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsJoinInvite(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.teamsJoinInvite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPatch(teamPatchRequest?: TeamPatchRequest, options?: any): AxiosPromise<TeamsPatch200Response> {
            return localVarFp.teamsPatch(teamPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for partnerTeamPatch operation in TeamsApi.
 * @export
 * @interface TeamsApiPartnerTeamPatchRequest
 */
export interface TeamsApiPartnerTeamPatchRequest {
    /**
     * the teamId of the team to be upgraded/downgraded
     * @type {string}
     * @memberof TeamsApiPartnerTeamPatch
     */
    readonly teamId: string

    /**
     * 
     * @type {PartnerTeamPatchRequest}
     * @memberof TeamsApiPartnerTeamPatch
     */
    readonly partnerTeamPatchRequest?: PartnerTeamPatchRequest
}

/**
 * Request parameters for teamsGet operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsGetRequest
 */
export interface TeamsApiTeamsGetRequest {
    /**
     * Search by name, ID, invite code, etc.
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly q?: string

    /**
     * Fetch specific teams by ID
     * @type {Array<string>}
     * @memberof TeamsApiTeamsGet
     */
    readonly id?: Array<string>

    /**
     * teams that contain this user ID
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly userId?: string

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly count?: number

    /**
     * The page number
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly page?: number

    /**
     * Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeTeamMembers?: boolean

    /**
     * Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeInviteLinks?: boolean

    /**
     * include the count of the total teams
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeTotal?: boolean

    /**
     * include the creator\&#39;s data in the API result
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeCreator?: boolean

    /**
     * string to identify user with a partner
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly partner?: string
}

/**
 * Request parameters for teamsJoinInvite operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsJoinInviteRequest
 */
export interface TeamsApiTeamsJoinInviteRequest {
    /**
     * inviteLink id
     * @type {string}
     * @memberof TeamsApiTeamsJoinInvite
     */
    readonly id: string
}

/**
 * Request parameters for teamsPatch operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsPatchRequest
 */
export interface TeamsApiTeamsPatchRequest {
    /**
     * 
     * @type {TeamPatchRequest}
     * @memberof TeamsApiTeamsPatch
     */
    readonly teamPatchRequest?: TeamPatchRequest
}

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * 
     * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
     * @param {TeamsApiPartnerTeamPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public partnerTeamPatch(requestParameters: TeamsApiPartnerTeamPatchRequest, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).partnerTeamPatch(requestParameters.teamId, requestParameters.partnerTeamPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch teams you have access to
     * @param {TeamsApiTeamsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsGet(requestParameters: TeamsApiTeamsGetRequest = {}, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsGet(requestParameters.q, requestParameters.id, requestParameters.userId, requestParameters.count, requestParameters.page, requestParameters.includeTeamMembers, requestParameters.includeInviteLinks, requestParameters.includeTotal, requestParameters.includeCreator, requestParameters.partner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a team
     * @param {TeamsApiTeamsJoinInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsJoinInvite(requestParameters: TeamsApiTeamsJoinInviteRequest, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsJoinInvite(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
     * @summary Update the team the access token is for
     * @param {TeamsApiTeamsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsPatch(requestParameters: TeamsApiTeamsPatchRequest = {}, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsPatch(requestParameters.teamPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDelete', 'id', id)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (q?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (originalTeamId) {
                localVarQueryParameter['originalTeamId'] = originalTeamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includeMemberships !== undefined) {
                localVarQueryParameter['includeMemberships'] = includeMemberships;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['includeTotal'] = includeTotal;
            }

            if (other) {
                localVarQueryParameter['other'] = other;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPasswordPatch: async (resetPassword?: ResetPassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch: async (userId?: string, userPatch?: UserPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["USERS_PATCH"], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (userCreate?: UserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(q?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(q, id, originalTeamId, count, page, includeMemberships, includeTotal, other, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPasswordPatch(resetPassword?: ResetPassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPasswordPatch(resetPassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPatch(userId?: string, userPatch?: UserPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPatch(userId, userPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(userCreate?: UserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(q?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, options?: any): AxiosPromise<UsersGet200Response> {
            return localVarFp.usersGet(q, id, originalTeamId, count, page, includeMemberships, includeTotal, other, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPasswordPatch(resetPassword?: ResetPassword, options?: any): AxiosPromise<void> {
            return localVarFp.usersPasswordPatch(resetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch(userId?: string, userPatch?: UserPatch, options?: any): AxiosPromise<User> {
            return localVarFp.usersPatch(userId, userPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(userCreate?: UserCreate, options?: any): AxiosPromise<User> {
            return localVarFp.usersPost(userCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersDeleteRequest
 */
export interface UsersApiUsersDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersDelete
     */
    readonly id: string
}

/**
 * Request parameters for usersGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersGetRequest
 */
export interface UsersApiUsersGetRequest {
    /**
     * Search by name, ID, email, phone etc.
     * @type {string}
     * @memberof UsersApiUsersGet
     */
    readonly q?: string

    /**
     * Fetch specific users by ID
     * @type {Array<string>}
     * @memberof UsersApiUsersGet
     */
    readonly id?: Array<string>

    /**
     * Fetch specific users by original team ID
     * @type {Array<string>}
     * @memberof UsersApiUsersGet
     */
    readonly originalTeamId?: Array<string>

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof UsersApiUsersGet
     */
    readonly count?: number

    /**
     * The page number
     * @type {number}
     * @memberof UsersApiUsersGet
     */
    readonly page?: number

    /**
     * Should include the user\&#39;s memberships
     * @type {boolean}
     * @memberof UsersApiUsersGet
     */
    readonly includeMemberships?: boolean

    /**
     * should return total count of accessible users
     * @type {boolean}
     * @memberof UsersApiUsersGet
     */
    readonly includeTotal?: boolean

    /**
     * other internal query options
     * @type {Array<string>}
     * @memberof UsersApiUsersGet
     */
    readonly other?: Array<string>
}

/**
 * Request parameters for usersPasswordPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersPasswordPatchRequest
 */
export interface UsersApiUsersPasswordPatchRequest {
    /**
     * 
     * @type {ResetPassword}
     * @memberof UsersApiUsersPasswordPatch
     */
    readonly resetPassword?: ResetPassword
}

/**
 * Request parameters for usersPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersPatchRequest
 */
export interface UsersApiUsersPatchRequest {
    /**
     * Change the password of this user ID
     * @type {string}
     * @memberof UsersApiUsersPatch
     */
    readonly userId?: string

    /**
     * 
     * @type {UserPatch}
     * @memberof UsersApiUsersPatch
     */
    readonly userPatch?: UserPatch
}

/**
 * Request parameters for usersPost operation in UsersApi.
 * @export
 * @interface UsersApiUsersPostRequest
 */
export interface UsersApiUsersPostRequest {
    /**
     * 
     * @type {UserCreate}
     * @memberof UsersApiUsersPost
     */
    readonly userCreate?: UserCreate
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Deletes the user specified
     * @summary Delete a user
     * @param {UsersApiUsersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDelete(requestParameters: UsersApiUsersDeleteRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch users you have access to
     * @param {UsersApiUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(requestParameters: UsersApiUsersGetRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGet(requestParameters.q, requestParameters.id, requestParameters.originalTeamId, requestParameters.count, requestParameters.page, requestParameters.includeMemberships, requestParameters.includeTotal, requestParameters.other, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset user password
     * @param {UsersApiUsersPasswordPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPasswordPatch(requestParameters: UsersApiUsersPasswordPatchRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPasswordPatch(requestParameters.resetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the user in the access token
     * @param {UsersApiUsersPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPatch(requestParameters: UsersApiUsersPatchRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPatch(requestParameters.userId, requestParameters.userPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {UsersApiUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(requestParameters: UsersApiUsersPostRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPost(requestParameters.userCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


