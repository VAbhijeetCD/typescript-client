const BASE_PATH = "https://api-bots.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Bots Service
 * Make, Get & Execute Bots
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Action
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Action
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'id': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Action
     */
    'botId'?: string;
    /**
     * Name of the template
     * @type {string}
     * @memberof Action
     */
    'name': string;
    /**
     * 
     * @type {MessageObj}
     * @memberof Action
     */
    'message'?: MessageObj | null;
    /**
     * set the assignee on the contact
     * @type {string}
     * @memberof Action
     */
    'assignee'?: string | null;
    /**
     * Tags to set on this contact.
     * @type {Array<ActionContentTagsInner>}
     * @memberof Action
     */
    'tags'?: Array<ActionContentTagsInner> | null;
    /**
     * Array of UserId
     * @type {Array<string>}
     * @memberof Action
     */
    'notifyUsers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Action
     */
    'webhooks'?: Array<string>;
    /**
     * send in to remove the action
     * @type {boolean}
     * @memberof Action
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface ActionAllOf
 */
export interface ActionAllOf {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionAllOf
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionAllOf
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ActionContent
 */
export interface ActionContent {
    /**
     * 
     * @type {string}
     * @memberof ActionContent
     */
    'id'?: string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof ActionContent
     */
    'botId'?: string;
    /**
     * Name of the template
     * @type {string}
     * @memberof ActionContent
     */
    'name'?: string;
    /**
     * 
     * @type {MessageObj}
     * @memberof ActionContent
     */
    'message'?: MessageObj | null;
    /**
     * set the assignee on the contact
     * @type {string}
     * @memberof ActionContent
     */
    'assignee'?: string | null;
    /**
     * Tags to set on this contact.
     * @type {Array<ActionContentTagsInner>}
     * @memberof ActionContent
     */
    'tags'?: Array<ActionContentTagsInner> | null;
    /**
     * Array of UserId
     * @type {Array<string>}
     * @memberof ActionContent
     */
    'notifyUsers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ActionContent
     */
    'webhooks'?: Array<string>;
    /**
     * send in to remove the action
     * @type {boolean}
     * @memberof ActionContent
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface ActionContentTagsInner
 */
export interface ActionContentTagsInner {
    /**
     * 
     * @type {string}
     * @memberof ActionContentTagsInner
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ActionContentTagsInner
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface ActionFireRecord
 */
export interface ActionFireRecord {
    /**
     * 
     * @type {number}
     * @memberof ActionFireRecord
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'actionId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'contactId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'accountId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionFireRecord
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ActionFireRecord
     */
    'messages'?: Array<ServiceResponse>;
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ActionFireRecord
     */
    'webhooks'?: Array<ServiceResponse>;
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ActionFireRecord
     */
    'notifyUsers'?: Array<ServiceResponse>;
    /**
     * 
     * @type {ServiceResponse}
     * @memberof ActionFireRecord
     */
    'contact'?: ServiceResponse;
}
/**
 * 
 * @export
 * @interface ActionsGet200Response
 */
export interface ActionsGet200Response {
    /**
     * 
     * @type {Array<Action>}
     * @memberof ActionsGet200Response
     */
    'actions': Array<Action>;
    /**
     * Name of the last record fetched
     * @type {string}
     * @memberof ActionsGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface Bot
 */
export interface Bot {
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'name': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Bot
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'startingActionId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'folderId'?: string | null;
    /**
     * 
     * @type {{ [key: string]: ExternalTemplateProvider; }}
     * @memberof Bot
     */
    'externalTemplate'?: { [key: string]: ExternalTemplateProvider; };
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Bot
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Bot
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface BotMessageButton
 */
export interface BotMessageButton {
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'triggerActionId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'triggerBotId'?: string | null;
    /**
     * Make a button with a link
     * @type {string}
     * @memberof BotMessageButton
     */
    'url'?: string;
    /**
     * Make a button with a phone number
     * @type {string}
     * @memberof BotMessageButton
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface BotMessageDelay
 */
export interface BotMessageDelay {
    /**
     * Time delays on second
     * @type {number}
     * @memberof BotMessageDelay
     */
    'timeDelaySec': number;
    /**
     * 
     * @type {string}
     * @memberof BotMessageDelay
     */
    'triggerActionId': string;
    /**
     * 
     * @type {string}
     * @memberof BotMessageDelay
     */
    'triggerBotId'?: string | null;
    /**
     * Simulate typing
     * @type {boolean}
     * @memberof BotMessageDelay
     */
    'simulateTyping'?: boolean;
}
/**
 * 
 * @export
 * @interface BotPatch
 */
export interface BotPatch {
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'startingActionId'?: string;
    /**
     * List of actions to edit/add. Do not specify the ID to add a new action
     * @type {Array<ActionContent>}
     * @memberof BotPatch
     */
    'actions'?: Array<ActionContent>;
}
/**
 * 
 * @export
 * @interface BotsCreateRequest
 */
export interface BotsCreateRequest {
    /**
     * Specify the ID of the bot to be created. Has to be globally unique
     * @type {string}
     * @memberof BotsCreateRequest
     */
    'id'?: string;
    /**
     * The name of the bot to be created
     * @type {string}
     * @memberof BotsCreateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BotsExternalTemplateCommand200Response
 */
export interface BotsExternalTemplateCommand200Response {
    /**
     * 
     * @type {ExternalTemplateProvider}
     * @memberof BotsExternalTemplateCommand200Response
     */
    'config'?: ExternalTemplateProvider;
}
/**
 * 
 * @export
 * @interface BotsFireRequest
 */
export interface BotsFireRequest {
    /**
     * Which account to use
     * @type {string}
     * @memberof BotsFireRequest
     */
    'accountId'?: string;
    /**
     * Contact action is being fired to
     * @type {string}
     * @memberof BotsFireRequest
     */
    'toContact': string;
    /**
     * 
     * @type {BotsFireRequestMessageSendOptions}
     * @memberof BotsFireRequest
     */
    'messageSendOptions'?: BotsFireRequestMessageSendOptions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotsFireRequest
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * Optional parameters to send a message
 * @export
 * @interface BotsFireRequestMessageSendOptions
 */
export interface BotsFireRequestMessageSendOptions {
    /**
     * 
     * @type {string}
     * @memberof BotsFireRequestMessageSendOptions
     */
    'messageId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BotsFireRequestMessageSendOptions
     */
    'simulateTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BotsFireRequestMessageSendOptions
     */
    'requireOpenAccount'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotsFireRequestMessageSendOptions
     */
    'scheduleAt'?: string;
    /**
     * Forwards option to IM service
     * @type {boolean}
     * @memberof BotsFireRequestMessageSendOptions
     */
    'includeMarketingMessage'?: boolean;
    /**
     * 
     * @type {BotsFireRequestMessageSendOptionsQuoted}
     * @memberof BotsFireRequestMessageSendOptions
     */
    'quoted'?: BotsFireRequestMessageSendOptionsQuoted;
}
/**
 * 
 * @export
 * @interface BotsFireRequestMessageSendOptionsQuoted
 */
export interface BotsFireRequestMessageSendOptionsQuoted {
    /**
     * 
     * @type {string}
     * @memberof BotsFireRequestMessageSendOptionsQuoted
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof BotsFireRequestMessageSendOptionsQuoted
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface BotsGetRecord200Response
 */
export interface BotsGetRecord200Response {
    /**
     * 
     * @type {Array<ActionFireRecord>}
     * @memberof BotsGetRecord200Response
     */
    'records': Array<ActionFireRecord>;
    /**
     * Name of the last record fetched
     * @type {string}
     * @memberof BotsGetRecord200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface BotsGets200Response
 */
export interface BotsGets200Response {
    /**
     * 
     * @type {Array<Bot>}
     * @memberof BotsGets200Response
     */
    'bots': Array<Bot>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof BotsGets200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ExternalTemplateProvider
 */
export interface ExternalTemplateProvider {
    /**
     * ID of the template on the provider
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'category': string;
    /**
     * Language of the template
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'language'?: string;
    /**
     * Status of the template on the provider
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'status': ExternalTemplateProviderStatusEnum;
    /**
     * Details of the rejection, if rejected
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'rejectionDetails'?: string;
    /**
     * ID of the user who submitted the template
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'submittedBy': string;
}

export const ExternalTemplateProviderStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type ExternalTemplateProviderStatusEnum = typeof ExternalTemplateProviderStatusEnum[keyof typeof ExternalTemplateProviderStatusEnum];

/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'teamId': string;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'botCount': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Folder
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Folder
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface FolderCreateRequest
 */
export interface FolderCreateRequest {
    /**
     * Folder name
     * @type {string}
     * @memberof FolderCreateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FolderGet200Response
 */
export interface FolderGet200Response {
    /**
     * 
     * @type {Array<Folder>}
     * @memberof FolderGet200Response
     */
    'folders': Array<Folder>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof FolderGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface FolderUpdateRequest
 */
export interface FolderUpdateRequest {
    /**
     * Folder name
     * @type {string}
     * @memberof FolderUpdateRequest
     */
    'name'?: string;
    /**
     * Bot IDs to add to the folder
     * @type {Array<FolderUpdateRequestBotIdsInner>}
     * @memberof FolderUpdateRequest
     */
    'botIds'?: Array<FolderUpdateRequestBotIdsInner>;
}
/**
 * 
 * @export
 * @interface FolderUpdateRequestBotIdsInner
 */
export interface FolderUpdateRequestBotIdsInner {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FolderUpdateRequestBotIdsInner
     */
    'botId': string;
    /**
     * If true, remove the bot from the folder
     * @type {boolean}
     * @memberof FolderUpdateRequestBotIdsInner
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface IMMessageAttachment
 */
export interface IMMessageAttachment {
    /**
     * 
     * @type {IMMessageAttachmentType}
     * @memberof IMMessageAttachment
     */
    'type': IMMessageAttachmentType;
    /**
     * 
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'mimetype': string;
    /**
     * 1. can be publicly hosted url,  2. or can be base64 encoded buffer. But make sure it starts with `data:;base64,` Note: the `contact` type only supports base64 encoded data 
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'url': string;
    /**
     * thumbnail of sticker/video/image
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'jpegThumbnail'?: string | null;
    /**
     * duration of audio/video message
     * @type {number}
     * @memberof IMMessageAttachment
     */
    'seconds'?: number;
    /**
     * name of the doc message
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IMMessageAttachmentType = {
    Image: 'image',
    Video: 'video',
    Contact: 'contact',
    Sticker: 'sticker',
    Audio: 'audio',
    Document: 'document',
    Location: 'location'
} as const;

export type IMMessageAttachmentType = typeof IMMessageAttachmentType[keyof typeof IMMessageAttachmentType];


/**
 * 
 * @export
 * @interface IMMessageProduct
 */
export interface IMMessageProduct {
    /**
     * 
     * @type {string}
     * @memberof IMMessageProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IMMessageProduct
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface MessageObj
 */
export interface MessageObj {
    /**
     * the template message itself
     * @type {string}
     * @memberof MessageObj
     */
    'text': string;
    /**
     * array of attachments for the template
     * @type {Array<IMMessageAttachment>}
     * @memberof MessageObj
     */
    'attachments'?: Array<IMMessageAttachment>;
    /**
     * 
     * @type {Array<BotMessageButton>}
     * @memberof MessageObj
     */
    'buttons'?: Array<BotMessageButton>;
    /**
     * 
     * @type {Array<BotMessageDelay>}
     * @memberof MessageObj
     */
    'delays'?: Array<BotMessageDelay>;
    /**
     * 
     * @type {string}
     * @memberof MessageObj
     */
    'quoted'?: string;
    /**
     * 
     * @type {Array<IMMessageProduct>}
     * @memberof MessageObj
     */
    'products'?: Array<IMMessageProduct>;
}
/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * 
     * @type {number}
     * @memberof ServiceResponse
     */
    'statusCode': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ServiceResponse
     */
    'body'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface StoreCreateRequest
 */
export interface StoreCreateRequest {
    /**
     * 
     * @type {StoreCreateRequestValues}
     * @memberof StoreCreateRequest
     */
    'values': StoreCreateRequestValues;
    /**
     * yaml file of boat
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'botFileUrl': string;
    /**
     * User Name for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'userName': string;
    /**
     * Language for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'language': string;
    /**
     * Image Url for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'imageUrl': string;
}
/**
 * 
 * @export
 * @interface StoreCreateRequestValues
 */
export interface StoreCreateRequestValues {
    /**
     * Name of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'templateName': string;
    /**
     * Category of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'templateCategory': string;
    /**
     * Name of Bot Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'botTemplate': string;
    /**
     * Image of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'image': string;
    /**
     * Description of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface StoreGet200Response
 */
export interface StoreGet200Response {
    /**
     * 
     * @type {Array<TemplateItem>}
     * @memberof StoreGet200Response
     */
    'templates': Array<TemplateItem>;
    /**
     * Cursor to fetch the next page
     * @type {string}
     * @memberof StoreGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TemplateCommand = {
    SubmitForReview: 'submit-for-review',
    Link: 'link',
    Unlink: 'unlink'
} as const;

export type TemplateCommand = typeof TemplateCommand[keyof typeof TemplateCommand];


/**
 * 
 * @export
 * @interface TemplateItem
 */
export interface TemplateItem {
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'yamlFileUrl': string;
}
/**
 * 
 * @export
 * @interface TemplateStatusUpdateRequestInner
 */
export interface TemplateStatusUpdateRequestInner {
    /**
     * Code of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestInner
     */
    'TemplateCode': string;
    /**
     * Status of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestInner
     */
    'AuditStatus': TemplateStatusUpdateRequestInnerAuditStatusEnum;
    /**
     * Language of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestInner
     */
    'Language': string;
    /**
     * Waba ID of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestInner
     */
    'WabaId': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateStatusUpdateRequestInner
     */
    'Reason'?: string;
}

export const TemplateStatusUpdateRequestInnerAuditStatusEnum = {
    Fail: 'fail',
    Pass: 'pass'
} as const;

export type TemplateStatusUpdateRequestInnerAuditStatusEnum = typeof TemplateStatusUpdateRequestInnerAuditStatusEnum[keyof typeof TemplateStatusUpdateRequestInnerAuditStatusEnum];


/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGet: async (count?: number, before?: string, q?: string, botId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionsGet(count?: number, before?: string, q?: string, botId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionsGet(count, before, q, botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGet(count?: number, before?: string, q?: string, botId?: string, options?: any): AxiosPromise<ActionsGet200Response> {
            return localVarFp.actionsGet(count, before, q, botId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for actionsGet operation in ActionsApi.
 * @export
 * @interface ActionsApiActionsGetRequest
 */
export interface ActionsApiActionsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ActionsApiActionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly botId?: string
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * 
     * @summary Gets all actions related to account/team
     * @param {ActionsApiActionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public actionsGet(requestParameters: ActionsApiActionsGetRequest = {}, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).actionsGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotsApi - axios parameter creator
 * @export
 */
export const BotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsCreate: async (botsCreateRequest?: BotsCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDeletes: async (bots: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bots' is not null or undefined
            assertParamExists('botsDeletes', 'bots', bots)
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (bots) {
                localVarQueryParameter['bots'] = bots;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsExternalTemplateCommand: async (id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'id', id)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'accountId', accountId)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'command', command)
            const localVarPath = `/bots/{id}/external-template/{accountId}/{command}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsFire: async (id: string, botsFireRequest?: BotsFireRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsFire', 'id', id)
            const localVarPath = `/bots/{id}/fire`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsFireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of execution records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGetRecord: async (count?: number, beforeId?: number, botId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (beforeId !== undefined) {
                localVarQueryParameter['beforeId'] = beforeId;
            }

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGets: async (q?: string, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPatch: async (id: string, botPatch?: BotPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsPatch', 'id', id)
            const localVarPath = `/bots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotsApi - functional programming interface
 * @export
 */
export const BotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsCreate(botsCreateRequest?: BotsCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsCreate(botsCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsDeletes(bots: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsDeletes(bots, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsExternalTemplateCommand(id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsExternalTemplateCommand200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsExternalTemplateCommand(id, accountId, command, language, category, templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsFire(id: string, botsFireRequest?: BotsFireRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionFireRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsFire(id, botsFireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns list of execution records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsGetRecord(count?: number, beforeId?: number, botId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsGetRecord200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsGetRecord(count, beforeId, botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsGets(q?: string, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsGets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsGets(q, before, count, id, sortBy, order, folderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsPatch(id: string, botPatch?: BotPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsPatch(id, botPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotsApi - factory interface
 * @export
 */
export const BotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsCreate(botsCreateRequest?: BotsCreateRequest, options?: any): AxiosPromise<Bot> {
            return localVarFp.botsCreate(botsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDeletes(bots: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.botsDeletes(bots, options).then((request) => request(axios, basePath));
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsExternalTemplateCommand(id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options?: any): AxiosPromise<BotsExternalTemplateCommand200Response> {
            return localVarFp.botsExternalTemplateCommand(id, accountId, command, language, category, templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsFire(id: string, botsFireRequest?: BotsFireRequest, options?: any): AxiosPromise<ActionFireRecord> {
            return localVarFp.botsFire(id, botsFireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of execution records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGetRecord(count?: number, beforeId?: number, botId?: string, options?: any): AxiosPromise<BotsGetRecord200Response> {
            return localVarFp.botsGetRecord(count, beforeId, botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGets(q?: string, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, options?: any): AxiosPromise<BotsGets200Response> {
            return localVarFp.botsGets(q, before, count, id, sortBy, order, folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPatch(id: string, botPatch?: BotPatch, options?: any): AxiosPromise<void> {
            return localVarFp.botsPatch(id, botPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botsCreate operation in BotsApi.
 * @export
 * @interface BotsApiBotsCreateRequest
 */
export interface BotsApiBotsCreateRequest {
    /**
     * 
     * @type {BotsCreateRequest}
     * @memberof BotsApiBotsCreate
     */
    readonly botsCreateRequest?: BotsCreateRequest
}

/**
 * Request parameters for botsDeletes operation in BotsApi.
 * @export
 * @interface BotsApiBotsDeletesRequest
 */
export interface BotsApiBotsDeletesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof BotsApiBotsDeletes
     */
    readonly bots: Array<string>
}

/**
 * Request parameters for botsExternalTemplateCommand operation in BotsApi.
 * @export
 * @interface BotsApiBotsExternalTemplateCommandRequest
 */
export interface BotsApiBotsExternalTemplateCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly accountId: string

    /**
     * 
     * @type {TemplateCommand}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly command: TemplateCommand

    /**
     * ISO code of the language, required for WA business templates
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly language?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly category?: string

    /**
     * The external ID of the template to link with, only valid for the \&quot;link\&quot; command
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly templateId?: string
}

/**
 * Request parameters for botsFire operation in BotsApi.
 * @export
 * @interface BotsApiBotsFireRequest
 */
export interface BotsApiBotsFireRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsFire
     */
    readonly id: string

    /**
     * 
     * @type {BotsFireRequest}
     * @memberof BotsApiBotsFire
     */
    readonly botsFireRequest?: BotsFireRequest
}

/**
 * Request parameters for botsGetRecord operation in BotsApi.
 * @export
 * @interface BotsApiBotsGetRecordRequest
 */
export interface BotsApiBotsGetRecordRequest {
    /**
     * 
     * @type {number}
     * @memberof BotsApiBotsGetRecord
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof BotsApiBotsGetRecord
     */
    readonly beforeId?: number

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGetRecord
     */
    readonly botId?: string
}

/**
 * Request parameters for botsGets operation in BotsApi.
 * @export
 * @interface BotsApiBotsGetsRequest
 */
export interface BotsApiBotsGetsRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly before?: string

    /**
     * 
     * @type {number}
     * @memberof BotsApiBotsGets
     */
    readonly count?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof BotsApiBotsGets
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {'name' | 'updatedAt'}
     * @memberof BotsApiBotsGets
     */
    readonly sortBy?: 'name' | 'updatedAt'

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof BotsApiBotsGets
     */
    readonly order?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly folderId?: string
}

/**
 * Request parameters for botsPatch operation in BotsApi.
 * @export
 * @interface BotsApiBotsPatchRequest
 */
export interface BotsApiBotsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsPatch
     */
    readonly id: string

    /**
     * 
     * @type {BotPatch}
     * @memberof BotsApiBotsPatch
     */
    readonly botPatch?: BotPatch
}

/**
 * BotsApi - object-oriented interface
 * @export
 * @class BotsApi
 * @extends {BaseAPI}
 */
export class BotsApi extends BaseAPI {
    /**
     * 
     * @summary Creates new bot
     * @param {BotsApiBotsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsCreate(requestParameters: BotsApiBotsCreateRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsCreate(requestParameters.botsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of bots
     * @param {BotsApiBotsDeletesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsDeletes(requestParameters: BotsApiBotsDeletesRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsDeletes(requestParameters.bots, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Either submit for review, unlink from the external template provider or link with an existing template ID
     * @summary Execute a command to update the status for the external template
     * @param {BotsApiBotsExternalTemplateCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsExternalTemplateCommand(requestParameters: BotsApiBotsExternalTemplateCommandRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsExternalTemplateCommand(requestParameters.id, requestParameters.accountId, requestParameters.command, requestParameters.language, requestParameters.category, requestParameters.templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Will throw a 400 if there is no starting action ID
     * @summary Initiates a bot sequence. Fires the starting action ID
     * @param {BotsApiBotsFireRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsFire(requestParameters: BotsApiBotsFireRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsFire(requestParameters.id, requestParameters.botsFireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of execution records
     * @param {BotsApiBotsGetRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsGetRecord(requestParameters: BotsApiBotsGetRecordRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsGetRecord(requestParameters.count, requestParameters.beforeId, requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of bots
     * @param {BotsApiBotsGetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsGets(requestParameters: BotsApiBotsGetsRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsGets(requestParameters.q, requestParameters.before, requestParameters.count, requestParameters.id, requestParameters.sortBy, requestParameters.order, requestParameters.folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an action
     * @param {BotsApiBotsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsPatch(requestParameters: BotsApiBotsPatchRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsPatch(requestParameters.id, requestParameters.botPatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderCreate: async (folderCreateRequest?: FolderCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderDelete: async (folders: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folders' is not null or undefined
            assertParamExists('folderDelete', 'folders', folders)
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (folders) {
                localVarQueryParameter['folders'] = folders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderGet: async (count?: number, before?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderUpdate: async (folderId: string, folderUpdateRequest?: FolderUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('folderUpdate', 'folderId', folderId)
            const localVarPath = `/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderCreate(folderCreateRequest?: FolderCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderCreate(folderCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderDelete(folders: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderDelete(folders, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderGet(count?: number, before?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderGet(count, before, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderUpdate(folderId: string, folderUpdateRequest?: FolderUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderUpdate(folderId, folderUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderCreate(folderCreateRequest?: FolderCreateRequest, options?: any): AxiosPromise<Folder> {
            return localVarFp.folderCreate(folderCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderDelete(folders: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.folderDelete(folders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderGet(count?: number, before?: string, q?: string, options?: any): AxiosPromise<FolderGet200Response> {
            return localVarFp.folderGet(count, before, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderUpdate(folderId: string, folderUpdateRequest?: FolderUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.folderUpdate(folderId, folderUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for folderCreate operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderCreateRequest
 */
export interface FoldersApiFolderCreateRequest {
    /**
     * 
     * @type {FolderCreateRequest}
     * @memberof FoldersApiFolderCreate
     */
    readonly folderCreateRequest?: FolderCreateRequest
}

/**
 * Request parameters for folderDelete operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderDeleteRequest
 */
export interface FoldersApiFolderDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof FoldersApiFolderDelete
     */
    readonly folders: Array<string>
}

/**
 * Request parameters for folderGet operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderGetRequest
 */
export interface FoldersApiFolderGetRequest {
    /**
     * 
     * @type {number}
     * @memberof FoldersApiFolderGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderGet
     */
    readonly q?: string
}

/**
 * Request parameters for folderUpdate operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderUpdateRequest
 */
export interface FoldersApiFolderUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderUpdate
     */
    readonly folderId: string

    /**
     * 
     * @type {FolderUpdateRequest}
     * @memberof FoldersApiFolderUpdate
     */
    readonly folderUpdateRequest?: FolderUpdateRequest
}

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * 
     * @summary Create folder
     * @param {FoldersApiFolderCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderCreate(requestParameters: FoldersApiFolderCreateRequest = {}, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderCreate(requestParameters.folderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of folders
     * @param {FoldersApiFolderDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderDelete(requestParameters: FoldersApiFolderDeleteRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderDelete(requestParameters.folders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all folders related to account/team
     * @param {FoldersApiFolderGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderGet(requestParameters: FoldersApiFolderGetRequest = {}, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderGet(requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update folder
     * @param {FoldersApiFolderUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderUpdate(requestParameters: FoldersApiFolderUpdateRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderUpdate(requestParameters.folderId, requestParameters.folderUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCreate: async (storeCreateRequest?: StoreCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGet: async (count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (categoryKeyValue) {
                localVarQueryParameter['categoryKeyValue'] = categoryKeyValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeCreate(storeCreateRequest?: StoreCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeCreate(storeCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeGet(count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeGet(count, before, q, language, categoryKeyValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCreate(storeCreateRequest?: StoreCreateRequest, options?: any): AxiosPromise<TemplateItem> {
            return localVarFp.storeCreate(storeCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGet(count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options?: any): AxiosPromise<StoreGet200Response> {
            return localVarFp.storeGet(count, before, q, language, categoryKeyValue, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for storeCreate operation in StoreApi.
 * @export
 * @interface StoreApiStoreCreateRequest
 */
export interface StoreApiStoreCreateRequest {
    /**
     * 
     * @type {StoreCreateRequest}
     * @memberof StoreApiStoreCreate
     */
    readonly storeCreateRequest?: StoreCreateRequest
}

/**
 * Request parameters for storeGet operation in StoreApi.
 * @export
 * @interface StoreApiStoreGetRequest
 */
export interface StoreApiStoreGetRequest {
    /**
     * 
     * @type {number}
     * @memberof StoreApiStoreGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly language?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof StoreApiStoreGet
     */
    readonly categoryKeyValue?: Array<string>
}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * 
     * @summary Create options in the store
     * @param {StoreApiStoreCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeCreate(requestParameters: StoreApiStoreCreateRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeCreate(requestParameters.storeCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get options in the store
     * @param {StoreApiStoreGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeGet(requestParameters: StoreApiStoreGetRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.language, requestParameters.categoryKeyValue, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateWebhookApi - axios parameter creator
 * @export
 */
export const TemplateWebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Webhook for template status
         * @param {string} secret 
         * @param {Array<TemplateStatusUpdateRequestInner>} [templateStatusUpdateRequestInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookTemplateStatus: async (secret: string, templateStatusUpdateRequestInner?: Array<TemplateStatusUpdateRequestInner>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('webhookTemplateStatus', 'secret', secret)
            const localVarPath = `/webhook/template-status/alibaba-cams/{secret}`
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateStatusUpdateRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateWebhookApi - functional programming interface
 * @export
 */
export const TemplateWebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateWebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Webhook for template status
         * @param {string} secret 
         * @param {Array<TemplateStatusUpdateRequestInner>} [templateStatusUpdateRequestInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookTemplateStatus(secret: string, templateStatusUpdateRequestInner?: Array<TemplateStatusUpdateRequestInner>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookTemplateStatus(secret, templateStatusUpdateRequestInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateWebhookApi - factory interface
 * @export
 */
export const TemplateWebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateWebhookApiFp(configuration)
    return {
        /**
         * 
         * @summary Webhook for template status
         * @param {string} secret 
         * @param {Array<TemplateStatusUpdateRequestInner>} [templateStatusUpdateRequestInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookTemplateStatus(secret: string, templateStatusUpdateRequestInner?: Array<TemplateStatusUpdateRequestInner>, options?: any): AxiosPromise<void> {
            return localVarFp.webhookTemplateStatus(secret, templateStatusUpdateRequestInner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for webhookTemplateStatus operation in TemplateWebhookApi.
 * @export
 * @interface TemplateWebhookApiWebhookTemplateStatusRequest
 */
export interface TemplateWebhookApiWebhookTemplateStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof TemplateWebhookApiWebhookTemplateStatus
     */
    readonly secret: string

    /**
     * 
     * @type {Array<TemplateStatusUpdateRequestInner>}
     * @memberof TemplateWebhookApiWebhookTemplateStatus
     */
    readonly templateStatusUpdateRequestInner?: Array<TemplateStatusUpdateRequestInner>
}

/**
 * TemplateWebhookApi - object-oriented interface
 * @export
 * @class TemplateWebhookApi
 * @extends {BaseAPI}
 */
export class TemplateWebhookApi extends BaseAPI {
    /**
     * 
     * @summary Webhook for template status
     * @param {TemplateWebhookApiWebhookTemplateStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateWebhookApi
     */
    public webhookTemplateStatus(requestParameters: TemplateWebhookApiWebhookTemplateStatusRequest, options?: AxiosRequestConfig) {
        return TemplateWebhookApiFp(this.configuration).webhookTemplateStatus(requestParameters.secret, requestParameters.templateStatusUpdateRequestInner, options).then((request) => request(this.axios, this.basePath));
    }
}


