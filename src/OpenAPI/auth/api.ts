const BASE_PATH = "https://api-teams.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Auth & Teams Service
 * Manage Users & Teams
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface AccountNotificationPreference
 */
export interface AccountNotificationPreference {
    /**
     * 
     * @type {Array<NotificationDestination>}
     * @memberof AccountNotificationPreference
     */
    'destinations': Array<NotificationDestination>;
    /**
     * List of accounts to receive notifications for. If empty, all accounts will be notified.
     * @type {Array<AccountNotificationPreferenceAccountsInner>}
     * @memberof AccountNotificationPreference
     */
    'accounts'?: Array<AccountNotificationPreferenceAccountsInner>;
}
/**
 * 
 * @export
 * @interface AccountNotificationPreferenceAccountsInner
 */
export interface AccountNotificationPreferenceAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof AccountNotificationPreferenceAccountsInner
     */
    'id': string;
}
/**
 * @type AuthRequest
 * @export
 */
export type AuthRequest = PasswordAuthRequest | RefreshTokenLoginRequest;

/**
 * Login with Boutir
 * @export
 * @interface BoutirTokenRequest
 */
export interface BoutirTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'type': BoutirTokenRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'referralCode'?: string;
}

export const BoutirTokenRequestTypeEnum = {
    Boutir: 'boutir'
} as const;

export type BoutirTokenRequestTypeEnum = typeof BoutirTokenRequestTypeEnum[keyof typeof BoutirTokenRequestTypeEnum];

/**
 * 
 * @export
 * @interface ConfirmOtp200Response
 */
export interface ConfirmOtp200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ConfirmOtp200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface ExternalTokenPostResponse
 */
export interface ExternalTokenPostResponse {
    /**
     * Was the user just created
     * @type {boolean}
     * @memberof ExternalTokenPostResponse
     */
    'created'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'refresh_token_expiry'?: string;
}
/**
 * 
 * @export
 * @interface ExternalTokenPostResponseAllOf
 */
export interface ExternalTokenPostResponseAllOf {
    /**
     * Was the user just created
     * @type {boolean}
     * @memberof ExternalTokenPostResponseAllOf
     */
    'created'?: boolean;
}
/**
 * @type ExternalTokenRequest
 * @export
 */
export type ExternalTokenRequest = BoutirTokenRequest | FirebaseTokenRequest;

/**
 * Login with Firebase
 * @export
 * @interface FirebaseTokenRequest
 */
export interface FirebaseTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'type': FirebaseTokenRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'idToken': string;
    /**
     * 
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'referralCode'?: string;
}

export const FirebaseTokenRequestTypeEnum = {
    Firebase: 'firebase'
} as const;

export type FirebaseTokenRequestTypeEnum = typeof FirebaseTokenRequestTypeEnum[keyof typeof FirebaseTokenRequestTypeEnum];

/**
 * 
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'id': string;
    /**
     * Unique identifier for a team
     * @type {string}
     * @memberof InviteLink
     */
    'teamId': string;
    /**
     * User ID of the person who created the link
     * @type {string}
     * @memberof InviteLink
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'expiresAt': string;
    /**
     * The scopes allowed for the invite link
     * @type {Array<Scope>}
     * @memberof InviteLink
     */
    'scopes': Array<Scope>;
    /**
     * 
     * @type {Team}
     * @memberof InviteLink
     */
    'team'?: Team;
}
/**
 * 
 * @export
 * @interface InviteLinksPostRequest
 */
export interface InviteLinksPostRequest {
    /**
     * 
     * @type {Array<Scope>}
     * @memberof InviteLinksPostRequest
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface JWT
 */
export interface JWT {
    /**
     * Binary representation of the scope array
     * @type {string}
     * @memberof JWT
     */
    'scope': string;
    /**
     * 
     * @type {number}
     * @memberof JWT
     */
    'exp': number;
    /**
     * 
     * @type {number}
     * @memberof JWT
     */
    'iat': number;
    /**
     * 
     * @type {JWTUser}
     * @memberof JWT
     */
    'user': JWTUser;
}
/**
 * 
 * @export
 * @interface JWTUser
 */
export interface JWTUser {
    /**
     * Unique identifier for a user
     * @type {string}
     * @memberof JWTUser
     */
    'id': string;
    /**
     * Unique identifier for a team
     * @type {string}
     * @memberof JWTUser
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'fullName'?: string;
    /**
     * 
     * @type {number}
     * @memberof JWTUser
     */
    'phoneNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'emailAddress'?: string;
}
/**
 * 
 * @export
 * @interface NewMessageNotificationPreference
 */
export interface NewMessageNotificationPreference {
    /**
     * 
     * @type {Array<string>}
     * @memberof NewMessageNotificationPreference
     */
    'destinations': Array<NewMessageNotificationPreferenceDestinationsEnum>;
    /**
     * 
     * @type {NewMessageNotificationType}
     * @memberof NewMessageNotificationPreference
     */
    'defaultType'?: NewMessageNotificationType;
    /**
     * List of accounts to receive notifications for. If empty, all accounts will be notified based on the preference set in \"\"
     * @type {Array<NewMessageNotificationPreferenceAccountsInner>}
     * @memberof NewMessageNotificationPreference
     */
    'accounts'?: Array<NewMessageNotificationPreferenceAccountsInner>;
}

export const NewMessageNotificationPreferenceDestinationsEnum = {
    Push: 'push'
} as const;

export type NewMessageNotificationPreferenceDestinationsEnum = typeof NewMessageNotificationPreferenceDestinationsEnum[keyof typeof NewMessageNotificationPreferenceDestinationsEnum];

/**
 * 
 * @export
 * @interface NewMessageNotificationPreferenceAccountsInner
 */
export interface NewMessageNotificationPreferenceAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof NewMessageNotificationPreferenceAccountsInner
     */
    'id': string;
    /**
     * 
     * @type {NewMessageNotificationType}
     * @memberof NewMessageNotificationPreferenceAccountsInner
     */
    'type': NewMessageNotificationType;
}
/**
 * @type NewMessageNotificationType
 * @export
 */
export type NewMessageNotificationType = Array<string> | string;

/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationDestination = {
    Push: 'push',
    Email: 'email',
    Whatsapp: 'whatsapp'
} as const;

export type NotificationDestination = typeof NotificationDestination[keyof typeof NotificationDestination];


/**
 * 
 * @export
 * @interface NotificationMiscData
 */
export interface NotificationMiscData {
    /**
     * The path to open when the notification is clicked
     * @type {string}
     * @memberof NotificationMiscData
     */
    'path'?: string;
    /**
     * The image to show in the notification
     * @type {string}
     * @memberof NotificationMiscData
     */
    'imgUrl'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NotificationMiscData
     */
    'context'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NotificationPreferences
 */
export interface NotificationPreferences {
    /**
     * 
     * @type {AccountNotificationPreference}
     * @memberof NotificationPreferences
     */
    'accountDisconnected'?: AccountNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'contactAssignedToMe'?: SimpleNotificationPreference;
    /**
     * 
     * @type {NewMessageNotificationPreference}
     * @memberof NotificationPreferences
     */
    'newMessage'?: NewMessageNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'teamMemberAdded'?: SimpleNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'trackingAdded'?: SimpleNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'trackingErrored'?: SimpleNotificationPreference;
    /**
     * 
     * @type {AccountNotificationPreference}
     * @memberof NotificationPreferences
     */
    'botExternalTemplateStatusUpdated'?: AccountNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'actionExecute'?: SimpleNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'noteMentionsMe'?: SimpleNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'payments'?: SimpleNotificationPreference;
}
/**
 * @type NotificationResult
 * @export
 */
export type NotificationResult = boolean | string;

/**
 * Deprecated. Use notificationPreferences instead
 * @export
 * @interface NotifyModel
 */
export interface NotifyModel {
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'whatsapp'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'email'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'desktop'?: boolean;
}
/**
 * 
 * @export
 * @interface NotifyRequestWithContent
 */
export interface NotifyRequestWithContent {
    /**
     * 
     * @type {string}
     * @memberof NotifyRequestWithContent
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof NotifyRequestWithContent
     */
    'content': string;
    /**
     * 
     * @type {NotifyRequestWithContentOverrides}
     * @memberof NotifyRequestWithContent
     */
    'overrides'?: NotifyRequestWithContentOverrides;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NotifyRequestWithContent
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NotifyRequestWithContentOverrides
 */
export interface NotifyRequestWithContentOverrides {
    /**
     * 
     * @type {NotifyRequestWithContentOverridesWhatsapp}
     * @memberof NotifyRequestWithContentOverrides
     */
    'whatsapp'?: NotifyRequestWithContentOverridesWhatsapp;
}
/**
 * 
 * @export
 * @interface NotifyRequestWithContentOverridesWhatsapp
 */
export interface NotifyRequestWithContentOverridesWhatsapp {
    /**
     * 
     * @type {string}
     * @memberof NotifyRequestWithContentOverridesWhatsapp
     */
    'botId': string;
}
/**
 * 
 * @export
 * @interface OTP
 */
export interface OTP {
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'phoneNumber': number;
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'otp'?: number;
    /**
     * 
     * @type {string}
     * @memberof OTP
     */
    'expiresAt': string;
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'resendsLeft': number;
}
/**
 * 
 * @export
 * @interface OnboardingStep
 */
export interface OnboardingStep {
    /**
     * 
     * @type {OnboardingStepID}
     * @memberof OnboardingStep
     */
    'id': OnboardingStepID;
    /**
     * 
     * @type {string}
     * @memberof OnboardingStep
     */
    'doneAt': string;
    /**
     * ID of the user that completed the step
     * @type {string}
     * @memberof OnboardingStep
     */
    'doneBy': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const OnboardingStepID = {
    ConnectedWa: 'connectedWa',
    SentMessage: 'sentMessage',
    UsedMobileVersion: 'usedMobileVersion',
    InvitedTeamMember: 'invitedTeamMember',
    CreatedNote: 'createdNote',
    CreatedTag: 'createdTag',
    CreatedMessageFlow: 'createdMessageFlow',
    SentMessageFlowByShortcut: 'sentMessageFlowByShortcut',
    AssignedChatToTeamMember: 'assignedChatToTeamMember',
    ScheduledAMessage: 'scheduledAMessage',
    CreatedMessageFlowWithButtons: 'createdMessageFlowWithButtons',
    SentMessageFlowWithButtons: 'sentMessageFlowWithButtons',
    AutoTagOrAssignWithMessageFlow: 'autoTagOrAssignWithMessageFlow',
    CreatedFirstBroadcast: 'createdFirstBroadcast',
    ScheduledFirstBroadcast: 'scheduledFirstBroadcast',
    ToggleOfflineBotOn: 'toggleOfflineBotOn',
    CreatedFirstKeywordBot: 'createdFirstKeywordBot',
    ConnectFirstIntegration: 'connectFirstIntegration',
    ImportedContacts: 'importedContacts',
    AdddedACustomFieldToContact: 'adddedACustomFieldToContact'
} as const;

export type OnboardingStepID = typeof OnboardingStepID[keyof typeof OnboardingStepID];


/**
 * 
 * @export
 * @interface OtpPostRequest
 */
export interface OtpPostRequest {
    /**
     * 
     * @type {string}
     * @memberof OtpPostRequest
     */
    'phoneNumber': string;
    /**
     * Optionally specify the OTP template type
     * @type {string}
     * @memberof OtpPostRequest
     */
    'template'?: string;
    /**
     * 
     * @type {string}
     * @memberof OtpPostRequest
     */
    'captchaToken'?: string;
}
/**
 * 
 * @export
 * @interface OtpTokenPost200Response
 */
export interface OtpTokenPost200Response {
    /**
     * 
     * @type {string}
     * @memberof OtpTokenPost200Response
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface OtpTokenPostRequest
 */
export interface OtpTokenPostRequest {
    /**
     * 
     * @type {string}
     * @memberof OtpTokenPostRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof OtpTokenPostRequest
     */
    'otp': string;
}
/**
 * 
 * @export
 * @interface PartnerTeamPatchRequest
 */
export interface PartnerTeamPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerTeamPatchRequest
     */
    'partnerAdmin': string | null;
}
/**
 * 
 * @export
 * @interface PasswordAuthRequest
 */
export interface PasswordAuthRequest {
    /**
     * 
     * @type {number}
     * @memberof PasswordAuthRequest
     */
    'phoneNumber': number;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'returnRefreshToken'?: boolean;
    /**
     * Base64 encoded SHA256 of the plaintext password, or the plaintext itself. See \"passwordEncoding\" below
     * @type {string}
     * @memberof PasswordAuthRequest
     */
    'password': string;
    /**
     * describe how the password is encoded
     * @type {string}
     * @memberof PasswordAuthRequest
     */
    'passwordEncoding'?: PasswordAuthRequestPasswordEncodingEnum;
    /**
     * The team ID to generate the token for, lastUsedTeam will be used otherwise
     * @type {string}
     * @memberof PasswordAuthRequest
     */
    'teamId'?: string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof PasswordAuthRequest
     */
    'scopes'?: Array<Scope>;
    /**
     * Should logging in with this team ID update the lastUsedTeam for login
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'updateLastUsedTeam'?: boolean;
    /**
     * Force the generation of an access token
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'force'?: boolean;
}

export const PasswordAuthRequestPasswordEncodingEnum = {
    ShaBase64: 'shaBase64',
    Plaintext: 'plaintext'
} as const;

export type PasswordAuthRequestPasswordEncodingEnum = typeof PasswordAuthRequestPasswordEncodingEnum[keyof typeof PasswordAuthRequestPasswordEncodingEnum];

/**
 * A refresh token allows you to generate access tokens to access & update things on ChatDaddy services. A refresh token will expire and become invalidated after 14 days of no activity. 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenLoginRequest
 */
export interface RefreshTokenLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenLoginRequest
     */
    'refreshToken': string;
    /**
     * The team ID to generate the token for, lastUsedTeam will be used otherwise
     * @type {string}
     * @memberof RefreshTokenLoginRequest
     */
    'teamId': string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof RefreshTokenLoginRequest
     */
    'scopes'?: Array<Scope>;
    /**
     * Should fetching the token of a new team update the lastUsedTeam for login
     * @type {boolean}
     * @memberof RefreshTokenLoginRequest
     */
    'updateLastUsedTeam'?: boolean;
    /**
     * Force the generation of an access token
     * @type {boolean}
     * @memberof RefreshTokenLoginRequest
     */
    'force'?: boolean;
}
/**
 * 
 * @export
 * @interface ResetPassword
 */
export interface ResetPassword {
    /**
     * 
     * @type {string}
     * @memberof ResetPassword
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Scope = {
    WaState: 'WA_STATE',
    ContactsReadAssigned: 'CONTACTS_READ_ASSIGNED',
    ContactsReadAll: 'CONTACTS_READ_ALL',
    ContactsExportButton: 'CONTACTS_EXPORT_BUTTON',
    ContactsCreate: 'CONTACTS_CREATE',
    ContactsDelete: 'CONTACTS_DELETE',
    ContactsUpdate: 'CONTACTS_UPDATE',
    CampaignsRead: 'CAMPAIGNS_READ',
    CampaignsCreate: 'CAMPAIGNS_CREATE',
    CampaignsDelete: 'CAMPAIGNS_DELETE',
    CampaignsUpdate: 'CAMPAIGNS_UPDATE',
    KeywordRead: 'KEYWORD_READ',
    KeywordCreate: 'KEYWORD_CREATE',
    KeywordDelete: 'KEYWORD_DELETE',
    KeywordUpdate: 'KEYWORD_UPDATE',
    TemplatesRead: 'TEMPLATES_READ',
    TemplatesCreate: 'TEMPLATES_CREATE',
    TemplatesDelete: 'TEMPLATES_DELETE',
    TemplatesUpdate: 'TEMPLATES_UPDATE',
    TagsRead: 'TAGS_READ',
    TagsCreate: 'TAGS_CREATE',
    TagsDelete: 'TAGS_DELETE',
    TokensRead: 'TOKENS_READ',
    TokensDelete: 'TOKENS_DELETE',
    UsersPatch: 'USERS_PATCH',
    TeamUpdate: 'TEAM_UPDATE',
    AccountCreate: 'ACCOUNT_CREATE',
    AccountRead: 'ACCOUNT_READ',
    AccountDelete: 'ACCOUNT_DELETE',
    AccountPatch: 'ACCOUNT_PATCH',
    TeamlinkCreate: 'TEAMLINK_CREATE',
    TeamlinkRead: 'TEAMLINK_READ',
    TeammembersUpdate: 'TEAMMEMBERS_UPDATE',
    TeammembersRead: 'TEAMMEMBERS_READ',
    TeamNotify: 'TEAM_NOTIFY',
    ChatsAccessAll: 'CHATS_ACCESS_ALL',
    ChatsAccessAssigned: 'CHATS_ACCESS_ASSIGNED',
    ChatsDelete: 'CHATS_DELETE',
    MessagesSendToAssigned: 'MESSAGES_SEND_TO_ASSIGNED',
    MessagesSendToAll: 'MESSAGES_SEND_TO_ALL',
    MessagesDelete: 'MESSAGES_DELETE',
    GroupsCreate: 'GROUPS_CREATE',
    GroupsUpdate: 'GROUPS_UPDATE',
    Notes: 'NOTES',
    NotificationRead: 'NOTIFICATION_READ',
    NotificationCreate: 'NOTIFICATION_CREATE',
    NotificationUpdate: 'NOTIFICATION_UPDATE',
    NotificationDelete: 'NOTIFICATION_DELETE',
    IntegrationsUpdate: 'INTEGRATIONS_UPDATE',
    AdminPanelAccess: 'ADMIN_PANEL_ACCESS',
    PaymentsRead: 'PAYMENTS_READ',
    PaymentsUpdate: 'PAYMENTS_UPDATE',
    WaLiveEvents: 'WA_LIVE_EVENTS',
    ChatdaddyHook: 'CHATDADDY_HOOK',
    PartnerAdminPanelAccess: 'PARTNER_ADMIN_PANEL_ACCESS',
    ProductsGet: 'PRODUCTS_GET',
    ProductsCreate: 'PRODUCTS_CREATE',
    ProductsUpdate: 'PRODUCTS_UPDATE',
    ProductsDelete: 'PRODUCTS_DELETE',
    PaymentIntegrationRead: 'PAYMENT_INTEGRATION_READ',
    PaymentIntegrationWrite: 'PAYMENT_INTEGRATION_WRITE',
    PaymentRecordsRead: 'PAYMENT_RECORDS_READ',
    PaymentRecordsWrite: 'PAYMENT_RECORDS_WRITE',
    MetricsGet: 'METRICS_GET',
    AccountsReadAssigned: 'ACCOUNTS_READ_ASSIGNED',
    AutocompleteGet: 'AUTOCOMPLETE_GET',
    MessagesSearch: 'MESSAGES_SEARCH'
} as const;

export type Scope = typeof Scope[keyof typeof Scope];


/**
 * 
 * @export
 * @interface SimpleNotificationPreference
 */
export interface SimpleNotificationPreference {
    /**
     * 
     * @type {Array<NotificationDestination>}
     * @memberof SimpleNotificationPreference
     */
    'destinations': Array<NotificationDestination>;
}
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'updatedAt': string;
    /**
     * Who created the team
     * @type {string}
     * @memberof Team
     */
    'createdBy'?: string;
    /**
     * 
     * @type {User}
     * @memberof Team
     */
    'creator'?: User;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name': string;
    /**
     * Is an admin team
     * @type {boolean}
     * @memberof Team
     */
    'isAdmin'?: boolean;
    /**
     * The max scopes allowed
     * @type {Array<Scope>}
     * @memberof Team
     */
    'scopes': Array<Scope>;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof Team
     */
    'metadata': TeamMetadata;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof Team
     */
    'members'?: Array<TeamMember>;
    /**
     * 
     * @type {Array<InviteLink>}
     * @memberof Team
     */
    'inviteLinks'?: Array<InviteLink>;
    /**
     * The team will be the admin team of a Chatdaddy partner if this property is not null.
     * @type {string}
     * @memberof Team
     */
    'partnerAdmin'?: string | null;
    /**
     * 
     * @type {Array<OnboardingStep>}
     * @memberof Team
     */
    'onboardingStepsDone'?: Array<OnboardingStep>;
    /**
     * The onboarding score of the team.
     * @type {number}
     * @memberof Team
     */
    'onboardingScore'?: number;
}
/**
 * 
 * @export
 * @interface TeamMember
 */
export interface TeamMember {
    /**
     * 
     * @type {Team}
     * @memberof TeamMember
     */
    'team'?: Team;
    /**
     * 
     * @type {User}
     * @memberof TeamMember
     */
    'user'?: User;
    /**
     * Unique identifier for a user
     * @type {string}
     * @memberof TeamMember
     */
    'userId': string;
    /**
     * Unique identifier for a team
     * @type {string}
     * @memberof TeamMember
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'addedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'addedBy'?: string | null;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof TeamMember
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface TeamMetadata
 */
export interface TeamMetadata {
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyEmailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyWebsite'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'industry'?: string;
}
/**
 * 
 * @export
 * @interface TeamPatchRequest
 */
export interface TeamPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof TeamPatchRequest
     */
    'metadata'?: TeamMetadata;
    /**
     * 
     * @type {Array<TeamPatchRequestMembersInner>}
     * @memberof TeamPatchRequest
     */
    'members'?: Array<TeamPatchRequestMembersInner>;
    /**
     * 
     * @type {Array<TeamPatchRequestInviteLinksInner>}
     * @memberof TeamPatchRequest
     */
    'inviteLinks'?: Array<TeamPatchRequestInviteLinksInner>;
}
/**
 * 
 * @export
 * @interface TeamPatchRequestInviteLinksInner
 */
export interface TeamPatchRequestInviteLinksInner {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequestInviteLinksInner
     */
    'id': string;
    /**
     * If set to true, will delete the invite link
     * @type {boolean}
     * @memberof TeamPatchRequestInviteLinksInner
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface TeamPatchRequestMembersInner
 */
export interface TeamPatchRequestMembersInner {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequestMembersInner
     */
    'id': string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof TeamPatchRequestMembersInner
     */
    'scopes'?: Array<Scope>;
    /**
     * If set to true, will delete the team member
     * @type {boolean}
     * @memberof TeamPatchRequestMembersInner
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface TeamsGet200Response
 */
export interface TeamsGet200Response {
    /**
     * 
     * @type {number}
     * @memberof TeamsGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Team>}
     * @memberof TeamsGet200Response
     */
    'teams': Array<Team>;
}
/**
 * 
 * @export
 * @interface TeamsPatch200Response
 */
export interface TeamsPatch200Response {
    /**
     * 
     * @type {boolean}
     * @memberof TeamsPatch200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface TokenGet400Response
 */
export interface TokenGet400Response {
    /**
     * 
     * @type {number}
     * @memberof TokenGet400Response
     */
    'statusCode'?: number;
    /**
     * Specific description of the error
     * @type {string}
     * @memberof TokenGet400Response
     */
    'error'?: string;
    /**
     * What the error was
     * @type {string}
     * @memberof TokenGet400Response
     */
    'message'?: string;
    /**
     * Some extra information about the error
     * @type {object}
     * @memberof TokenGet400Response
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface TokenPost200Response
 */
export interface TokenPost200Response {
    /**
     * 
     * @type {string}
     * @memberof TokenPost200Response
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPost200Response
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenPost200Response
     */
    'refresh_token_expiry'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenPost200Response
     */
    'was_forced'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenPostResponse
 */
export interface TokenPostResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'refresh_token_expiry'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'disabledAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName': string;
    /**
     * The last used team ID, your refresh token when logging in is generated for this team
     * @type {string}
     * @memberof User
     */
    'lastUsedTeamId'?: string;
    /**
     * Will only contain numbers, no + sign, brackets etc.
     * @type {number}
     * @memberof User
     */
    'phoneNumber': number | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {UserCreateMethod}
     * @memberof User
     */
    'createdByMethod'?: UserCreateMethod;
    /**
     * 
     * @type {NotifyModel}
     * @memberof User
     * @deprecated
     */
    'notify': NotifyModel;
    /**
     * 
     * @type {NotificationPreferences}
     * @memberof User
     */
    'notificationPreferences': NotificationPreferences;
    /**
     * The referral code used for sign-up
     * @type {string}
     * @memberof User
     */
    'referralCode'?: string | null;
    /**
     * The signature of the user to use in messages
     * @type {string}
     * @memberof User
     */
    'signature'?: string | null;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof User
     */
    'memberships'?: Array<TeamMember>;
    /**
     * 
     * @type {Array<WebPushSubscription>}
     * @memberof User
     */
    'webPushSubscriptions'?: Array<WebPushSubscription>;
    /**
     * The partnership the user has signed in with
     * @type {string}
     * @memberof User
     */
    'partnership'?: string | null;
}


/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'fullName': string;
    /**
     * Will only contain numbers, no + sign, brackets etc.
     * @type {number}
     * @memberof UserCreate
     */
    'phoneNumber': number;
    /**
     * SHA256 of the plaintext password pls
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof UserCreate
     */
    'metadata'?: TeamMetadata;
    /**
     * 
     * @type {NotifyModel}
     * @memberof UserCreate
     * @deprecated
     */
    'notify'?: NotifyModel;
    /**
     * 
     * @type {NotificationPreferences}
     * @memberof UserCreate
     */
    'notificationPreferences'?: NotificationPreferences;
    /**
     * Sign up with a referral code
     * @type {string}
     * @memberof UserCreate
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserCreateMethod = {
    AdminPanel: 'admin-panel',
    Otp: 'otp',
    Boutir: 'boutir',
    InstantReg: 'instant-reg',
    Firebase: 'firebase'
} as const;

export type UserCreateMethod = typeof UserCreateMethod[keyof typeof UserCreateMethod];


/**
 * 
 * @export
 * @interface UserPatch
 */
export interface UserPatch {
    /**
     * 
     * @type {string}
     * @memberof UserPatch
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPatch
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {NotifyModel}
     * @memberof UserPatch
     * @deprecated
     */
    'notify'?: NotifyModel;
    /**
     * 
     * @type {NotificationPreferences}
     * @memberof UserPatch
     */
    'notificationPreferences'?: NotificationPreferences;
    /**
     * Phone number. Only admin access can modify or specify OTP
     * @type {number}
     * @memberof UserPatch
     */
    'phoneNumber'?: number;
    /**
     * OTP to change password/phone number
     * @type {number}
     * @memberof UserPatch
     */
    'otp'?: number;
    /**
     * new password. Only admin access can modify
     * @type {string}
     * @memberof UserPatch
     */
    'password'?: string;
    /**
     * A signature of the user to be used at the end of the message
     * @type {string}
     * @memberof UserPatch
     */
    'signature'?: string;
    /**
     * 
     * @type {Array<WebPushSubscription>}
     * @memberof UserPatch
     */
    'webPushSubscriptions'?: Array<WebPushSubscription>;
    /**
     * add a user to a partnership manually
     * @type {string}
     * @memberof UserPatch
     */
    'partnership'?: string | null;
}
/**
 * 
 * @export
 * @interface UsersGet200Response
 */
export interface UsersGet200Response {
    /**
     * 
     * @type {number}
     * @memberof UsersGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersGet200Response
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface UsersPhoneNumberPatchRequest
 */
export interface UsersPhoneNumberPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof UsersPhoneNumberPatchRequest
     */
    'phoneNumber': number;
    /**
     * 
     * @type {string}
     * @memberof UsersPhoneNumberPatchRequest
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface WebPushNotification
 */
export interface WebPushNotification {
    /**
     * 
     * @type {string}
     * @memberof WebPushNotification
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof WebPushNotification
     */
    'text': string;
    /**
     * When true, the notification is only shown if the user is online
     * @type {boolean}
     * @memberof WebPushNotification
     */
    'onlineOnly'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WebPushNotification
     */
    'teamId': string;
    /**
     * The path to open when the notification is clicked
     * @type {string}
     * @memberof WebPushNotification
     */
    'path'?: string;
    /**
     * The image to show in the notification
     * @type {string}
     * @memberof WebPushNotification
     */
    'imgUrl'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebPushNotification
     */
    'context'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface WebPushSubscription
 */
export interface WebPushSubscription {
    /**
     * 
     * @type {string}
     * @memberof WebPushSubscription
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof WebPushSubscription
     */
    'authKey': string;
    /**
     * 
     * @type {string}
     * @memberof WebPushSubscription
     */
    'p256dhKey': string;
}

/**
 * InviteLinksApi - axios parameter creator
 * @export
 */
export const InviteLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('inviteLinksGet', 'id', id)
            const localVarPath = `/invite-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InviteLinksPostRequest} [inviteLinksPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksPost: async (inviteLinksPostRequest?: InviteLinksPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invite-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAMLINK_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLinksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteLinksApi - functional programming interface
 * @export
 */
export const InviteLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InviteLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteLinksGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteLinksGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InviteLinksPostRequest} [inviteLinksPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteLinksPost(inviteLinksPostRequest?: InviteLinksPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteLinksPost(inviteLinksPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InviteLinksApi - factory interface
 * @export
 */
export const InviteLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InviteLinksApiFp(configuration)
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {InviteLinksApiInviteLinksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksGet(requestParameters: InviteLinksApiInviteLinksGetRequest, options?: AxiosRequestConfig): AxiosPromise<InviteLink> {
            return localVarFp.inviteLinksGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InviteLinksApiInviteLinksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksPost(requestParameters: InviteLinksApiInviteLinksPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<InviteLink> {
            return localVarFp.inviteLinksPost(requestParameters.inviteLinksPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for inviteLinksGet operation in InviteLinksApi.
 * @export
 * @interface InviteLinksApiInviteLinksGetRequest
 */
export interface InviteLinksApiInviteLinksGetRequest {
    /**
     * the invite link ID
     * @type {string}
     * @memberof InviteLinksApiInviteLinksGet
     */
    readonly id: string
}

/**
 * Request parameters for inviteLinksPost operation in InviteLinksApi.
 * @export
 * @interface InviteLinksApiInviteLinksPostRequest
 */
export interface InviteLinksApiInviteLinksPostRequest {
    /**
     * 
     * @type {InviteLinksPostRequest}
     * @memberof InviteLinksApiInviteLinksPost
     */
    readonly inviteLinksPostRequest?: InviteLinksPostRequest
}

/**
 * InviteLinksApi - object-oriented interface
 * @export
 * @class InviteLinksApi
 * @extends {BaseAPI}
 */
export class InviteLinksApi extends BaseAPI {
    /**
     * 
     * @summary Get info about an invite link
     * @param {InviteLinksApiInviteLinksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteLinksApi
     */
    public inviteLinksGet(requestParameters: InviteLinksApiInviteLinksGetRequest, options?: AxiosRequestConfig) {
        return InviteLinksApiFp(this.configuration).inviteLinksGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
     * @summary Create an invite link for the team
     * @param {InviteLinksApiInviteLinksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteLinksApi
     */
    public inviteLinksPost(requestParameters: InviteLinksApiInviteLinksPostRequest = {}, options?: AxiosRequestConfig) {
        return InviteLinksApiFp(this.configuration).inviteLinksPost(requestParameters.inviteLinksPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete: async (token?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TOKENS_DELETE"], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TOKENS_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login to ChatDaddy
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: async (authRequest?: AuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {ExternalTokenRequest} [externalTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPostExternal: async (externalTokenRequest?: ExternalTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token/external`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenDelete(token?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDelete(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefreshToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login to ChatDaddy
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPost(authRequest?: AuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(authRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {ExternalTokenRequest} [externalTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPostExternal(externalTokenRequest?: ExternalTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalTokenPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPostExternal(externalTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {OAuthApiTokenDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete(requestParameters: OAuthApiTokenDeleteRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tokenDelete(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGet(options?: AxiosRequestConfig): AxiosPromise<Array<RefreshToken>> {
            return localVarFp.tokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login to ChatDaddy
         * @param {OAuthApiTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(requestParameters: OAuthApiTokenPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TokenPost200Response> {
            return localVarFp.tokenPost(requestParameters.authRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {OAuthApiTokenPostExternalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPostExternal(requestParameters: OAuthApiTokenPostExternalRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ExternalTokenPostResponse> {
            return localVarFp.tokenPostExternal(requestParameters.externalTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tokenDelete operation in OAuthApi.
 * @export
 * @interface OAuthApiTokenDeleteRequest
 */
export interface OAuthApiTokenDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof OAuthApiTokenDelete
     */
    readonly token?: string
}

/**
 * Request parameters for tokenPost operation in OAuthApi.
 * @export
 * @interface OAuthApiTokenPostRequest
 */
export interface OAuthApiTokenPostRequest {
    /**
     * 
     * @type {AuthRequest}
     * @memberof OAuthApiTokenPost
     */
    readonly authRequest?: AuthRequest
}

/**
 * Request parameters for tokenPostExternal operation in OAuthApi.
 * @export
 * @interface OAuthApiTokenPostExternalRequest
 */
export interface OAuthApiTokenPostExternalRequest {
    /**
     * 
     * @type {ExternalTokenRequest}
     * @memberof OAuthApiTokenPostExternal
     */
    readonly externalTokenRequest?: ExternalTokenRequest
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * If the token is not specified, all tokens of the user are revoked
     * @summary Revoke refresh tokens
     * @param {OAuthApiTokenDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenDelete(requestParameters: OAuthApiTokenDeleteRequest = {}, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenDelete(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns in descending order of most recently used
     * @summary Fetch list of tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenGet(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login to ChatDaddy
     * @param {OAuthApiTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenPost(requestParameters: OAuthApiTokenPostRequest = {}, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenPost(requestParameters.authRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login via an external partner
     * @param {OAuthApiTokenPostExternalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenPostExternal(requestParameters: OAuthApiTokenPostExternalRequest = {}, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenPostExternal(requestParameters.externalTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OTPApi - axios parameter creator
 * @export
 */
export const OTPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Confirm OTP while checkout products.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOtp: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verify-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate an OTP
         * @param {OtpPostRequest} [otpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpPost: async (otpPostRequest?: OtpPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(otpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate an OTP token
         * @param {OtpTokenPostRequest} [otpTokenPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpTokenPost: async (otpTokenPostRequest?: OtpTokenPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/otp/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(otpTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OTPApi - functional programming interface
 * @export
 */
export const OTPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OTPApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Confirm OTP while checkout products.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmOtp(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmOtp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmOtp(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate an OTP
         * @param {OtpPostRequest} [otpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async otpPost(otpPostRequest?: OtpPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OTP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.otpPost(otpPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate an OTP token
         * @param {OtpTokenPostRequest} [otpTokenPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async otpTokenPost(otpTokenPostRequest?: OtpTokenPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OtpTokenPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.otpTokenPost(otpTokenPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OTPApi - factory interface
 * @export
 */
export const OTPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OTPApiFp(configuration)
    return {
        /**
         * 
         * @summary Confirm OTP while checkout products.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOtp(options?: AxiosRequestConfig): AxiosPromise<ConfirmOtp200Response> {
            return localVarFp.confirmOtp(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate an OTP
         * @param {OTPApiOtpPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpPost(requestParameters: OTPApiOtpPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<OTP> {
            return localVarFp.otpPost(requestParameters.otpPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate an OTP token
         * @param {OTPApiOtpTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpTokenPost(requestParameters: OTPApiOtpTokenPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<OtpTokenPost200Response> {
            return localVarFp.otpTokenPost(requestParameters.otpTokenPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for otpPost operation in OTPApi.
 * @export
 * @interface OTPApiOtpPostRequest
 */
export interface OTPApiOtpPostRequest {
    /**
     * 
     * @type {OtpPostRequest}
     * @memberof OTPApiOtpPost
     */
    readonly otpPostRequest?: OtpPostRequest
}

/**
 * Request parameters for otpTokenPost operation in OTPApi.
 * @export
 * @interface OTPApiOtpTokenPostRequest
 */
export interface OTPApiOtpTokenPostRequest {
    /**
     * 
     * @type {OtpTokenPostRequest}
     * @memberof OTPApiOtpTokenPost
     */
    readonly otpTokenPostRequest?: OtpTokenPostRequest
}

/**
 * OTPApi - object-oriented interface
 * @export
 * @class OTPApi
 * @extends {BaseAPI}
 */
export class OTPApi extends BaseAPI {
    /**
     * 
     * @summary Confirm OTP while checkout products.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public confirmOtp(options?: AxiosRequestConfig) {
        return OTPApiFp(this.configuration).confirmOtp(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate an OTP
     * @param {OTPApiOtpPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public otpPost(requestParameters: OTPApiOtpPostRequest = {}, options?: AxiosRequestConfig) {
        return OTPApiFp(this.configuration).otpPost(requestParameters.otpPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate an OTP token
     * @param {OTPApiOtpTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public otpTokenPost(requestParameters: OTPApiOtpTokenPostRequest = {}, options?: AxiosRequestConfig) {
        return OTPApiFp(this.configuration).otpTokenPost(requestParameters.otpTokenPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
         * @param {string} teamId the teamId of the team to be upgraded/downgraded
         * @param {PartnerTeamPatchRequest} [partnerTeamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTeamPatch: async (teamId: string, partnerTeamPatchRequest?: PartnerTeamPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('partnerTeamPatch', 'teamId', teamId)
            const localVarPath = `/teams/partner-team-status/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerTeamPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark a team as having completed an onboarding step
         * @param {OnboardingStepID} step the onboarding step to mark as completed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsCompletedOnboardingStepPost: async (step: OnboardingStepID, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'step' is not null or undefined
            assertParamExists('teamsCompletedOnboardingStepPost', 'step', step)
            const localVarPath = `/teams/completed-onboarding-step/{step}`
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {string} [partnership] Search by partnership
         * @param {number} [onboardingScoreMin] The minimum onboarding score of the teams to return
         * @param {number} [onboardingScoreMax] The maximum onboarding score of the teams to return
         * @param {string} [createdAfter] Teams after a given date-time
         * @param {Array<OnboardingStepID>} [completedSteps] Teams that have completed the given Steps
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {string} [partner] string to identify user with a partner
         * @param {boolean} [returnOnboardingScore] return the onboarding score for the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet: async (q?: string, partnership?: string, onboardingScoreMin?: number, onboardingScoreMax?: number, createdAfter?: string, completedSteps?: Array<OnboardingStepID>, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, partner?: string, returnOnboardingScore?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (partnership !== undefined) {
                localVarQueryParameter['partnership'] = partnership;
            }

            if (onboardingScoreMin !== undefined) {
                localVarQueryParameter['onboardingScoreMin'] = onboardingScoreMin;
            }

            if (onboardingScoreMax !== undefined) {
                localVarQueryParameter['onboardingScoreMax'] = onboardingScoreMax;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (completedSteps) {
                localVarQueryParameter['completedSteps'] = completedSteps;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includeTeamMembers !== undefined) {
                localVarQueryParameter['includeTeamMembers'] = includeTeamMembers;
            }

            if (includeInviteLinks !== undefined) {
                localVarQueryParameter['includeInviteLinks'] = includeInviteLinks;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['includeTotal'] = includeTotal;
            }

            if (includeCreator !== undefined) {
                localVarQueryParameter['includeCreator'] = includeCreator;
            }

            if (partner !== undefined) {
                localVarQueryParameter['partner'] = partner;
            }

            if (returnOnboardingScore !== undefined) {
                localVarQueryParameter['returnOnboardingScore'] = returnOnboardingScore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsJoinInvite: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamsJoinInvite', 'id', id)
            const localVarPath = `/teams/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPatch: async (teamPatchRequest?: TeamPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAM_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
         * @param {string} teamId the teamId of the team to be upgraded/downgraded
         * @param {PartnerTeamPatchRequest} [partnerTeamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTeamPatch(teamId: string, partnerTeamPatchRequest?: PartnerTeamPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTeamPatch(teamId, partnerTeamPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark a team as having completed an onboarding step
         * @param {OnboardingStepID} step the onboarding step to mark as completed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsCompletedOnboardingStepPost(step: OnboardingStepID, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsCompletedOnboardingStepPost(step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {string} [partnership] Search by partnership
         * @param {number} [onboardingScoreMin] The minimum onboarding score of the teams to return
         * @param {number} [onboardingScoreMax] The maximum onboarding score of the teams to return
         * @param {string} [createdAfter] Teams after a given date-time
         * @param {Array<OnboardingStepID>} [completedSteps] Teams that have completed the given Steps
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {string} [partner] string to identify user with a partner
         * @param {boolean} [returnOnboardingScore] return the onboarding score for the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsGet(q?: string, partnership?: string, onboardingScoreMin?: number, onboardingScoreMax?: number, createdAfter?: string, completedSteps?: Array<OnboardingStepID>, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, partner?: string, returnOnboardingScore?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsGet(q, partnership, onboardingScoreMin, onboardingScoreMax, createdAfter, completedSteps, id, userId, count, page, includeTeamMembers, includeInviteLinks, includeTotal, includeCreator, partner, returnOnboardingScore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsJoinInvite(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsJoinInvite(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsPatch(teamPatchRequest?: TeamPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsPatch(teamPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * 
         * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
         * @param {TeamsApiPartnerTeamPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTeamPatch(requestParameters: TeamsApiPartnerTeamPatchRequest, options?: AxiosRequestConfig): AxiosPromise<TeamsPatch200Response> {
            return localVarFp.partnerTeamPatch(requestParameters.teamId, requestParameters.partnerTeamPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark a team as having completed an onboarding step
         * @param {TeamsApiTeamsCompletedOnboardingStepPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsCompletedOnboardingStepPost(requestParameters: TeamsApiTeamsCompletedOnboardingStepPostRequest, options?: AxiosRequestConfig): AxiosPromise<TeamsPatch200Response> {
            return localVarFp.teamsCompletedOnboardingStepPost(requestParameters.step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {TeamsApiTeamsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet(requestParameters: TeamsApiTeamsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TeamsGet200Response> {
            return localVarFp.teamsGet(requestParameters.q, requestParameters.partnership, requestParameters.onboardingScoreMin, requestParameters.onboardingScoreMax, requestParameters.createdAfter, requestParameters.completedSteps, requestParameters.id, requestParameters.userId, requestParameters.count, requestParameters.page, requestParameters.includeTeamMembers, requestParameters.includeInviteLinks, requestParameters.includeTotal, requestParameters.includeCreator, requestParameters.partner, requestParameters.returnOnboardingScore, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a team
         * @param {TeamsApiTeamsJoinInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsJoinInvite(requestParameters: TeamsApiTeamsJoinInviteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.teamsJoinInvite(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
         * @summary Update the team the access token is for
         * @param {TeamsApiTeamsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPatch(requestParameters: TeamsApiTeamsPatchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TeamsPatch200Response> {
            return localVarFp.teamsPatch(requestParameters.teamPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for partnerTeamPatch operation in TeamsApi.
 * @export
 * @interface TeamsApiPartnerTeamPatchRequest
 */
export interface TeamsApiPartnerTeamPatchRequest {
    /**
     * the teamId of the team to be upgraded/downgraded
     * @type {string}
     * @memberof TeamsApiPartnerTeamPatch
     */
    readonly teamId: string

    /**
     * 
     * @type {PartnerTeamPatchRequest}
     * @memberof TeamsApiPartnerTeamPatch
     */
    readonly partnerTeamPatchRequest?: PartnerTeamPatchRequest
}

/**
 * Request parameters for teamsCompletedOnboardingStepPost operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsCompletedOnboardingStepPostRequest
 */
export interface TeamsApiTeamsCompletedOnboardingStepPostRequest {
    /**
     * the onboarding step to mark as completed
     * @type {OnboardingStepID}
     * @memberof TeamsApiTeamsCompletedOnboardingStepPost
     */
    readonly step: OnboardingStepID
}

/**
 * Request parameters for teamsGet operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsGetRequest
 */
export interface TeamsApiTeamsGetRequest {
    /**
     * Search by name, ID, invite code, etc.
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly q?: string

    /**
     * Search by partnership
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly partnership?: string

    /**
     * The minimum onboarding score of the teams to return
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly onboardingScoreMin?: number

    /**
     * The maximum onboarding score of the teams to return
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly onboardingScoreMax?: number

    /**
     * Teams after a given date-time
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly createdAfter?: string

    /**
     * Teams that have completed the given Steps
     * @type {Array<OnboardingStepID>}
     * @memberof TeamsApiTeamsGet
     */
    readonly completedSteps?: Array<OnboardingStepID>

    /**
     * Fetch specific teams by ID
     * @type {Array<string>}
     * @memberof TeamsApiTeamsGet
     */
    readonly id?: Array<string>

    /**
     * teams that contain this user ID
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly userId?: string

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly count?: number

    /**
     * The page number
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly page?: number

    /**
     * Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeTeamMembers?: boolean

    /**
     * Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeInviteLinks?: boolean

    /**
     * include the count of the total teams
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeTotal?: boolean

    /**
     * include the creator\&#39;s data in the API result
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeCreator?: boolean

    /**
     * string to identify user with a partner
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly partner?: string

    /**
     * return the onboarding score for the team
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly returnOnboardingScore?: boolean
}

/**
 * Request parameters for teamsJoinInvite operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsJoinInviteRequest
 */
export interface TeamsApiTeamsJoinInviteRequest {
    /**
     * inviteLink ID
     * @type {string}
     * @memberof TeamsApiTeamsJoinInvite
     */
    readonly id: string
}

/**
 * Request parameters for teamsPatch operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsPatchRequest
 */
export interface TeamsApiTeamsPatchRequest {
    /**
     * 
     * @type {TeamPatchRequest}
     * @memberof TeamsApiTeamsPatch
     */
    readonly teamPatchRequest?: TeamPatchRequest
}

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * 
     * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
     * @param {TeamsApiPartnerTeamPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public partnerTeamPatch(requestParameters: TeamsApiPartnerTeamPatchRequest, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).partnerTeamPatch(requestParameters.teamId, requestParameters.partnerTeamPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark a team as having completed an onboarding step
     * @param {TeamsApiTeamsCompletedOnboardingStepPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsCompletedOnboardingStepPost(requestParameters: TeamsApiTeamsCompletedOnboardingStepPostRequest, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsCompletedOnboardingStepPost(requestParameters.step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch teams you have access to
     * @param {TeamsApiTeamsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsGet(requestParameters: TeamsApiTeamsGetRequest = {}, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsGet(requestParameters.q, requestParameters.partnership, requestParameters.onboardingScoreMin, requestParameters.onboardingScoreMax, requestParameters.createdAfter, requestParameters.completedSteps, requestParameters.id, requestParameters.userId, requestParameters.count, requestParameters.page, requestParameters.includeTeamMembers, requestParameters.includeInviteLinks, requestParameters.includeTotal, requestParameters.includeCreator, requestParameters.partner, requestParameters.returnOnboardingScore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a team
     * @param {TeamsApiTeamsJoinInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsJoinInvite(requestParameters: TeamsApiTeamsJoinInviteRequest, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsJoinInvite(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned 
     * @summary Update the team the access token is for
     * @param {TeamsApiTeamsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsPatch(requestParameters: TeamsApiTeamsPatchRequest = {}, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsPatch(requestParameters.teamPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDelete', 'id', id)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {string} [partnership] Search by partnership
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (q?: string, partnership?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (partnership !== undefined) {
                localVarQueryParameter['partnership'] = partnership;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (originalTeamId) {
                localVarQueryParameter['originalTeamId'] = originalTeamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includeMemberships !== undefined) {
                localVarQueryParameter['includeMemberships'] = includeMemberships;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['includeTotal'] = includeTotal;
            }

            if (other) {
                localVarQueryParameter['other'] = other;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPasswordPatch: async (resetPassword?: ResetPassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch: async (userId?: string, userPatch?: UserPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["USERS_PATCH"], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates users Phonenumber
         * @param {UsersPhoneNumberPatchRequest} [usersPhoneNumberPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPhoneNumberPatch: async (usersPhoneNumberPatchRequest?: UsersPhoneNumberPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/phonenumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPhoneNumberPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (userCreate?: UserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {string} [partnership] Search by partnership
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(q?: string, partnership?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(q, partnership, id, originalTeamId, count, page, includeMemberships, includeTotal, other, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPasswordPatch(resetPassword?: ResetPassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPasswordPatch(resetPassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPatch(userId?: string, userPatch?: UserPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPatch(userId, userPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates users Phonenumber
         * @param {UsersPhoneNumberPatchRequest} [usersPhoneNumberPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPhoneNumberPatch(usersPhoneNumberPatchRequest?: UsersPhoneNumberPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPhoneNumberPatch(usersPhoneNumberPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(userCreate?: UserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {UsersApiUsersDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete(requestParameters: UsersApiUsersDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {UsersApiUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(requestParameters: UsersApiUsersGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<UsersGet200Response> {
            return localVarFp.usersGet(requestParameters.q, requestParameters.partnership, requestParameters.id, requestParameters.originalTeamId, requestParameters.count, requestParameters.page, requestParameters.includeMemberships, requestParameters.includeTotal, requestParameters.other, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset user password
         * @param {UsersApiUsersPasswordPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPasswordPatch(requestParameters: UsersApiUsersPasswordPatchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersPasswordPatch(requestParameters.resetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {UsersApiUsersPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch(requestParameters: UsersApiUsersPatchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPatch(requestParameters.userId, requestParameters.userPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates users Phonenumber
         * @param {UsersApiUsersPhoneNumberPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPhoneNumberPatch(requestParameters: UsersApiUsersPhoneNumberPatchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersPhoneNumberPatch(requestParameters.usersPhoneNumberPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {UsersApiUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(requestParameters: UsersApiUsersPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPost(requestParameters.userCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersDeleteRequest
 */
export interface UsersApiUsersDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersDelete
     */
    readonly id: string
}

/**
 * Request parameters for usersGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersGetRequest
 */
export interface UsersApiUsersGetRequest {
    /**
     * Search by name, ID, email, phone etc.
     * @type {string}
     * @memberof UsersApiUsersGet
     */
    readonly q?: string

    /**
     * Search by partnership
     * @type {string}
     * @memberof UsersApiUsersGet
     */
    readonly partnership?: string

    /**
     * Fetch specific users by ID
     * @type {Array<string>}
     * @memberof UsersApiUsersGet
     */
    readonly id?: Array<string>

    /**
     * Fetch specific users by original team ID
     * @type {Array<string>}
     * @memberof UsersApiUsersGet
     */
    readonly originalTeamId?: Array<string>

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof UsersApiUsersGet
     */
    readonly count?: number

    /**
     * The page number
     * @type {number}
     * @memberof UsersApiUsersGet
     */
    readonly page?: number

    /**
     * Should include the user\&#39;s memberships
     * @type {boolean}
     * @memberof UsersApiUsersGet
     */
    readonly includeMemberships?: boolean

    /**
     * should return total count of accessible users
     * @type {boolean}
     * @memberof UsersApiUsersGet
     */
    readonly includeTotal?: boolean

    /**
     * other internal query options
     * @type {Array<string>}
     * @memberof UsersApiUsersGet
     */
    readonly other?: Array<string>
}

/**
 * Request parameters for usersPasswordPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersPasswordPatchRequest
 */
export interface UsersApiUsersPasswordPatchRequest {
    /**
     * 
     * @type {ResetPassword}
     * @memberof UsersApiUsersPasswordPatch
     */
    readonly resetPassword?: ResetPassword
}

/**
 * Request parameters for usersPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersPatchRequest
 */
export interface UsersApiUsersPatchRequest {
    /**
     * Change the password of this user ID
     * @type {string}
     * @memberof UsersApiUsersPatch
     */
    readonly userId?: string

    /**
     * 
     * @type {UserPatch}
     * @memberof UsersApiUsersPatch
     */
    readonly userPatch?: UserPatch
}

/**
 * Request parameters for usersPhoneNumberPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersPhoneNumberPatchRequest
 */
export interface UsersApiUsersPhoneNumberPatchRequest {
    /**
     * 
     * @type {UsersPhoneNumberPatchRequest}
     * @memberof UsersApiUsersPhoneNumberPatch
     */
    readonly usersPhoneNumberPatchRequest?: UsersPhoneNumberPatchRequest
}

/**
 * Request parameters for usersPost operation in UsersApi.
 * @export
 * @interface UsersApiUsersPostRequest
 */
export interface UsersApiUsersPostRequest {
    /**
     * 
     * @type {UserCreate}
     * @memberof UsersApiUsersPost
     */
    readonly userCreate?: UserCreate
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Deletes the user specified
     * @summary Delete a user
     * @param {UsersApiUsersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDelete(requestParameters: UsersApiUsersDeleteRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch users you have access to
     * @param {UsersApiUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(requestParameters: UsersApiUsersGetRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGet(requestParameters.q, requestParameters.partnership, requestParameters.id, requestParameters.originalTeamId, requestParameters.count, requestParameters.page, requestParameters.includeMemberships, requestParameters.includeTotal, requestParameters.other, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset user password
     * @param {UsersApiUsersPasswordPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPasswordPatch(requestParameters: UsersApiUsersPasswordPatchRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPasswordPatch(requestParameters.resetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the user in the access token
     * @param {UsersApiUsersPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPatch(requestParameters: UsersApiUsersPatchRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPatch(requestParameters.userId, requestParameters.userPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates users Phonenumber
     * @param {UsersApiUsersPhoneNumberPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPhoneNumberPatch(requestParameters: UsersApiUsersPhoneNumberPatchRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPhoneNumberPatch(requestParameters.usersPhoneNumberPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {UsersApiUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(requestParameters: UsersApiUsersPostRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPost(requestParameters.userCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


